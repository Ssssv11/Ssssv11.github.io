<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CMicrosoft+YaHei:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CMonaco:300,300italic,400,400italic,700,700italic%7CMenlo:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ssssv11.github.io","root":"/","images":"/images","scheme":"Pisces","version":"8.2.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="MySQL优化">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL优化">
<meta property="og:url" content="https://ssssv11.github.io/2022/05/12/MySQL%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="Ssssv">
<meta property="og:description" content="MySQL优化">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/12/OBkxqs.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/12/OBWnFU.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/12/OBLTBD.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/ODF3Pf.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/ODF2L9.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/ODkfXQ.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/ODAl38.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/ODA03T.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/ODEyz8.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/ODZYHH.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/OrUdQU.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/OrRYxH.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/OrWHtf.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/OrWsTx.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/Orfzxe.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/OrhyRO.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/OrHR91.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/OrbEvV.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/OrbcqS.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/OrOvGj.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/OrvqZ6.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/Oslk7V.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/OsLyoF.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/OsLOSA.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/OsOsXt.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/OsOmwT.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/OsXtvn.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/OsXy8J.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/Osz8Zq.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/Oy9FsJ.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/OyCA1S.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/OyCvCV.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/OyPxII.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/OyVHzt.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/Oy1Vwq.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/Oy1tk6.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/Oy1T7q.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/Oy3aEq.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/OyNi4I.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/Oy0X8A.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/OyDDTU.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/14/OyrkXq.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/14/OyrJHK.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/14/Oy6SAK.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/14/O627TI.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/14/O6fYTA.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/14/O6XwUf.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/14/OcpQUI.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/14/Oc3LI1.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/14/Octets.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/14/OcNRIJ.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/14/OcUmQ0.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/14/Oc0fvn.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/14/OcD6pQ.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/14/OcsAxJ.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/14/OcyQwq.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/14/Oc4wBF.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/14/Oc56aQ.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/15/OgeTmt.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/15/O2KyQg.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/15/O2QjxO.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/OWWgBT.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/OWfXLV.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/OWhaWj.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/OW5BZV.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/OWqnFx.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/OWqGmd.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/OWvcWt.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/OfiAC4.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/OfE4mR.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/OfVkcQ.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/OfMiad.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/OfM7SP.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/OfQSWq.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/OfwoM4.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/Of0H1S.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/OfByEn.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/OfB5DJ.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/OfrztI.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/OfgpVg.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/Of2uOf.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/OfTqjH.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/OfHudI.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/OfXJVH.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/OfXTZ4.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/OfjFJI.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/OfjeOS.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/OfjaTJ.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/OfjFJI.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/Ofx5sf.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/Ofz6XV.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/OhSm3n.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/OhpYdS.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/Ohp2i4.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/Oh9vh4.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/OhPtIO.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/OhP7wV.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/Ohi0tU.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/Ohiv4S.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/16/OhFlHx.png">
<meta property="article:published_time" content="2022-05-12T09:17:08.767Z">
<meta property="article:modified_time" content="2022-05-16T13:31:54.094Z">
<meta property="article:author" content="Ssssv11">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s1.ax1x.com/2022/05/12/OBkxqs.png">


<link rel="canonical" href="https://ssssv11.github.io/2022/05/12/MySQL%E4%BC%98%E5%8C%96/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>
<title>MySQL优化 | Ssssv</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Ssssv</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">24</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">41</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA-SQL-%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C"><span class="nav-number">1.</span> <span class="nav-text">一个 SQL 如何执行</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">MySQL 软件架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%88Connectors%EF%BC%89"><span class="nav-number">1.1.1.</span> <span class="nav-text">客户端（Connectors）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%BB%84%E4%BB%B6%EF%BC%88Connection-Pool%EF%BC%89"><span class="nav-number">1.1.2.</span> <span class="nav-text">连接池组件（Connection Pool）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6%EF%BC%88Management-Services-amp-Utillties%EF%BC%89"><span class="nav-number">1.1.3.</span> <span class="nav-text">管理服务和工具组件（Management Services &amp; Utillties）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL-%E6%8E%A5%E5%8F%A3%E7%BB%84%E4%BB%B6%EF%BC%88SQL-Interface%EF%BC%89"><span class="nav-number">1.1.4.</span> <span class="nav-text">SQL 接口组件（SQL Interface）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90%E5%99%A8%E7%BB%84%E4%BB%B6%EF%BC%88Parse%EF%BC%89"><span class="nav-number">1.1.5.</span> <span class="nav-text">解析器组件（Parse）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E5%99%A8%E7%BB%84%E4%BB%B6%EF%BC%88Optimizer%EF%BC%89"><span class="nav-number">1.1.6.</span> <span class="nav-text">优化器组件（Optimizer）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%BB%84%E4%BB%B6%EF%BC%88Caches-amp-Buffers%EF%BC%89"><span class="nav-number">1.1.7.</span> <span class="nav-text">缓存组件（Caches &amp; Buffers）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%8E%A5%E5%8F%A3%EF%BC%88Pluggable-Storage-Engines-Memory-Index-amp-Storage-Management%EF%BC%89"><span class="nav-number">1.1.8.</span> <span class="nav-text">存储引擎接口（Pluggable Storage Engines Memory, Index &amp; Storage Management）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E-MySQL-%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F"><span class="nav-number">1.2.</span> <span class="nav-text">客户端与 MySQL 的连接方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-x2F-IP-%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.2.1.</span> <span class="nav-text">TCP&#x2F;IP 连接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A4%E8%AF%81%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">认证连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">执行命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">断开连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL-TCP-%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">MySQL TCP 报文格式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-number">1.2.2.</span> <span class="nav-text">命名管道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-number">1.2.3.</span> <span class="nav-text">共享内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UNIX-%E5%9F%9F%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="nav-number">1.2.4.</span> <span class="nav-text">UNIX 域套接字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL-%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="nav-number">1.3.</span> <span class="nav-text">SQL 语句执行机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">1.4.</span> <span class="nav-text">MySQL 的存储引擎</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%BB%BA%E8%A1%A8%E6%9B%B4%E7%AC%A6%E5%90%88%E4%B8%9A%E5%8A%A1"><span class="nav-number">2.</span> <span class="nav-text">如何建表更符合业务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%BB%84%E7%BB%87%E8%A1%A8"><span class="nav-number">2.1.</span> <span class="nav-text">索引组织表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95"><span class="nav-number">2.1.1.</span> <span class="nav-text">索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE"><span class="nav-number">2.1.2.</span> <span class="nav-text">主键</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%AE%97%E6%B3%95"><span class="nav-number">2.2.</span> <span class="nav-text">索引算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E6%B5%81%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="nav-number">2.2.1.</span> <span class="nav-text">主流索引查找算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB-%E7%B4%A2%E5%BC%95%E5%8D%B3%E6%95%B0%E6%8D%AE"><span class="nav-number">2.3.</span> <span class="nav-text">InnoDB 索引即数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#B-%E6%A0%91%E7%B4%A2%E5%BC%95"><span class="nav-number">2.3.1.</span> <span class="nav-text">B+ 树索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="nav-number">2.3.2.</span> <span class="nav-text">聚簇索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95"><span class="nav-number">2.3.3.</span> <span class="nav-text">辅助索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB-%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8"><span class="nav-number">2.4.</span> <span class="nav-text">InnoDB 数据表的存储</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB-%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">2.4.1.</span> <span class="nav-text">InnoDB 逻辑存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E7%A9%BA%E9%97%B4-TableSpace"><span class="nav-number">2.4.2.</span> <span class="nav-text">表空间(TableSpace)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AE%B5-Segment"><span class="nav-number">2.4.3.</span> <span class="nav-text">段(Segment)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA-Extent"><span class="nav-number">2.4.4.</span> <span class="nav-text">区(Extent)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5-Page-x2F-%E8%A1%8C-Row"><span class="nav-number">2.4.5.</span> <span class="nav-text">页(Page)&#x2F;行(Row)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB-%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A1%8C"><span class="nav-number">2.5.</span> <span class="nav-text">InnoDB 的数据行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%95%BF%E5%88%97"><span class="nav-number">2.5.1.</span> <span class="nav-text">变长列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%8C%E6%BA%A2%E5%87%BA%E6%95%B0%E6%8D%AE"><span class="nav-number">2.5.2.</span> <span class="nav-text">行溢出数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%8C%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F-Row-Format"><span class="nav-number">2.5.3.</span> <span class="nav-text">行记录格式(Row Format)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Redundant"><span class="nav-number">2.5.3.1.</span> <span class="nav-text">Redundant</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Compact"><span class="nav-number">2.5.3.2.</span> <span class="nav-text">Compact</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dynamic"><span class="nav-number">2.5.3.3.</span> <span class="nav-text">Dynamic</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Compressed"><span class="nav-number">2.5.3.4.</span> <span class="nav-text">Compressed</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E2%80%9C%E5%B7%A6%E4%BE%A7%E7%94%A8%E6%B3%95%E2%80%9D"><span class="nav-number">2.6.</span> <span class="nav-text">索引的“左侧用法”</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="nav-number">2.6.1.</span> <span class="nav-text">联合索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="nav-number">2.6.2.</span> <span class="nav-text">字符串的前缀索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-Like"><span class="nav-number">2.6.3.</span> <span class="nav-text">字符串 Like</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%A6%E6%9D%9F%E6%95%B0%E6%8D%AE"><span class="nav-number">2.7.</span> <span class="nav-text">约束数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB-%E7%BA%A6%E6%9D%9F%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">2.7.1.</span> <span class="nav-text">InnoDB 约束数据的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A1%A8"><span class="nav-number">2.8.</span> <span class="nav-text">使用不存在的数据表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE-View"><span class="nav-number">2.8.1.</span> <span class="nav-text">视图(View)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-number">2.8.2.</span> <span class="nav-text">视图算法的选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8-MERGE-%E7%9A%84-SQL"><span class="nav-number">2.8.3.</span> <span class="nav-text">无法使用 MERGE 的 SQL</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">2.9.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%8E%E6%A0%B7%E6%9F%A5%E8%AF%A2%E9%80%9F%E5%BA%A6%E6%9B%B4%E5%BF%AB"><span class="nav-number">3.</span> <span class="nav-text">怎样查询速度更快</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85"><span class="nav-number">3.1.</span> <span class="nav-text">示例数据库的安装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Sakila-db"><span class="nav-number">3.1.1.</span> <span class="nav-text">Sakila-db</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WHERE-%E6%9F%A5%E8%AF%A2%E5%A4%AA%E6%85%A2"><span class="nav-number">3.2.</span> <span class="nav-text">WHERE 查询太慢</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="nav-number">3.2.1.</span> <span class="nav-text">覆盖索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">3.2.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E6%9B%B4%E5%90%88%E9%80%82%E7%9A%84%E7%B4%A2%E5%BC%95%E4%B8%8D%E8%B5%B0"><span class="nav-number">3.3.</span> <span class="nav-text">有更合适的索引不走</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E7%94%A8%E5%93%AA%E6%9D%A1%E7%B4%A2%E5%BC%95"><span class="nav-number">3.3.1.</span> <span class="nav-text">如何确定用哪条索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">3.3.2.</span> <span class="nav-text">基数的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="nav-number">3.3.3.</span> <span class="nav-text">强制使用索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E7%B4%A2%E5%BC%95"><span class="nav-number">3.3.4.</span> <span class="nav-text">优化索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#COUNT-%E6%9F%A5%E8%AF%A2%E5%A4%AA%E6%85%A2"><span class="nav-number">3.4.</span> <span class="nav-text">COUNT 查询太慢</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL-COUNT-%E5%87%BD%E6%95%B0"><span class="nav-number">3.4.1.</span> <span class="nav-text">MySQL COUNT() 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#COUNT-%E9%9D%9E%E7%B4%A2%E5%BC%95%E5%AD%97%E6%AE%B5"><span class="nav-number">3.4.2.</span> <span class="nav-text">COUNT(非索引字段)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#COUNT-%E7%B4%A2%E5%BC%95%E5%AD%97%E6%AE%B5"><span class="nav-number">3.4.3.</span> <span class="nav-text">COUNT(索引字段)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#COUNT-1"><span class="nav-number">3.4.4.</span> <span class="nav-text">COUNT(1)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#COUNT"><span class="nav-number">3.4.5.</span> <span class="nav-text">COUNT(*)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-number">3.4.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ORDER-BY-%E6%9F%A5%E8%AF%A2%E5%A4%AA%E6%85%A2"><span class="nav-number">3.5.</span> <span class="nav-text">ORDER BY 查询太慢</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ORDER-BY-%E6%89%A7%E8%A1%8C%E6%AD%A5%E9%AA%A4%E5%8E%9F%E7%90%86"><span class="nav-number">3.5.1.</span> <span class="nav-text">ORDER BY 执行步骤原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2"><span class="nav-number">3.5.2.</span> <span class="nav-text">优化条件查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E4%B8%AD%E9%97%B4%E7%BB%93%E6%9E%9C%E9%9B%86"><span class="nav-number">3.5.3.</span> <span class="nav-text">优化中间结果集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E5%9B%9E%E8%A1%A8"><span class="nav-number">3.5.4.</span> <span class="nav-text">优化回表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95-1"><span class="nav-number">3.5.5.</span> <span class="nav-text">覆盖索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-3"><span class="nav-number">3.5.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E9%80%89%E5%8F%96%E5%A4%AA%E6%85%A2"><span class="nav-number">3.6.</span> <span class="nav-text">随机选取太慢</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ORDER-BY-RAND-%E5%8E%9F%E7%90%86"><span class="nav-number">3.6.1.</span> <span class="nav-text">ORDER BY RAND() 原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%B8%8D%E5%A5%BD%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">3.6.2.</span> <span class="nav-text">性能不好的原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B4%E6%97%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">3.6.3.</span> <span class="nav-text">临时解决方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%9A%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">3.6.4.</span> <span class="nav-text">业务解决方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-4"><span class="nav-number">3.6.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%A6%E5%A4%B4%E5%A4%A7%E5%93%A5%E4%B8%A2%E4%BA%86"><span class="nav-number">3.7.</span> <span class="nav-text">带头大哥丢了</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="nav-number">3.7.1.</span> <span class="nav-text">索引下推</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%B7%B3%E8%B7%83%E6%89%AB%E6%8F%8F"><span class="nav-number">3.7.2.</span> <span class="nav-text">索引跳跃扫描</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="nav-number">3.8.</span> <span class="nav-text">索引失效</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0"><span class="nav-number">3.8.1.</span> <span class="nav-text">时间函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%95%B0%E5%AD%97%E6%AF%94%E8%BE%83"><span class="nav-number">3.8.2.</span> <span class="nav-text">字符串与数字比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.8.3.</span> <span class="nav-text">隐式字符编码转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-5"><span class="nav-number">3.8.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E5%A4%AA%E6%85%A2"><span class="nav-number">3.9.</span> <span class="nav-text">分页查询太慢</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%8F%E7%A7%BB%E9%87%8F%E5%A4%A7%E6%97%B6%E6%95%88%E7%8E%87%E4%BD%8E"><span class="nav-number">3.9.1.</span> <span class="nav-text">偏移量大时效率低</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF"><span class="nav-number">3.9.2.</span> <span class="nav-text">优化思路</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-6"><span class="nav-number">3.10.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%80%80%E7%96%91%E6%96%B9%E5%90%91"><span class="nav-number">3.10.1.</span> <span class="nav-text">慢查询的怀疑方向</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0"><span class="nav-number">4.</span> <span class="nav-text">如何处理数据更新</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%90%E8%A1%8C%E5%90%8E%E5%8F%AF%E8%83%BD%E4%BA%A7%E7%94%9F%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="nav-number">4.1.</span> <span class="nav-text">数据库运行后可能产生的性能问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A7%E7%94%9F%E6%97%A5%E5%BF%97%E6%95%B0%E6%8D%AE"><span class="nav-number">4.1.1.</span> <span class="nav-text">产生日志数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B9%8B%E9%97%B4%E5%9B%A0%E4%B8%BA%E9%94%81%E8%80%8C%E4%BA%92%E7%9B%B8%E5%BD%B1%E5%93%8D"><span class="nav-number">4.1.2.</span> <span class="nav-text">客户端之间因为锁而互相影响</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E9%80%A0%E6%88%90%E6%9F%A5%E8%AF%A2%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A3%81%E7%9B%98%E4%B8%8A%E4%B8%8D%E4%B8%80%E8%87%B4"><span class="nav-number">4.1.3.</span> <span class="nav-text">事务造成查询到的数据与磁盘上不一致</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E7%BB%99%E4%BA%BA%E7%9C%8B%E7%9A%84%E6%97%A5%E5%BF%97"><span class="nav-number">4.2.</span> <span class="nav-text">不给人看的日志</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL-%E6%97%A5%E5%BF%97%E4%BD%93%E7%B3%BB"><span class="nav-number">4.2.1.</span> <span class="nav-text">MySQL 日志体系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binlog-%E5%BD%92%E6%A1%A3%E6%97%A5%E5%BF%97"><span class="nav-number">4.2.2.</span> <span class="nav-text">binlog 归档日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undo-log-%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97"><span class="nav-number">4.2.3.</span> <span class="nav-text">undo log 回滚日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redo-log-%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97"><span class="nav-number">4.2.4.</span> <span class="nav-text">redo log 重做日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redo-log%E4%B8%8Ebinlog%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.5.</span> <span class="nav-text">redo log与binlog区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E6%9D%A1%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0%E7%9A%84"><span class="nav-number">4.3.</span> <span class="nav-text">一条数据是如何更新的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B"><span class="nav-number">4.3.1.</span> <span class="nav-text">数据更新流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redo-log-%E5%88%B7%E7%9B%98"><span class="nav-number">4.3.2.</span> <span class="nav-text">redo log 刷盘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binlog-%E5%88%B7%E7%9B%98"><span class="nav-number">4.3.3.</span> <span class="nav-text">binlog 刷盘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E5%88%86%E6%9E%90"><span class="nav-number">4.3.4.</span> <span class="nav-text">持久化分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-7"><span class="nav-number">4.3.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">4.4.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL-%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="nav-number">4.4.1.</span> <span class="nav-text">MySQL 锁的种类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E9%94%81"><span class="nav-number">4.4.2.</span> <span class="nav-text">全局锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E9%94%81"><span class="nav-number">4.4.3.</span> <span class="nav-text">表锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%8C%E9%94%81"><span class="nav-number">4.4.4.</span> <span class="nav-text">行锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-8"><span class="nav-number">4.4.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">4.5.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">4.5.1.</span> <span class="nav-text">事务的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-number">4.5.2.</span> <span class="nav-text">原子性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">4.5.3.</span> <span class="nav-text">一致性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E6%80%A7"><span class="nav-number">4.5.4.</span> <span class="nav-text">隔离性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E6%80%A7"><span class="nav-number">4.5.5.</span> <span class="nav-text">持久性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">4.6.</span> <span class="nav-text">事务的隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">4.6.1.</span> <span class="nav-text">隔离级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4"><span class="nav-number">4.6.2.</span> <span class="nav-text">读未提交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E6%8F%90%E4%BA%A4"><span class="nav-number">4.6.3.</span> <span class="nav-text">读提交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="nav-number">4.6.4.</span> <span class="nav-text">可重复读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E8%A1%8C%E5%8C%96"><span class="nav-number">4.6.5.</span> <span class="nav-text">串行化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MVCC-%E5%B9%B6%E5%8F%91%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6"><span class="nav-number">4.7.</span> <span class="nav-text">MVCC 并发版本控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%8C%E8%AE%B0%E5%BD%95%E7%9A%84%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6"><span class="nav-number">4.7.1.</span> <span class="nav-text">行记录的版本控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E7%85%A7%E8%AF%BB%EF%BC%88%E4%B8%80%E8%87%B4%E6%80%A7%E9%9D%9E%E9%94%81%E5%AE%9A%E8%AF%BB%EF%BC%89"><span class="nav-number">4.7.2.</span> <span class="nav-text">快照读（一致性非锁定读）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%93%E5%89%8D%E8%AF%BB%EF%BC%88%E4%B8%80%E8%87%B4%E6%80%A7%E9%94%81%E5%AE%9A%E8%AF%BB%EF%BC%89"><span class="nav-number">4.7.3.</span> <span class="nav-text">当前读（一致性锁定读）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E9%97%AE%E9%A2%98"><span class="nav-number">4.8.</span> <span class="nav-text">隔离问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL-%E4%B8%8D%E5%90%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">4.8.1.</span> <span class="nav-text">MySQL 不同隔离级别的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98"><span class="nav-number">4.8.2.</span> <span class="nav-text">如何解决幻读问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Next-Key-Lock-%E7%9A%84%E5%8A%A0%E9%94%81%E9%80%BB%E8%BE%91"><span class="nav-number">4.8.3.</span> <span class="nav-text">Next-Key Lock 的加锁逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2%E9%97%B4%E9%9A%99%E9%94%81"><span class="nav-number">4.8.4.</span> <span class="nav-text">等值查询间隙锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E9%94%81"><span class="nav-number">4.8.5.</span> <span class="nav-text">非唯一索引等值锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E9%94%81"><span class="nav-number">4.8.6.</span> <span class="nav-text">主键索引范围锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E9%94%81"><span class="nav-number">4.8.7.</span> <span class="nav-text">非唯一索引范围锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E7%B4%A2%E5%BC%95%E5%AD%97%E6%AE%B5%E6%9F%A5%E8%AF%A2"><span class="nav-number">4.8.8.</span> <span class="nav-text">非索引字段查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-9"><span class="nav-number">4.8.9.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-%E7%9A%84%E2%80%9C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E2%80%9D"><span class="nav-number">4.9.</span> <span class="nav-text">MySQL 的“垃圾回收”</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL-%E8%84%8F%E9%A1%B5%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="nav-number">4.9.1.</span> <span class="nav-text">MySQL 脏页的产生</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%B7%E8%84%8F"><span class="nav-number">4.9.2.</span> <span class="nav-text">刷脏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E5%96%84%E5%88%B7%E8%84%8F%E6%80%A7%E8%83%BD"><span class="nav-number">4.9.3.</span> <span class="nav-text">改善刷脏性能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8-IO-%E9%85%8D%E7%BD%AE"><span class="nav-number">4.9.3.1.</span> <span class="nav-text">服务器 IO 配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%84%8F%E9%A1%B5%E6%AF%94%E4%BE%8B%E4%B8%8A%E9%99%90%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="nav-number">4.9.3.2.</span> <span class="nav-text">脏页比例上限的配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E2%80%9C%E9%A1%BA%E4%BE%BF%E5%88%B7%E8%84%8F%E2%80%9D%E7%AD%96%E7%95%A5"><span class="nav-number">4.9.3.3.</span> <span class="nav-text">控制“顺便刷脏”策略</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%95%BF%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8D%B1%E5%AE%B3"><span class="nav-number">4.10.</span> <span class="nav-text">长事务的危害</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E6%97%A0%E6%B3%95%E9%87%8A%E6%94%BE"><span class="nav-number">4.10.1.</span> <span class="nav-text">锁无法释放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81%E9%95%BF%E6%97%B6%E9%97%B4%E6%97%A0%E6%B3%95%E9%87%8A%E6%94%BE"><span class="nav-number">4.10.2.</span> <span class="nav-text">行级锁长时间无法释放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%A0%E6%88%90%E6%AD%BB%E9%94%81"><span class="nav-number">4.10.3.</span> <span class="nav-text">造成死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MDL-%E9%94%81%E5%AF%BC%E8%87%B4-MySQL-%E5%B4%A9%E6%BA%83"><span class="nav-number">4.10.4.</span> <span class="nav-text">MDL 锁导致 MySQL 崩溃</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E5%BD%B1%E5%93%8D%E6%80%A7%E8%83%BD%E7%9A%84%E9%94%81"><span class="nav-number">4.10.5.</span> <span class="nav-text">查看影响性能的锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%9A%E5%8A%A1%E4%B8%8A%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">4.10.6.</span> <span class="nav-text">业务上的优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-10"><span class="nav-number">4.11.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E8%B5%B7%E6%9D%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">4.11.1.</span> <span class="nav-text">动起来的数据库的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL-%E6%97%A5%E5%BF%97%E4%BD%93%E7%B3%BB-1"><span class="nav-number">4.11.2.</span> <span class="nav-text">MySQL 日志体系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL-%E7%9A%84%E9%94%81"><span class="nav-number">4.11.3.</span> <span class="nav-text">MySQL 的锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E4%B8%8E-MVCC"><span class="nav-number">4.11.4.</span> <span class="nav-text">事务与 MVCC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL-%E7%9A%84%E5%88%B7%E8%84%8F%E7%AD%96%E7%95%A5"><span class="nav-number">4.11.5.</span> <span class="nav-text">MySQL 的刷脏策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%95%BF%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8D%B1%E5%AE%B3-1"><span class="nav-number">4.11.6.</span> <span class="nav-text">长事务的危害</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ORM-%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86"><span class="nav-number">5.</span> <span class="nav-text">ORM 框架原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-ORM-%E6%A1%86%E6%9E%B6"><span class="nav-number">5.1.</span> <span class="nav-text">什么是 ORM 框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ORM-%E6%A1%86%E6%9E%B6%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">5.1.1.</span> <span class="nav-text">ORM 框架的意义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ORM-%E6%A1%86%E6%9E%B6%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%9A%84"><span class="nav-number">5.2.</span> <span class="nav-text">ORM 框架是如何设计的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ORM-%E6%A1%86%E6%9E%B6-%E6%9E%B6%E6%9E%84%E5%B1%82%E6%AC%A1"><span class="nav-number">5.2.1.</span> <span class="nav-text">ORM 框架 - 架构层次</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ORM-%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">5.3.</span> <span class="nav-text">ORM 框架常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ORM-%E4%B8%8E-DAO-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">5.3.1.</span> <span class="nav-text">ORM 与 DAO 的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%BD%8D%E5%87%BA%E9%97%AE%E9%A2%98%E7%9A%84-SQL"><span class="nav-number">5.3.2.</span> <span class="nav-text">定位出问题的 SQL</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%8E%E6%A0%B7%E7%BB%99%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8A%E4%BF%9D%E9%99%A9"><span class="nav-number">6.</span> <span class="nav-text">怎样给数据库上保险</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="nav-number">6.1.</span> <span class="nav-text">数据库备份的种类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%87%E4%BB%BD%E7%9A%84%E5%88%86%E7%B1%BB%E7%BB%B4%E5%BA%A6"><span class="nav-number">6.1.1.</span> <span class="nav-text">备份的分类维度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%87%E4%BB%BD%E6%97%B6%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">6.1.2.</span> <span class="nav-text">备份时数据库的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="nav-number">6.1.3.</span> <span class="nav-text">备份文件的格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%87%E4%BB%BD%E7%9A%84%E5%86%85%E5%AE%B9"><span class="nav-number">6.1.4.</span> <span class="nav-text">备份的内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%87%E4%BB%BD%E5%B7%A5%E5%85%B7"><span class="nav-number">6.1.5.</span> <span class="nav-text">备份工具</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-OUTFILE-%E5%91%BD%E4%BB%A4%E5%A4%87%E4%BB%BD"><span class="nav-number">6.2.</span> <span class="nav-text">使用 OUTFILE 命令备份</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#OUTFILE"><span class="nav-number">6.2.1.</span> <span class="nav-text">OUTFILE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">6.2.2.</span> <span class="nav-text">使用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OUTFILE-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">6.2.3.</span> <span class="nav-text">OUTFILE 注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OUTFILE-%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="nav-number">6.2.4.</span> <span class="nav-text">OUTFILE 的缺陷</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B-OUTFILE"><span class="nav-number">6.2.5.</span> <span class="nav-text">改进 OUTFILE</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-MySQLDump-%E5%A4%87%E4%BB%BD"><span class="nav-number">6.3.</span> <span class="nav-text">使用 MySQLDump 备份</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQLDump-%E5%8E%9F%E7%90%86"><span class="nav-number">6.3.1.</span> <span class="nav-text">MySQLDump 原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQLDump-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">6.3.2.</span> <span class="nav-text">MySQLDump 使用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQLDump-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">6.3.3.</span> <span class="nav-text">MySQLDump 注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQLDump-%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">6.3.4.</span> <span class="nav-text">MySQLDump 的缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-MySQLDump-%E5%A2%9E%E9%87%8F%E5%A4%87%E4%BB%BD"><span class="nav-number">6.4.</span> <span class="nav-text">使用 MySQLDump 增量备份</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQLDump-%E5%A2%9E%E9%87%8F%E5%A4%87%E4%BB%BD%E6%80%9D%E8%B7%AF"><span class="nav-number">6.4.1.</span> <span class="nav-text">MySQLDump 增量备份思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="nav-number">6.4.2.</span> <span class="nav-text">使用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-11"><span class="nav-number">6.4.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-XtraBackup-%E7%89%A9%E7%90%86%E5%A4%87%E4%BB%BD"><span class="nav-number">6.5.</span> <span class="nav-text">使用 XtraBackup 物理备份</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E7%89%A9%E7%90%86%E5%A4%87%E4%BB%BD"><span class="nav-number">6.5.1.</span> <span class="nav-text">为什么要使用物理备份</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E6%8B%B7%E8%B4%9D%E8%A3%B8%E6%96%87%E4%BB%B6%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">6.5.2.</span> <span class="nav-text">直接拷贝裸文件的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-%E7%89%A9%E7%90%86-%E7%83%AD-%E5%85%A8%E9%87%8F-%E5%A4%87%E4%BB%BD"><span class="nav-number">6.5.3.</span> <span class="nav-text">实现 物理+热+全量 备份</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-%E7%89%A9%E7%90%86-%E7%83%AD-%E5%A2%9E%E9%87%8F-%E5%A4%87%E4%BB%BD"><span class="nav-number">6.5.4.</span> <span class="nav-text">实现 物理+热+增量 备份</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%89%A9%E7%90%86%E8%BF%98%E5%8E%9F"><span class="nav-number">6.5.5.</span> <span class="nav-text">实现物理还原</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ibbackup"><span class="nav-number">6.5.6.</span> <span class="nav-text">ibbackup</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XtraBackup"><span class="nav-number">6.5.7.</span> <span class="nav-text">XtraBackup</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XtraBackup-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">6.5.8.</span> <span class="nav-text">XtraBackup 使用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-12"><span class="nav-number">6.5.9.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%B2%E6%82%A3%E4%BA%8E%E6%9C%AA%E7%84%B6"><span class="nav-number">6.6.</span> <span class="nav-text">防患于未然</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E9%9A%94%E7%A6%BB"><span class="nav-number">6.6.1.</span> <span class="nav-text">权限隔离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL-%E5%AE%A1%E8%AE%A1"><span class="nav-number">6.6.2.</span> <span class="nav-text">SQL 审计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%AA%E5%88%A0%E8%A1%A8"><span class="nav-number">6.6.3.</span> <span class="nav-text">伪删表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E5%96%84%E6%B5%81%E7%A8%8B"><span class="nav-number">6.6.4.</span> <span class="nav-text">完善流程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%86%97%E4%BD%99"><span class="nav-number">7.</span> <span class="nav-text">如何实现数据冗余</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E9%AB%98%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF"><span class="nav-number">7.1.</span> <span class="nav-text">三高架构之路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E9%AB%98"><span class="nav-number">7.1.1.</span> <span class="nav-text">什么是三高</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%89%E9%AB%98"><span class="nav-number">7.1.2.</span> <span class="nav-text">实现三高</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.2.</span> <span class="nav-text">复制的原理和类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">7.2.1.</span> <span class="nav-text">复制的基本原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.2.2.</span> <span class="nav-text">复制的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6"><span class="nav-number">7.2.3.</span> <span class="nav-text">异步复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6"><span class="nav-number">7.2.4.</span> <span class="nav-text">半同步复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%A4%8D%E5%88%B6"><span class="nav-number">7.2.5.</span> <span class="nav-text">组复制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="nav-number">7.3.</span> <span class="nav-text">主从复制的配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E6%96%B9%E4%BE%BF%E5%9C%B0%E5%A4%8D%E5%88%B6"><span class="nav-number">7.4.</span> <span class="nav-text">更方便地复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GTID-Global-Transaction-Identifier"><span class="nav-number">7.4.1.</span> <span class="nav-text">GTID(Global Transaction Identifier)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E7%94%A8-GTID"><span class="nav-number">7.4.2.</span> <span class="nav-text">启用 GTID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-GTID-%E8%BF%9B%E8%A1%8C%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">7.4.3.</span> <span class="nav-text">使用 GTID 进行主从复制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Binlog-%E7%9A%84%E6%A0%BC%E5%BC%8F%E9%97%AE%E9%A2%98"><span class="nav-number">7.5.</span> <span class="nav-text">Binlog 的格式问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Statement-%E6%A0%BC%E5%BC%8F%E7%9A%84-Binlog"><span class="nav-number">7.5.1.</span> <span class="nav-text">Statement 格式的 Binlog</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ROW-%E6%A0%BC%E5%BC%8F%E7%9A%84-Binlog"><span class="nav-number">7.5.2.</span> <span class="nav-text">ROW 格式的 Binlog</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mixed-%E6%A0%BC%E5%BC%8F%E7%9A%84-Binlog"><span class="nav-number">7.5.3.</span> <span class="nav-text">Mixed 格式的 Binlog</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E8%AF%AD%E5%8F%A5%E6%88%96%E8%A1%8C%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="nav-number">7.5.4.</span> <span class="nav-text">基于语句或行的复制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E5%BA%93%E7%9A%84%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98"><span class="nav-number">7.6.</span> <span class="nav-text">从库的延迟问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E5%BA%93%E5%BB%B6%E8%BF%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">7.6.1.</span> <span class="nav-text">从库延迟的原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="nav-number">7.6.2.</span> <span class="nav-text">处理方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E5%A4%8D%E5%88%B6%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="nav-number">7.6.3.</span> <span class="nav-text">并行复制的思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL-5-6-%E5%B9%B6%E8%A1%8C%E5%A4%8D%E5%88%B6"><span class="nav-number">7.6.4.</span> <span class="nav-text">MySQL 5.6 并行复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL-5-7-%E4%BA%8B%E5%8A%A1%E7%BB%84%E5%B9%B6%E8%A1%8C%E7%9A%84%E7%AD%96%E7%95%A5"><span class="nav-number">7.6.5.</span> <span class="nav-text">MySQL 5.7 事务组并行的策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL-5-7-22-%E5%B9%B6%E8%A1%8C%E5%A4%8D%E5%88%B6"><span class="nav-number">7.6.6.</span> <span class="nav-text">MySQL 5.7.22 并行复制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E4%BB%8E%E5%BA%93%E8%AF%BB%E5%88%B0%E6%9C%80%E6%96%B0%E6%95%B0%E6%8D%AE"><span class="nav-number">7.7.</span> <span class="nav-text">如何在从库读到最新数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E4%BB%8E%E5%BA%93%E5%B7%B2%E7%BB%8F%E5%90%8C%E6%AD%A5"><span class="nav-number">7.7.1.</span> <span class="nav-text">判断从库已经同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E5%85%B7%E4%BD%93%E4%BA%8B%E5%8A%A1%E5%B7%B2%E7%BB%8F%E9%87%8D%E6%94%BE"><span class="nav-number">7.7.2.</span> <span class="nav-text">判断具体事务已经重放</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84"><span class="nav-number">7.8.</span> <span class="nav-text">实现最简单的高可用架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB-%E4%B8%BB%E5%A4%8D%E5%88%B6%E6%9E%B6%E6%9E%84"><span class="nav-number">7.8.1.</span> <span class="nav-text">主-主复制架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB-%E4%B8%BB%E6%9E%B6%E6%9E%84%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">7.8.2.</span> <span class="nav-text">主-主架构的问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-13"><span class="nav-number">7.9.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E7%9A%84%E7%B1%BB%E5%9E%8B-1"><span class="nav-number">7.9.1.</span> <span class="nav-text">复制的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GTID"><span class="nav-number">7.9.2.</span> <span class="nav-text">GTID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Binlog-%E6%A0%BC%E5%BC%8F"><span class="nav-number">7.9.3.</span> <span class="nav-text">Binlog 格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E5%BA%93%E5%BB%B6%E8%BF%9F"><span class="nav-number">7.9.4.</span> <span class="nav-text">从库延迟</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E5%A4%8D%E5%88%B6"><span class="nav-number">7.9.5.</span> <span class="nav-text">并行复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">7.9.6.</span> <span class="nav-text">判断主从同步的情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB-%E4%B8%BB%E5%A4%8D%E5%88%B6%E6%9E%B6%E6%9E%84-1"><span class="nav-number">7.9.7.</span> <span class="nav-text">主-主复制架构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B6%85%E5%A4%A7%E5%AE%B9%E9%87%8F"><span class="nav-number">8.</span> <span class="nav-text">如何解决数据库超大容量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E7%AE%80%E5%8D%95%E5%9C%B0%E6%89%A9%E5%B1%95%E5%AE%B9%E9%87%8F"><span class="nav-number">8.1.</span> <span class="nav-text">最简单地扩展容量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E8%A1%A8"><span class="nav-number">8.1.1.</span> <span class="nav-text">分区表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E6%96%B9%E5%BC%8F"><span class="nav-number">8.1.2.</span> <span class="nav-text">分区方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E8%A1%A8%E7%9A%84%E4%BC%98%E5%8A%A3"><span class="nav-number">8.1.3.</span> <span class="nav-text">分区表的优劣</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="nav-number">8.2.</span> <span class="nav-text">分库分表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E8%A1%A8"><span class="nav-number">8.2.1.</span> <span class="nav-text">分表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%82%E7%9B%B4%E5%88%86%E8%A1%A8"><span class="nav-number">8.2.2.</span> <span class="nav-text">垂直分表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B0%B4%E5%B9%B3%E5%88%86%E8%A1%A8"><span class="nav-number">8.2.3.</span> <span class="nav-text">水平分表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%BA%93"><span class="nav-number">8.2.4.</span> <span class="nav-text">分库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%82%E7%9B%B4%E5%88%86%E5%BA%93"><span class="nav-number">8.2.5.</span> <span class="nav-text">垂直分库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B0%B4%E5%B9%B3%E5%88%86%E5%BA%93"><span class="nav-number">8.2.6.</span> <span class="nav-text">水平分库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E4%BC%98%E5%8A%A3"><span class="nav-number">8.2.7.</span> <span class="nav-text">分库分表的优劣</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%90%8E%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">8.2.8.</span> <span class="nav-text">分库分表后的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DBLE"><span class="nav-number">8.3.</span> <span class="nav-text">DBLE</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">8.3.1.</span> <span class="nav-text">分库分表中间件的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DBLE-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">8.3.2.</span> <span class="nav-text">DBLE 架构设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DBLE-%E5%AF%B9-MyCat-%E5%81%9A%E7%9A%84%E5%A2%9E%E5%BC%BA"><span class="nav-number">8.3.3.</span> <span class="nav-text">DBLE 对 MyCat 做的增强</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DBLE-%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-number">8.3.4.</span> <span class="nav-text">DBLE 的基础概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DBLE-%E8%A1%A8%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">8.3.5.</span> <span class="nav-text">DBLE 表的类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E8%A3%85-DBLE"><span class="nav-number">8.4.</span> <span class="nav-text">安装 DBLE</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DBLE-%E6%9C%80%E7%AE%80%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="nav-number">8.4.1.</span> <span class="nav-text">DBLE 最简运行环境搭建</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%90%E9%AB%98%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="nav-number">8.5.</span> <span class="nav-text">提高分库分表架构的可靠性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E4%B8%8E%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E7%BB%93%E5%90%88"><span class="nav-number">8.5.1.</span> <span class="nav-text">复制与分库分表架构的结合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-DBLE-%E8%BF%9B%E8%A1%8C%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="nav-number">8.5.2.</span> <span class="nav-text">使用 DBLE 进行读写分离</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%90%8E%E6%80%A7%E8%83%BD%E4%B8%8B%E9%99%8D%E9%97%AE%E9%A2%98"><span class="nav-number">8.6.</span> <span class="nav-text">解决分库分表后性能下降问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E4%B8%AD%E5%B0%BD%E9%87%8F%E5%B8%A6%E6%9C%89%E6%8B%86%E5%88%86%E5%AD%97%E6%AE%B5"><span class="nav-number">8.6.1.</span> <span class="nav-text">查询语句中尽量带有拆分字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E8%AF%AD%E5%8F%A5%E4%B8%AD%E5%BF%85%E9%A1%BB%E5%B8%A6%E6%9C%89%E6%8B%86%E5%88%86%E5%AD%97%E6%AE%B5"><span class="nav-number">8.6.2.</span> <span class="nav-text">插入语句中必须带有拆分字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%86%E5%88%86%E5%AD%97%E6%AE%B5%E5%B0%BD%E9%87%8F%E7%AD%89%E5%80%BC"><span class="nav-number">8.6.3.</span> <span class="nav-text">拆分字段尽量等值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%8F%E5%B0%91%E8%A1%A8%E7%9A%84%E6%90%9C%E7%B4%A2%E9%81%8D%E5%8E%86"><span class="nav-number">8.6.4.</span> <span class="nav-text">减少表的搜索遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%8F%E5%B0%91%E7%BB%93%E6%9E%9C%E9%9B%86"><span class="nav-number">8.6.5.</span> <span class="nav-text">减少结果集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%A8%E8%8A%82%E7%82%B9%E8%BF%9E%E8%A1%A8"><span class="nav-number">8.6.6.</span> <span class="nav-text">跨节点连表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%95%E6%9C%BA%E9%97%AE%E9%A2%98"><span class="nav-number">9.</span> <span class="nav-text">如何解决数据库宕机问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%9D%E4%B8%9A%E5%8A%A1%E8%BF%98%E6%98%AF%E4%BF%9D%E6%95%B0%E6%8D%AE"><span class="nav-number">9.1.</span> <span class="nav-text">保业务还是保数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E8%BA%AB%E4%BB%BD%E5%88%87%E6%8D%A2"><span class="nav-number">9.1.1.</span> <span class="nav-text">如何进行身份切换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BC%98%E5%85%88%E7%AD%96%E7%95%A5"><span class="nav-number">9.1.2.</span> <span class="nav-text">可靠性优先策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E7%94%A8%E6%80%A7%E4%BC%98%E5%85%88%E7%AD%96%E7%95%A5"><span class="nav-number">9.1.3.</span> <span class="nav-text">可用性优先策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-14"><span class="nav-number">9.1.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%87%E6%8D%A2%E4%BA%86%E4%B8%9A%E5%8A%A1%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="nav-number">9.2.</span> <span class="nav-text">数据库切换了业务怎么办</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%9A%E5%8A%A1%E5%88%87%E6%8D%A2%E8%87%B3%E6%96%B0%E5%9C%B0%E5%9D%80"><span class="nav-number">9.2.1.</span> <span class="nav-text">业务切换至新地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8-DNS-%E9%80%9A%E8%BF%87%E5%9F%9F%E5%90%8D%E9%93%BE%E6%8E%A5"><span class="nav-number">9.2.2.</span> <span class="nav-text">使用内部 DNS 通过域名链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VIP-%E6%BC%82%E7%A7%BB"><span class="nav-number">9.2.3.</span> <span class="nav-text">VIP 漂移</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86"><span class="nav-number">9.2.4.</span> <span class="nav-text">使用代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-DBLE-%E6%97%B6%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2"><span class="nav-number">9.2.5.</span> <span class="nav-text">使用 DBLE 时的主从切换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-15"><span class="nav-number">9.2.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2"><span class="nav-number">9.3.</span> <span class="nav-text">实现自动主从切换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Keepalived"><span class="nav-number">9.3.1.</span> <span class="nav-text">Keepalived</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MHA-Master-High-Availability"><span class="nav-number">9.3.2.</span> <span class="nav-text">MHA(Master High Availability)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MHA-%E4%B8%8E-DBLE-%E8%81%94%E5%8A%A8"><span class="nav-number">9.3.3.</span> <span class="nav-text">MHA 与 DBLE 联动</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E8%BF%98%E6%98%AF%E4%BC%9A%E6%8C%82"><span class="nav-number">9.4.</span> <span class="nav-text">实现高可用集群还是会挂</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DRDS-Distributed-Relational-Database-Service"><span class="nav-number">9.4.1.</span> <span class="nav-text">DRDS(Distributed Relational Database Service)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-16"><span class="nav-number">9.4.2.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ssssv11"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">Ssssv11</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Ssssv11" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Ssssv11" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ssssv11.github.io/2022/05/12/MySQL%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="Ssssv11">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ssssv">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL优化
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-05-12 17:17:08" itemprop="dateCreated datePublished" datetime="2022-05-12T17:17:08+08:00">2022-05-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-05-16 21:31:54" itemprop="dateModified" datetime="2022-05-16T21:31:54+08:00">2022-05-16</time>
      </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <center>MySQL优化</center>

<span id="more"></span>

<h1 id="一个-SQL-如何执行"><a href="#一个-SQL-如何执行" class="headerlink" title="一个 SQL 如何执行"></a>一个 SQL 如何执行</h1><h2 id="MySQL-软件架构"><a href="#MySQL-软件架构" class="headerlink" title="MySQL 软件架构"></a>MySQL 软件架构</h2><p>MySQL Server 架构自顶向下大致可以分<strong>网络连接层</strong>、<strong>服务层</strong>、<strong>存储引擎层</strong>和<strong>系统文件层</strong>。<img src="https://s1.ax1x.com/2022/05/12/OBkxqs.png" alt="OBkxqs.png"></p>
<p>上图中，Connection pool 为连接层，Management Services &amp; Utilities … Caches &amp; Buffers 为 SQL 层，Pluggable Storage Engines 为存储引擎层，File system、Files &amp; Logs 为文件系统层。</p>
<p>可以看出数据库架构使用了分层架构、管道-过滤器、微核架构。</p>
<h3 id="客户端（Connectors）"><a href="#客户端（Connectors）" class="headerlink" title="客户端（Connectors）"></a>客户端（Connectors）</h3><p>客户端连接器（Client Connectors）：指各类语言与 MySQL 服务器的交互 API，提供与 MySQL 服务器建立的支持。目前几乎支持所有主流的服务器编程技术，例如常见的 Java、C、Python、.NET 等，它们通过各自的 API 技术与 MySQL 建立连接。</p>
<p>Connectors 不属于以上任何一层，可以将 Connectors 理解为各种客户端、应用服务，主要指的是不同语言与 SQL 的交互。</p>
<br>

<h3 id="连接池组件（Connection-Pool）"><a href="#连接池组件（Connection-Pool）" class="headerlink" title="连接池组件（Connection Pool）"></a>连接池组件（Connection Pool）</h3><p>负责管理连接和权限验证：跟客户端建立连接、获取权限、维持和管理连接。</p>
<p>每个成功连接 MySQL Server 的客户请求都会被创建或分配一个线程，该线程负责客户端与 MySQL Server 端的通信，接收客户端发送的命令，传递服务端的结果信息等。线程池组件提供线程重用、连接限制等能力。</p>
<br>

<h3 id="管理服务和工具组件（Management-Services-amp-Utillties）"><a href="#管理服务和工具组件（Management-Services-amp-Utillties）" class="headerlink" title="管理服务和工具组件（Management Services &amp; Utillties）"></a>管理服务和工具组件（Management Services &amp; Utillties）</h3><p>提供对 MySQL 的集成管理，如备份(Backup)，恢复(Recovery)，安全管理(Security)等。</p>
<br>

<h3 id="SQL-接口组件（SQL-Interface）"><a href="#SQL-接口组件（SQL-Interface）" class="headerlink" title="SQL 接口组件（SQL Interface）"></a>SQL 接口组件（SQL Interface）</h3><p>接收用户 SQL 命令，如 DML、DDL 和存储过程等，并将最终结果返回给用户。</p>
<br>

<h3 id="解析器组件（Parse）"><a href="#解析器组件（Parse）" class="headerlink" title="解析器组件（Parse）"></a>解析器组件（Parse）</h3><p>SQL 命令传递到解析器的时候会被解析器验证和解析。解析器是由 Lex 和 YACC 实现的，是一个很长的脚本。在  MySQL 中我们习惯将所有客户端发送给服务端的命令都称为 Query ，在 MySQL Server 里面，连接线程接收到客户端的一个 Query 后，会直接将该 Query 传递给专门负责将各种 Query 进行分类然后转发给各个对应的处理模块。</p>
<ul>
<li>将 SQL 语句进行语义和语法的分析，分解成数据结构，然后按照不同的操作类型进行分类，然后做出针对性的转发到后续步骤，以后 SQL 语句的传递和处理就是基于这个结构的； </li>
<li>如果在分解构成中遇到错误，那么就说明这个 SQL 语句是不合理的。</li>
</ul>
<br>

<h3 id="优化器组件（Optimizer）"><a href="#优化器组件（Optimizer）" class="headerlink" title="优化器组件（Optimizer）"></a>优化器组件（Optimizer）</h3><p>SQL 语句在查询之前会使用查询优化器对查询进行优化。即优化客户端请求 Query，根据客户端请求的 Query 语句和数据库中的一些统计信息，在一系列算法的基础上进行分析，得出一个最优的策略，告诉后面的程序如何取得这个 Query 语句的结果。 </p>
<br>

<h3 id="缓存组件（Caches-amp-Buffers）"><a href="#缓存组件（Caches-amp-Buffers）" class="headerlink" title="缓存组件（Caches &amp; Buffers）"></a>缓存组件（Caches &amp; Buffers）</h3><p>主要功能是将客户端提交给 MySQL 的 Select 类 Query 请求的返回结果集缓存到内存中，与该 Query 的 Hash 值做一个对应。该 query 所取数据的基表发生任何数据的变化之后， MySQL 会自动使该 Query 的 Cache 失效。在读写比例非常高的应用系统中， Query Cache 对性能的提高是非常显著的。当然它对内存的消耗也是非常大的。 如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key 缓存，权限缓存等。</p>
<br>

<h3 id="存储引擎接口（Pluggable-Storage-Engines-Memory-Index-amp-Storage-Management）"><a href="#存储引擎接口（Pluggable-Storage-Engines-Memory-Index-amp-Storage-Management）" class="headerlink" title="存储引擎接口（Pluggable Storage Engines Memory, Index &amp; Storage Management）"></a>存储引擎接口（Pluggable Storage Engines Memory, Index &amp; Storage Management）</h3><p>存储引擎负责 MySQL 中数据的存储与提取，与底层系统文件进行交互。MySQL 存储引擎是插件式的，服务器中的查询执行引擎通过接口与存储引擎进行通信，接口屏蔽了不同存储引擎之间的差异 。现在有很多种存储引擎，各有各的特点，最常见的是 MyISAM 和 InnoDB，MySQL 5.5 后默认使用 InnoDB。</p>
<p>MySQL 区别于其他数据库的最重要的特点就是其插件式的表存储引擎。MySQL 插件式的存储引擎架构提供了一系列标准的管理和服务支持，这些标准与存储引擎本身无关，可能是每个数据库系统本身都必需的，如 SQL 分析器和优化器等，而存储引擎是底层物理结构的实现，每个存储引擎开发者都可以按照自己的意愿来进行开发。 </p>
<p><strong>注意</strong>：存储引擎是基于表的，而不是数据库。</p>
<br>

<h2 id="客户端与-MySQL-的连接方式"><a href="#客户端与-MySQL-的连接方式" class="headerlink" title="客户端与 MySQL 的连接方式"></a>客户端与 MySQL 的连接方式</h2><p>客户端与 MySQL 进行连接的方式有四种：TCP&#x2F;IP 连接、管道命名、共享内存、UNIX 域套接字。但主要使用的是 TCP&#x2F;IP 连接，即网络连接。其他方式使用极少。</p>
<br>

<h3 id="TCP-x2F-IP-连接"><a href="#TCP-x2F-IP-连接" class="headerlink" title="TCP&#x2F;IP 连接"></a>TCP&#x2F;IP 连接</h3><p>TCP&#x2F;IP 连接是 MySQL 在任何平台上都提供的连接方法，是目前互联网最主流的网络连接方式。</p>
<p><strong>MySQL TCP 通讯协议的过程：</strong></p>
<ol>
<li>三次握手建立 TCP 连接</li>
<li>认证连接</li>
<li>认证通过后建立 MySQL 连接，客户端开始与服务端交互</li>
<li>断开 MySQL 连接</li>
<li>四次挥手断开 TCP 连接</li>
</ol>
<p>TCP 协议连接的三次握手和断开连接的四次挥手不是这里的重点，详细参考「计算机网络」。这里详细介绍中间三步。</p>
<h4 id="认证连接"><a href="#认证连接" class="headerlink" title="认证连接"></a>认证连接</h4><p>建立 TCP 连接后：</p>
<ol>
<li>服务端 -&gt; 客户端：发送握手初始化包</li>
<li>客户端 -&gt; 服务端：发送验证（验证用户名、密码）</li>
<li>服务端 -&gt; 客户端：认证结果消息</li>
</ol>
<h4 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h4><p>客户端认证成功后会进入执行命令阶段进行交互：</p>
<ol>
<li>客户端 -&gt; 服务端：发送命令包（Command Packet，SQL 语句）</li>
<li>服务端 -&gt; 客户端：发送回应包（SQL 语句执行结果）</li>
</ol>
<h4 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h4><ol>
<li>客户端 -&gt; 服务端：发送退出命令包</li>
</ol>
<h4 id="MySQL-TCP-报文格式"><a href="#MySQL-TCP-报文格式" class="headerlink" title="MySQL TCP 报文格式"></a>MySQL TCP 报文格式</h4><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OBWnFU"><img src="https://s1.ax1x.com/2022/05/12/OBWnFU.png" alt="OBWnFU.png"></a></p>
<ul>
<li><p>消息头 Header：3 字节报文长度、1 字节序号</p>
</li>
<li><p>消息体 Body：1 字节指令，其余为参数</p>
<p>指令举例：切换数据库（0x02）、查询命令（0x03）</p>
</li>
</ul>
<p>可以使用抓包工具进行详细理解。</p>
<br>

<h3 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h3><p>同一台服务器通讯（Windows）。在 MySQL 中开启命名管道的方式：<code>enable-named-pipe</code>。</p>
<br>

<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>客户端和服务端通过一片内存进行通讯。服务端配置 <code>--shared-memory</code>，客户端配置 <code>--protocol=memory</code></p>
<br>

<h3 id="UNIX-域套接字"><a href="#UNIX-域套接字" class="headerlink" title="UNIX 域套接字"></a>UNIX 域套接字</h3><p>在 UNIX 中建立内部的 Socket，服务端配置 <code>--socket=/tmp/mysql.sock</code>，客户端配置 <code>-S=/tmp/mysql.sock</code></p>
<br>

<h2 id="SQL-语句执行机制"><a href="#SQL-语句执行机制" class="headerlink" title="SQL 语句执行机制"></a>SQL 语句执行机制</h2><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OBLTBD"><img src="https://s1.ax1x.com/2022/05/12/OBLTBD.png" alt="OBLTBD.png"></a></p>
<p>整体流程描述：</p>
<ol>
<li><p>客户端发送查询到服务器。</p>
</li>
<li><p>查询缓存，如果命中缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。</p>
<blockquote>
<p>之前执行过的语句会以 KV 形式缓存在内存中，在查询之前会先在缓存中寻找之前执行过的相同语句。数据表修改后会删除所有相关的缓存，因此不推荐使用缓存，在 MySQL 8.0 以后取消了 Server 的缓存。</p>
</blockquote>
</li>
<li><p>服务器进行 SQL 解析、预处理。</p>
<blockquote>
<p>分析器先做词法分析，识别 SQL 语句中的关键字。再做语法分析，判断 SQL 语句是否符合语法。</p>
</blockquote>
</li>
<li><p>优化器生成对应的执行计划。</p>
<blockquote>
<p>优化器的主要工作是决定如何使用索引。</p>
</blockquote>
</li>
<li><p>执行器根据优化器生成的执行计划，调用存储引擎的 API 来执行查询。</p>
<blockquote>
<p>执行器主要工作为校验权限和调用存储引擎。执行器首先校验此用户对目标数据有无对应权限，然后<strong>以行为粒度</strong>调用存储引擎执行 SQL。不同存储引擎的执行方法不同，存储引擎会将指令落实在数据文件上。在没有索引的情况下，执行器会循环查询所有行。</p>
</blockquote>
</li>
<li><p>将结果返回给客户端</p>
<blockquote>
<p>注：如果开启了查询缓存，那么 MySQL 也会将结果存放在查询缓存中。<br>MySQL 将结果集返回客户端是一个增量、逐步返回的过程。这样做服务器端无须存储太多的结果，也就不会因为要返回太多结果而消耗太多内存。客户端也能第一时间获得返回的结果。</p>
</blockquote>
</li>
</ol>
<p>因此，一个 SQL 语句是按照 解析 - 预处理 - 优化 - 执行 - 落盘 的步骤执行的。</p>
<br>

<h2 id="MySQL-的存储引擎"><a href="#MySQL-的存储引擎" class="headerlink" title="MySQL 的存储引擎"></a>MySQL 的存储引擎</h2><p>MySQL 的核心就是存储引擎。</p>
<p>InnoDB 事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。MySQL 5.5.5 之后，InnoDB 作为默认存储引擎。</p>
<p>MyISAM 是基于 ISAM 的存储引擎，并对其进行扩展，是在 Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有较高的插入、查询速度，但不支持事务。</p>
<p>MEMORY 存储引擎将表中的数据存储到内存中，为查询和引用其他数据提供快速访问。</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>MylSAM</th>
<th>MEMORY</th>
<th>InnoDB</th>
<th>Archive</th>
</tr>
</thead>
<tbody><tr>
<td>存储限制</td>
<td>256TB</td>
<td>RAM</td>
<td>64TB</td>
<td>None</td>
</tr>
<tr>
<td>支持事务</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>支持全文索引</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>支持树索引</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>支持哈希索引</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>支持数据缓存</td>
<td>No</td>
<td>N&#x2F;A</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>支持外键</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
</tbody></table>
<p><strong>InnoDB核心特性</strong></p>
<ul>
<li>事务</li>
<li>MVCC</li>
<li>行级锁</li>
<li>热备份</li>
<li>Crash Safe Recovery（自动故障恢复）</li>
</ul>
<p>可以根据以下的原则来选择 MySQL 存储引擎：</p>
<ul>
<li>如果要提供提交、回滚和恢复的事务安全（ACID 兼容）能力，并要求实现并发控制，InnoDB 是一个很好的选择。</li>
<li>如果数据表主要用来插入和查询记录，则 MyISAM 引擎提供较高的处理效率。</li>
<li>如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存的 MEMORY 引擎中，MySQL 中使用该引擎作为临时表，存放查询的中间结果。</li>
<li>如果只有 INSERT 和 SELECT 操作，可以选择 Archive 引擎，Archive 存储引擎支持高并发的插入操作，但是本身并不是事务安全的。Archive 存储引擎非常适合存储归档数据，如记录日志信息可以使用 Archive 引擎。</li>
</ul>
<p>使用哪一种引擎要根据需要灵活选择，一个数据库中多个表可以使用不同的引擎以满足各种性能和实际需求。使用合适的存储引擎将会提高整个数据库的性能。</p>
<br>

<h1 id="如何建表更符合业务"><a href="#如何建表更符合业务" class="headerlink" title="如何建表更符合业务"></a>如何建表更符合业务</h1><h2 id="索引组织表"><a href="#索引组织表" class="headerlink" title="索引组织表"></a>索引组织表</h2><p>索引组织表（Index Organized Table, IOT）不是一种“组织表”，而是由索引“组织起来的”表，是存储在一个索引结构中的表。在 InnoDB 中，表都是根据<strong>主键</strong>顺序组织存放的。</p>
<br>

<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引（Index）是数据库中对某一列或多个列的值进行<strong>预排序</strong>的数据结构。索引可以理解为数据的“目录”。</p>
<p>在 InnoDB 中，主键是一个特殊的索引。ID 是主键不是主索引，主索引是主键排序后组成的索引。</p>
<br>

<h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>主键（Primary Key）指一个列或多列的组合，其值能唯一地标识表中的每一行，通过它可强制表的实体完整性。</p>
<p> 在 InnoDB 中，每一个表都有一个主键，如果没有显式声明：</p>
<ul>
<li>若表中有一个非空唯一索引（Unique NOT NULL），则作为主键。</li>
<li>若有多个非空唯一索引，则选择第一个定义的索引。</li>
<li>若以上都无，InnoDB 会自动创建一个 6 字节的指针（rowid）作为主键。</li>
</ul>
<p><strong>注意：</strong>这里指的是表中的索引而不是字段。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Z (</span><br><span class="line">	a INT NOT NULL,</span><br><span class="line">  b INT NULL,</span><br><span class="line">  c INT NOT NULL,</span><br><span class="line">  d INT NOT NULL,</span><br><span class="line">  UNIQUE KEY(b),</span><br><span class="line">  UNIQUE KEY(d),</span><br><span class="line">  UNIQUE KEY(c)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在这段 SQL 键表语句中，d 为主键（非空唯一索引且第一个被定义）。</p>
<br>

<h2 id="索引算法"><a href="#索引算法" class="headerlink" title="索引算法"></a>索引算法</h2><p>数据可视化网站：<a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p>
<h3 id="主流索引查找算法"><a href="#主流索引查找算法" class="headerlink" title="主流索引查找算法"></a>主流索引查找算法</h3><ul>
<li>线性查找 Linear Search</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/ODF3Pf"><img src="https://s1.ax1x.com/2022/05/13/ODF3Pf.png" alt="ODF3Pf.png"></a></p>
<p>线性查找的时间复杂度为 O(N)。由于线性查找是从第一个数据开始逐个匹配，因此线性查找的效率比较低。</p>
<ul>
<li>二分查找 Binary Search</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/ODF2L9"><img src="https://s1.ax1x.com/2022/05/13/ODF2L9.png" alt="ODF2L9.png"></a></p>
<p>二分查找的时间复杂度为 O(logN)。二分查找取出有序数列的中点位置作为比较对象，根据中点位置数据的大小选取一半数据作为新的数列，这样每次可以减少一半数据量。</p>
<p>但二分查找需要在有序的前提且必须知道数列的中点的位置。实际情况中，表中的数据在磁盘中是随机读写的并不是连续读写的，我们无从得知中点的位置。</p>
<ul>
<li>二叉查找树 Binary Search Tree</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/ODkfXQ"><img src="https://s1.ax1x.com/2022/05/13/ODkfXQ.png" alt="ODkfXQ.png" style="zoom:50%;" /></a></p>
<p>二叉查找树的时间复杂度为 O(logN)。二叉查找树与二分查找相似，根据当前结点与被查找的数的大小选取左或右子树。使用了经典的二叉树数据结构，从根节点开始查找。当二分查找树为满树时，查找的效率与二分查找相同，且不会出现找不到中点的情况。</p>
<p>但考虑下面这种情况：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/ODAl38"><img src="https://s1.ax1x.com/2022/05/13/ODAl38.png" alt="ODAl38.png" style="zoom:50%;" /></a></p>
<p>当数据大小递增时，二分查找树就会退化成线性查找。此时最坏情况的时间复杂度为 O(N)。</p>
<ul>
<li>平衡二叉树 AVL Tree</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/ODA03T"><img src="https://s1.ax1x.com/2022/05/13/ODA03T.png" alt="ODA03T.png" style="zoom:50%;" /></a></p>
<p>平衡二叉树的时间复杂度为 O(logN)。在查找时，平衡二叉树与二叉查找树相同。在增删改时，平衡二叉树会通过旋转操作来维护树的平衡，AVL 树可以保证不会退化成线性查找。</p>
<p>但平衡二叉树一个结点所包含但数据量太少，会造成磁盘空间的浪费且读写效率低。</p>
<ul>
<li>B-Tree</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/ODEyz8"><img src="https://s1.ax1x.com/2022/05/13/ODEyz8.png" alt="ODEyz8.png" style="zoom:67%;" /></a></p>
<p>B-树是线性数据结构和树的结合。在节点内部的查找为线性查找，在节点外部的查找为树结果查找。B-树通过多数据结点大大降低了树的高度，且 B-树不需要旋转就可以保证树的平衡。</p>
<p>但 B-树对于范围查找的效率是非常低的，每次查找都需要从根节点开始一层层查找。</p>
<ul>
<li>B+ Tree</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/ODZYHH"><img src="https://s1.ax1x.com/2022/05/13/ODZYHH.png" alt="ODZYHH.png"></a></p>
<p>B+ 树是由 B 树发展而来的一种数据结构。B+ 树的所有数据均在叶子结点，且这些数据形成了一个线性表。非叶子节点并不存储真正的数据而是作为了索引。</p>
<p><strong>B+ 树是目前最主流的数据库索引算法</strong>，它由线性表、二叉树、B-树发展而来，集成了线性表、平衡二叉树、B树的优势。</p>
<p>其他细节可以参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wxzhe/p/9951333.html">https://www.cnblogs.com/wxzhe/p/9951333.html</a></p>
<br>

<h2 id="InnoDB-索引即数据"><a href="#InnoDB-索引即数据" class="headerlink" title="InnoDB 索引即数据"></a>InnoDB 索引即数据</h2><h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+ 树索引"></a>B+ 树索引</h3><p>InnoDB 使用 B+ 树作为索引的数据结构。B+ 树索引在数据库中有一个特点就是高扇出，树的高度一般是 2<del>4 层，即查找某一个记录最多只需要 2</del>4 次 IO。</p>
<p>InnoDB 中 B+ 树索引可以分为聚簇索引（主索引）和辅助索引。但不管聚集索引还是辅助索引，其内部都是 B+ 树，即高度平衡的。不同的是，聚集索引叶子节点存放着所有的数据，辅助索引叶子节点存放的只是一个指向聚集索引的指针。</p>
<br>

<h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>InnoDB 存储引擎是索引组织表，即表中的数据按照主键顺序存放。而聚簇索引（Clustered Index）就是按照每张表的<strong>主键</strong>构造一棵 B+ 树，同时<strong>叶子节点中的存放的即为整张表的行记录数据</strong>，<strong>每张表只有一个聚集索引</strong>，也将聚簇索引的叶子节点称为数据页（Page）。聚簇索引的这个特性决定了索引组织表中数据也是索引的一部分。同 B+ 树数据结构一样，每个数据页都通过一个双向链表来连接。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OrUdQU"><img src="https://s1.ax1x.com/2022/05/13/OrUdQU.png" alt="OrUdQU.png"></a></p>
<p>InnoDB 使用 B+ 树实现的聚簇索引与 B+ 树不太相同，每个结点都具有下限指针和上限指针，在叶子结点的上层结点之间还有双向链表结构，结点之内数据条目之间为单向链表。并且非叶子结点中两个数据只有两个指针。</p>
<p>当需要查询时，会从根节点根据范围找到下一步需要查询的页号，再从该页的下限指针开始继续查询，直到到达叶子结点并查询成功。</p>
<p><strong>所谓索引即数据，是把数据直接记录在了主索引中。</strong></p>
<br>

<h3 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h3><p>辅助索引（Secondary Index）即非聚集索引，其相较于聚集索引，辅助索引叶子节点并不包含行记录的全部数据。叶子节点除列包含键值以外，每个叶子节点中的索引行中还包含了一个书签。该书签用来告诉 InnoDB 存储引擎哪里可以找到与索引相对应的行数据。由于 InnoDB 存储引擎是索引组织表，因此 InnoDB 存储引擎的辅助索引的书签就是相应行数据的聚集索引键。</p>
<p>使用辅助索引查找数据需要两个步骤：</p>
<ol>
<li>找到辅助索引的位置，辅助索引给出目标数据的聚集索引的位置</li>
<li>根据这个聚簇索引来找到对应数据行（回表）</li>
</ol>
<br>

<h2 id="InnoDB-数据表的存储"><a href="#InnoDB-数据表的存储" class="headerlink" title="InnoDB 数据表的存储"></a>InnoDB 数据表的存储</h2><h3 id="InnoDB-逻辑存储结构"><a href="#InnoDB-逻辑存储结构" class="headerlink" title="InnoDB 逻辑存储结构"></a>InnoDB 逻辑存储结构</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OrRYxH"><img src="https://s1.ax1x.com/2022/05/13/OrRYxH.png" alt="OrRYxH.png"></a></p>
<h3 id="表空间-TableSpace"><a href="#表空间-TableSpace" class="headerlink" title="表空间(TableSpace)"></a>表空间(TableSpace)</h3><p>表空间指的是数据表在硬盘上的存储空间。InnoDB 提供了两种表空间存储数据的方式，一种是共享表空间，一种是独占表空间。InnoDB 默认会将其所有的表数据存储在一个共享表空间中，即 ibdata1。</p>
<p>我们可以通过设置 <code>innodb_file_per_table</code> 参数为 1（1 代表独占方式）开启独占表空间模式。开启之后，每个表都有自己独立的表空间物理文件，所有的数据以及索引都会存储在该文件中，这样方便备份以及恢复数据。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OrWHtf"><img src="https://s1.ax1x.com/2022/05/13/OrWHtf.png" alt="OrWHtf.png" style="zoom:20%;" /></a></p>
<br>

<h3 id="段-Segment"><a href="#段-Segment" class="headerlink" title="段(Segment)"></a>段(Segment)</h3><p>表空间是由各个段组成的，段一般分为数据段、索引段和回滚段等。InnoDB 中，段由存储引擎自动管理。</p>
<p>这里的索引段则是指的 B+ 树的非叶子节点，数据段则是 B+ 树的叶子节点。而回滚段则指的是回滚数据，事务隔离的 MVCC 利用了回滚段实现了多版本查询数据。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OrWsTx"><img src="https://s1.ax1x.com/2022/05/13/OrWsTx.png" alt="OrWsTx.png" style="zoom:25%;" /></a></p>
<br>

<h3 id="区-Extent"><a href="#区-Extent" class="headerlink" title="区(Extent)"></a>区(Extent)</h3><p>区是表空间的单元结构，每个区的大小为 1MB。每个页的大小默认为 16KB，一个区中有 64 个页。为了保证页的<strong>连续性</strong>，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Orfzxe"><img src="https://s1.ax1x.com/2022/05/13/Orfzxe.png" alt="Orfzxe.png" style="zoom:25%;" /></a></p>
<p>虽然页在区中是连续的，但页之间的 B+ 树结构是依靠它们之间的指针来构成的。因此物理上连续相邻的页在逻辑上不一定连续相邻。</p>
<br>

<h3 id="页-Page-x2F-行-Row"><a href="#页-Page-x2F-行-Row" class="headerlink" title="页(Page)&#x2F;行(Row)"></a>页(Page)&#x2F;行(Row)</h3><p>页是组成区的最小单元，默认为 16KB。页也是 InnoDB 存储引擎磁盘管理的最小单元。页的大小充分考虑了机械硬盘和 SSD 的最小单元（512B 和 4KB），确保页的存储效率是最高的。一个数据页就是一个 B+ 树的结点。InnoDB 存储引擎是面向列的（row-oriented），也就是说数据是按行进行存放的，每个页存放的行记录也是有硬性定义的，最多允许存放 16KB&#x2F;2-200 行，即 7992 行记录。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OrhyRO"><img src="https://s1.ax1x.com/2022/05/13/OrhyRO.png" alt="OrhyRO.png" style="zoom:25%;" /></a></p>
<p>InnoDB 中 的页是自身的逻辑概念，与硬件中的页无关。</p>
<p>为什么页的大小不为 16MB 或 16B ？</p>
<p>由于页是磁盘管理的最小单元，因此16MB 的页会大大增加磁盘读写的压力，而且 16MB 的页即 16MB 的链表，在这样大的页中线性查找的效率太低。</p>
<p>由于机械硬盘和 SSD 的最小单元分别为 512B 和 4KB，因此对于 16B 的页来说无法完全用满硬盘的一个块，这样就会造成空间浪费或与其他数据共同存储在一个块而使逻辑更加复杂。</p>
<br>

<h2 id="InnoDB-的数据行"><a href="#InnoDB-的数据行" class="headerlink" title="InnoDB 的数据行"></a>InnoDB 的数据行</h2><h3 id="变长列"><a href="#变长列" class="headerlink" title="变长列"></a>变长列</h3><p>长度不固定的数据类型：</p>
<ul>
<li>VARCHAR、VARBINARY、BLOB、TEXT</li>
</ul>
<p>占用空间大于 768 Byte 的变长列：</p>
<ul>
<li>CHAR（在 InnoDB 中，当 CHAR 的长度大于 768B 的时候会自动变成变长列）</li>
</ul>
<p>变长编码下的 CHAR：</p>
<ul>
<li>所谓变长到底是指硬盘存储空间的变化还是字符串长度的变化呢？从理论上讲，所谓变长列应该指的是磁盘存储空间的变化，如 VARCHAR，它的字符串有可能长有可能短，所以在硬盘存储空间中也有可能长有可能短，所以称变长列(字段)；而在 UTF-8 这种编码下一个字符的所占的空间是不固定的，所以在 UTF-8 或者其他变长编码下的 CHAR 也为变长列。</li>
</ul>
<br>

<h3 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OrHR91"><img src="https://s1.ax1x.com/2022/05/13/OrHR91.png" alt="OrHR91.png" style="zoom:25%;" /></a></p>
<p>由于 InnoDB 每个数据页容量有限，导致数据字段也是有限的。而在当数据段过大时，InnoDB 会使用行溢出机制，它会将超长的字段放入单独开辟的数据页中。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OrbEvV"><img src="https://s1.ax1x.com/2022/05/13/OrbEvV.png" alt="OrbEvV.png" style="zoom:25%;" /></a></p>
<p>在一个数据行中当一个数据段过大时，就会将超长的字段存入到 BLOB 页中，这样就避免了在一个数据页中页数据量过少导致 B+ 树效率退化的问题。因此在 InnoDB 中采用数据转移的操作来使得页数据量恢复，从而维持 B+ 树硬盘读写的优势。但如果要查询大数据段，只能多一步利用该数据段指向 Blob 页的指针查找到对应的数据，这也是种折中方案。</p>
<br>

<h3 id="行记录格式-Row-Format"><a href="#行记录格式-Row-Format" class="headerlink" title="行记录格式(Row Format)"></a>行记录格式(Row Format)</h3><p>行记录格式进化的核心需求是节约行记录空间，从而增加每个页的数据行数，提高查询效率。</p>
<p>InnoDB 行记录格式主要分为两个时代：</p>
<ul>
<li>Redundant &#x2F; Compact (Antelope文件格式)</li>
<li>Dynamic &#x2F; Compressed (Barracuda 文件格式)</li>
</ul>
<h4 id="Redundant"><a href="#Redundant" class="headerlink" title="Redundant"></a>Redundant</h4><p>MySQL 5.0 之前的 InnoDB 默认行记录格式，主要物理结构如下：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OrbcqS"><img src="https://s1.ax1x.com/2022/05/13/OrbcqS.png" alt="OrbcqS.png"></a></p>
<p>其中每个字段间没有分割，是连续记录的。</p>
<ul>
<li><p>字段偏移列表：记录每个字段的相对位置，按照列的顺序逆序放置</p>
<p>实际中每个字段是连续的，如果没有记录尤其是对于变长列而言，是无法知道其位置在哪的。比如最后一个字段是空，那么这条行记录最后只会记录到 Col n-1，这是不是最后一个 Col 就无从得知。因此字段偏移列表中记录了该字段相对于上一个字段的偏移量。</p>
</li>
<li><p>Header：列数量、段偏移表的单位、下一行记录的指针等信息。</p>
</li>
<li><p>RowID：没有可用主键时使用 RowID 作为隐藏主键</p>
</li>
<li><p>TxID(Transaction ID)：事务 ID</p>
</li>
<li><p>Roll Pointer：回滚指针</p>
</li>
<li><p>Col n：未溢出的数据</p>
<p>当数据溢出时，Col 中前 768 Byte 存放数据，其他存放 BLOB 页指针。</p>
</li>
</ul>
<p>对于 Redundant，如果存储的是变长列，字段偏移列表中的字段偏移量能帮我们找到数据段的位置。但如果存储的是定长列，那么字段偏移量就显得冗余了。</p>
<br>

<h4 id="Compact"><a href="#Compact" class="headerlink" title="Compact"></a>Compact</h4><p>MySQL 5.1 默认的行记录格式：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OrOvGj"><img src="https://s1.ax1x.com/2022/05/13/OrOvGj.png" alt="OrOvGj.png"></a></p>
<ul>
<li>变长字段长度表：记录每个<strong>变长</strong>字段的长度，按照列的顺序逆序放置</li>
<li>NULL 标志位：指示记录中的 Null 值，每个 bit 代表一个字段</li>
</ul>
<p>但对于溢出的数据，在 Col 中存放的 768Byte 数据其实是没有必要的。</p>
<br>

<h4 id="Dynamic"><a href="#Dynamic" class="headerlink" title="Dynamic"></a>Dynamic</h4><p>MySQL 5.7 之后默认的行记录格式（最多使用）：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OrvqZ6"><img src="https://s1.ax1x.com/2022/05/13/OrvqZ6.png" alt="OrvqZ6.png"></a></p>
<p>Dynamic 的结构与 Compact 相同，唯一不同的地方在于在 Dynamic 中数据小于 40 Byte 才算未溢出。当数据大于 40 Byte 就将数据全部存入 BLOB 页中，该处 Col 只存放指向 BLOB 页的指针。</p>
<br>

<h4 id="Compressed"><a href="#Compressed" class="headerlink" title="Compressed"></a>Compressed</h4><p> 为了进一步节约空间发展出了 Compressed，它的物理结构与 Dynamic 相同，而它的不同在于：</p>
<ul>
<li>对表的数据行使用 zlib 算法进行了压缩存储</li>
<li>可以节约 40% 左右空间，但对 CPU 的压力比较大</li>
</ul>
<br>

<h2 id="索引的“左侧用法”"><a href="#索引的“左侧用法”" class="headerlink" title="索引的“左侧用法”"></a>索引的“左侧用法”</h2><p><strong>带头大哥不能死，中间兄都不能断，索引列上无操作，范围右边全失效，like百分加右边，字符串中有引号</strong></p>
<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>联合索引指使用两个及以上字段生成的索引。对于联合索引，MySQL 从左到右地使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。联合索引可以加速“最左前缀”的查询，可以替代最左侧字段的单独索引。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Oslk7V"><img src="https://s1.ax1x.com/2022/05/13/Oslk7V.png" alt="Oslk7V.png"></a></p>
<p>联合索引首先按最左侧字段排序，因此可以替代最左侧字段的单独索引。在联合索引匹配过程中，首先会将联合索引中的第一个索引条件和节点中的第一个索引列进行匹配。如果匹配成功，那么接着匹配第二个索引条件和第二个索引列。依次类推，直到所有的索引条件都完成匹配。</p>
<br>

<h3 id="字符串的前缀索引"><a href="#字符串的前缀索引" class="headerlink" title="字符串的前缀索引"></a>字符串的前缀索引</h3><p>前缀索引指定义字符串的一部分当做索引，而不是把整个字符串当做索引，这样可以节省空间。如使用邮箱作为索引则可以省略邮箱的后缀。如果前缀区分度太小，可以考虑两种办法：</p>
<ul>
<li>倒序存储</li>
<li>新建 Hash 字段</li>
</ul>
<p><code>ALTER TABLE USER ADD INDEX email_index(email(6))</code></p>
<br>

<h3 id="字符串-Like"><a href="#字符串-Like" class="headerlink" title="字符串 Like"></a>字符串 Like</h3><p>字符串的左或者左右模糊匹配会使索引失效（%xxx%、%xxx）。这是<strong>因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。</strong></p>
<br>

<h2 id="约束数据"><a href="#约束数据" class="headerlink" title="约束数据"></a>约束数据</h2><h3 id="InnoDB-约束数据的方法"><a href="#InnoDB-约束数据的方法" class="headerlink" title="InnoDB 约束数据的方法"></a>InnoDB 约束数据的方法</h3><ul>
<li><p>Primary Key&#x2F;Unique Key</p>
<p>通过将数据字段设置为索引来约束数据内容。</p>
<ul>
<li>Primary Key：唯一、NOT NULL</li>
<li>Unique Key：唯一</li>
</ul>
<p>但唯一约束插入时的性能开销比较大（需要检查插入的数据是否唯一）。</p>
</li>
<li><p>Foreign Key</p>
<p>外键可以对数据的正确性实现约束。但外键同样是影响性能的，且外键在数据异常修复时会产生问题。</p>
</li>
<li><p>Default&#x2F;NOT NULL</p>
<ul>
<li>Default：数据默认值</li>
<li>NOT NULL：数据不为空（行为可能受到 <code>sql_mode</code> 参数的影响）</li>
</ul>
</li>
<li><p>Trigger</p>
<p>插入、修改数据时使用触发器校验数据。但触发器会干扰业务，使用很少。</p>
</li>
</ul>
<br>

<h2 id="使用不存在的数据表"><a href="#使用不存在的数据表" class="headerlink" title="使用不存在的数据表"></a>使用不存在的数据表</h2><h3 id="视图-View"><a href="#视图-View" class="headerlink" title="视图(View)"></a>视图(View)</h3><p>视图是一种虚拟存在的表，同真实表一样，视图也由列和行构成，但视图并不实际存在于数据库中。行和列的数据来自于定义视图的查询中所使用的表，并且还是在使用视图时动态生成的。原理是一个预设的 <code>SELECT</code> 语句，它的查询结果就作为视图这个虚拟表的数据。</p>
<p>数据库中只存放了视图的定义，并没有存放视图中的数据，这些数据都存放在定义视图查询所引用的真实表中。使用视图查询数据时，数据库会从真实表中取出对应的数据。因此，视图中的数据是依赖于真实表中的数据的。一旦真实表中的数据发生改变，显示在视图中的数据也会发生改变。</p>
<p>视图可以从原有的表上选取对用户有用的信息，那些对用户没用，或者用户没有权限了解的信息，都可以直接屏蔽掉，作用类似于筛选。这样做既使应用简单化，也保证了系统的安全。</p>
<br>

<h3 id="视图算法的选择"><a href="#视图算法的选择" class="headerlink" title="视图算法的选择"></a>视图算法的选择</h3><ul>
<li>MERGE：将视图的 SQL 合并到主查询的 SQL 中</li>
<li>TEMPTABLE：将视图作为临时表（中间结果）来处理</li>
<li>UNDEFINED：未定义（默认）</li>
</ul>
<p>一般来讲，MERGE 的性能优于 TEMPTABLE（没有中间结果）。</p>
<br>

<h3 id="无法使用-MERGE-的-SQL"><a href="#无法使用-MERGE-的-SQL" class="headerlink" title="无法使用 MERGE 的 SQL"></a>无法使用 MERGE 的 SQL</h3><ul>
<li>聚集函数</li>
<li>DISTINCT</li>
<li>GROUP BY</li>
<li>HAVING</li>
<li>UNION、UNION ALL</li>
<li>子查询</li>
</ul>
<br>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>如何建表更符合业务</strong></p>
<ul>
<li>增加每页数据量：<ul>
<li>尽量做到冷热数据分离，减小表的宽度</li>
<li>优先选择符合存储需要的最小的数据类型</li>
</ul>
</li>
<li>避免行溢出：<ul>
<li>把 BLOB 或 TEXT 列分离到单独的扩展表中</li>
<li>禁止在数据库中存储图片、文件等大的二进制数据</li>
</ul>
</li>
<li>控制 B+ 树高度：<ul>
<li>尽量控制单表数据量的大小，建议控制在 500 万以内</li>
</ul>
</li>
</ul>
<br>

<h1 id="怎样查询速度更快"><a href="#怎样查询速度更快" class="headerlink" title="怎样查询速度更快"></a>怎样查询速度更快</h1><h2 id="示例数据库的安装"><a href="#示例数据库的安装" class="headerlink" title="示例数据库的安装"></a>示例数据库的安装</h2><h3 id="Sakila-db"><a href="#Sakila-db" class="headerlink" title="Sakila-db"></a>Sakila-db</h3><p>Sakila 是 MySQL 中的一个示例数据库(sample database)，它展示了一个电影 DVD 租赁公司的后台管理系统。</p>
<p>下载链接：<a target="_blank" rel="noopener" href="https://downloads.mysql.com/docs/sakila-db.zip">https://downloads.mysql.com/docs/sakila-db.zip</a></p>
<p>下载完后导入 sakila-schema.sql 文件和 sakila-data.sql 文件。</p>
<br>

<h2 id="WHERE-查询太慢"><a href="#WHERE-查询太慢" class="headerlink" title="WHERE 查询太慢"></a>WHERE 查询太慢</h2><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>覆盖索引指是查询的数据列只用从索引中就能够取得，不必读取数据行，即查询列要被所建的索引覆盖。覆盖索引可以有效地减少回表。</p>
<p>如果想要通过覆盖索引查询多列，那么需要给需要查询的列建立一个多列索引，当然如果带查询条件，WHERE 条件要求满足最左前缀原则。InnoDB 的辅助索引叶子节点包含的是主键列，所以主键一定是被索引覆盖的。</p>
<p>复制 inventory 数据表，去掉外键、联合索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `inventory_1` (</span><br><span class="line">  `inventory_id` mediumint unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `film_id` <span class="type">smallint</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `store_id` tinyint unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `last_update` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`inventory_id`),</span><br><span class="line">  KEY `idx_fk_film_id` (`film_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">4582</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_ai_ci</span><br></pre></td></tr></table></figure>

<p>复制数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> inventory_1 <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> inventory</span><br></pre></td></tr></table></figure>

<p>查询以下语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> store_id, film_id <span class="keyword">from</span> sakila.`inventory_1` <span class="keyword">where</span> store_id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OsLyoF"><img src="https://s1.ax1x.com/2022/05/13/OsLyoF.png" alt="OsLyoF.png"></a></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> store_id, film_id <span class="keyword">from</span> sakila.`inventory` <span class="keyword">where</span> store_id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OsLOSA"><img src="https://s1.ax1x.com/2022/05/13/OsLOSA.png" alt="OsLOSA.png"></a></p>
<p>可以看到，我们复制的删除了外键、联合索引的数据表在查询时并没有走索引(Extra &#x3D; Using where)</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OsOsXt"><img src="https://s1.ax1x.com/2022/05/13/OsOsXt.png" alt="OsOsXt.png"></a>而原本的 inventory 数据表由于存在一个组合索引(store_id，film_id)且这个索引以及包含我们查询的 store_id 和 film_id，因此 MySQL 从查询到数据返回就都可以使用这个索引，实现覆盖索引(Extra &#x3D; Using index)：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OsOmwT"><img src="https://s1.ax1x.com/2022/05/13/OsOmwT.png" alt="OsOmwT.png"></a></p>
<p>查询以下语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> inventory_id, store_id, film_id <span class="keyword">from</span> sakila.`inventory` <span class="keyword">where</span> store_id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OsXtvn"><img src="https://s1.ax1x.com/2022/05/13/OsXtvn.png" alt="OsXtvn.png"></a></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> inventory_id, store_id, film_id, last_update <span class="keyword">from</span> sakila.`inventory` <span class="keyword">where</span> store_id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OsXy8J"><img src="https://s1.ax1x.com/2022/05/13/OsXy8J.png" alt="OsXy8J.png"></a></p>
<p>首先这两句 SQL 查询都可以使用联合索引（最左字段）。但第一句走了覆盖索引而不需要回表，这是因为虽然查询到内容比联合索引多了一个字段，但这个字段是主键，本来就存在于联合索引中。因此比联合索引中的字段多一个主键字段就不需要回表而走了覆盖索引。</p>
<p>对于第二句 SQL，它可以使用联合索引搜索符合条件的记录，但它不仅多了主键字段还多了一条非主键非联合索引中字段的字段，因此它无法覆盖索引而回表。这种情况若多余的字段非必须则应该去掉，这样对查询效率有很大影响。</p>
<br>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>覆盖索引通过取消回表操作提升了查询效率</li>
<li>若数据的查询不只使用了一个索引，则不是覆盖索引</li>
<li>可以通过优化SQL语句或优化联合索引，来使用覆盖索引</li>
</ul>
<br>

<h2 id="有更合适的索引不走"><a href="#有更合适的索引不走" class="headerlink" title="有更合适的索引不走"></a>有更合适的索引不走</h2><h3 id="如何确定用哪条索引"><a href="#如何确定用哪条索引" class="headerlink" title="如何确定用哪条索引"></a>如何确定用哪条索引</h3><p>在 MySQL 选取索引时，会参考索引的基数(Cardinality)。基数是 MySQL 估算的，用来反映这个字段有多少种取值（选取几个页算出取值的平均值再乘以页数，即为基数）。因此这个估算是不准确的。</p>
<br>

<h3 id="基数的应用"><a href="#基数的应用" class="headerlink" title="基数的应用"></a>基数的应用</h3><p>执行以下语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个只有一列 city 的表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> sakila.`city_1`(city <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>);</span><br><span class="line"># 从老 city 表中复制五次数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sakila.city_1 <span class="keyword">select</span> city <span class="keyword">from</span> sakila.city;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sakila.city_1 <span class="keyword">select</span> city <span class="keyword">from</span> sakila.city;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sakila.city_1 <span class="keyword">select</span> city <span class="keyword">from</span> sakila.city;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sakila.city_1 <span class="keyword">select</span> city <span class="keyword">from</span> sakila.city;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sakila.city_1 <span class="keyword">select</span> city <span class="keyword">from</span> sakila.city;</span><br><span class="line"># 将新 city 表中的数据打乱</span><br><span class="line"><span class="keyword">update</span> sakila.city_1 <span class="keyword">set</span> city<span class="operator">=</span>(<span class="keyword">select</span> city <span class="keyword">from</span> sakila.city <span class="keyword">order</span> <span class="keyword">by</span> RAND() limit <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>增加以下前缀索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 分别使用 city 字段的前 <span class="number">1</span><span class="number">-8</span> 个字符作为前缀索引</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> sakila.city_1 <span class="keyword">add</span> key (city(<span class="number">1</span>));</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> sakila.city_1 <span class="keyword">add</span> key (city(<span class="number">2</span>));</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> sakila.city_1 <span class="keyword">add</span> key (city(<span class="number">3</span>));</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> sakila.city_1 <span class="keyword">add</span> key (city(<span class="number">4</span>));</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> sakila.city_1 <span class="keyword">add</span> key (city(<span class="number">5</span>));</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> sakila.city_1 <span class="keyword">add</span> key (city(<span class="number">6</span>));</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> sakila.city_1 <span class="keyword">add</span> key (city(<span class="number">7</span>));</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> sakila.city_1 <span class="keyword">add</span> key (city(<span class="number">8</span>));</span><br></pre></td></tr></table></figure>

<p>查看各个索引的基数：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Osz8Zq"><img src="https://s1.ax1x.com/2022/05/13/Osz8Zq.png" alt="Osz8Zq.png"></a></p>
<p>可以看到当我们使用第一个字符作为前缀索引时的基数为 26，即有 26 种可能的取值。当使用前两个字符作为前缀索引时的基数为 186，这样以城市名进行查询时的粒度更细，扫描所有行的数量更少。在以前五个字符作为前缀索引以后的熟悉明显的变低了(基数增长不大)，因此这里使用前三个或前四个字符作为前缀索引收益较好且占用磁盘少。</p>
<p>因此 MySQL 会根据 Cardinality 的大小来选择区分度更大的索引。但这个值是估算出来的有可能不准确，因此需要我们强制使用索引。</p>
<br>

<h3 id="强制使用索引"><a href="#强制使用索引" class="headerlink" title="强制使用索引"></a>强制使用索引</h3><p>使用 <code>force index</code> 可以强制使用索引。</p>
<br>

<h3 id="优化索引"><a href="#优化索引" class="headerlink" title="优化索引"></a>优化索引</h3><p>使用 <code>analyze table</code> 可以重新统计索引信息。在重新统计索引信息时会重新计算索引的基数。</p>
<br>

<h2 id="COUNT-查询太慢"><a href="#COUNT-查询太慢" class="headerlink" title="COUNT 查询太慢"></a>COUNT 查询太慢</h2><h3 id="MySQL-COUNT-函数"><a href="#MySQL-COUNT-函数" class="headerlink" title="MySQL COUNT() 函数"></a>MySQL COUNT() 函数</h3><p>COUNT() 函数用来统计结果集中不为 NULL 的数据的个数：</p>
<ol>
<li>存储引擎查询出结果集</li>
<li>Server 层逐个判断结果是否为 NULL，不为 NULL 则加 1</li>
</ol>
<p>使用 customer 表测试，查询表中的索引 <code>show index from customer</code>：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Oy9FsJ"><img src="https://s1.ax1x.com/2022/05/13/Oy9FsJ.png" alt="Oy9FsJ.png"></a></p>
<br>

<h3 id="COUNT-非索引字段"><a href="#COUNT-非索引字段" class="headerlink" title="COUNT(非索引字段)"></a>COUNT(非索引字段)</h3><p>使用 COUNT() 统计非索引字段时，Server 层需要判断每个数据是否为 NULL，而且查询本身无法使用覆盖索引，理论上最慢：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="built_in">count</span>(first_name) <span class="keyword">from</span> sakila.customer;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OyCA1S"><img src="https://s1.ax1x.com/2022/05/13/OyCA1S.png" alt="OyCA1S.png"></a></p>
<p>可以看到没有任何可能的索引因此使用了全表扫描，首先查询出所有的行，再将所有行中的 first_name 列解析出来，然后交给 Server 层一个一个地判断结果是否为 NULL 来计算行的数量。</p>
<br>

<h3 id="COUNT-索引字段"><a href="#COUNT-索引字段" class="headerlink" title="COUNT(索引字段)"></a>COUNT(索引字段)</h3><p>使用 COUNT() 统计索引字段时，不需要对行记录进行解析且使用了覆盖索引，但依然需要判断字段是否为 NULL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="built_in">count</span>(last_name) <span class="keyword">from</span> sakila.customer;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OyCvCV"><img src="https://s1.ax1x.com/2022/05/13/OyCvCV.png" alt="OyCvCV.png"></a></p>
<p>对于使用 COUNT() 统计主键也是如此，MySQL 并没有对主键的 COUNT() 函数进行优化，就算主键不能为 NULL，查询出的记录也会被送往 Server 层进行非空统计：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="built_in">count</span>(customer_id) <span class="keyword">from</span> sakila.customer;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="COUNT-1"><a href="#COUNT-1" class="headerlink" title="COUNT(1)"></a>COUNT(1)</h3><p>COUNT(1) 只扫描了索引树，没有解析数据行的过程，理论上更快。但 Server 层仍然每次都需要判断 1 是否为 NULL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">from</span> sakila.customer;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OyPxII"><img src="https://s1.ax1x.com/2022/05/13/OyPxII.png" alt="OyPxII.png"></a></p>
<br>

<h3 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT(*)"></a>COUNT(*)</h3><p>COUNT(*) 一般用来返回数据表的行数。在 MyISAM 中的 COUNT(*) 直接返回数据库中记录的数据表行数。但由于 InnoDB 支持事务，导致其数据库中的数据表的行数无法准确的记录而不被记录。但 MySQL 专门优化了 COUNT(*) 函数，使其直接返回索引树中数据的个数。</p>
<p>因此，在统计数据表的行数时最好使用 COUNT(*)。</p>
<br>

<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>COUNT(非索引字段)：无法使用覆盖索引，最慢</li>
<li>COUNT(索引字段)：可以使用覆盖索引但仍需要逐个取出数据判断是否为 NULL</li>
<li>COUNT(1)：不需要取出数据，但需要判断 1 是否为 NULL</li>
<li>COUNT(*)：经过专门优化，不需要判空，理论最快</li>
</ul>
<br>

<h2 id="ORDER-BY-查询太慢"><a href="#ORDER-BY-查询太慢" class="headerlink" title="ORDER BY 查询太慢"></a>ORDER BY 查询太慢</h2><h3 id="ORDER-BY-执行步骤原理"><a href="#ORDER-BY-执行步骤原理" class="headerlink" title="ORDER BY 执行步骤原理"></a>ORDER BY 执行步骤原理</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `film` <span class="keyword">where</span> film_id <span class="operator">&gt;</span> <span class="number">80</span> <span class="keyword">order</span> <span class="keyword">by</span> title;</span><br></pre></td></tr></table></figure>

<ol>
<li>根据 WHERE 等条件进行查询</li>
<li>将查询结果存入 sort_buffer(MySQL 中排序专用缓存，用来存放需要被排序的数据内容)</li>
<li>对中间结果集安装 ORDER 字段进行排序</li>
<li>回表生产完整结果集(若需要)</li>
</ol>
<br>

<h3 id="优化条件查询"><a href="#优化条件查询" class="headerlink" title="优化条件查询"></a>优化条件查询</h3><p>给查询字段添加索引可以改善条件查询的速度。但这里的 film_id 为主键，本身就有索引，因此改善不了太多查询速度。</p>
<br>

<h3 id="优化中间结果集"><a href="#优化中间结果集" class="headerlink" title="优化中间结果集"></a>优化中间结果集</h3><p>当中间表比较小时，会将中间表直接存放在内存中；当中间表大于 <code>sort_buffer_size</code> 参数的值时，会将中间表存放在硬盘中。</p>
<p>因此，如果需要优化内存占用，则可以减小 <code>sort_buffer_size</code> 参数；如果需要优化排序查询的时间且内存足够，则可以增大 <code>sort_buffer_size</code> 参数。</p>
<br>

<h3 id="优化回表"><a href="#优化回表" class="headerlink" title="优化回表"></a>优化回表</h3><p>当行数据小于 <code>max_length_for_sort_data</code> 参数的值时，会生成全字段中间表；大于这个阈值时，只会生成 排序字段 + 主键 中间表，但需要回表生成完整结果集。</p>
<p>但调大 <code>max_length_for_sort_data</code> 参数的值并不一定能改善效率，因为太大的中间结果集会被存入硬盘中，且数据过大在排序时读写也会变慢。</p>
<br>

<h3 id="覆盖索引-1"><a href="#覆盖索引-1" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>覆盖索引可以跳过生成中间结果集而直接输出查询结果(WHERE 和 ORDER BY 的条件使用同一个索引)。要求 ORDER 字段需要有索引(活在联合索引左侧)；其他相关字段(条件、输出)均在上诉的索引中：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> film;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OyVHzt"><img src="https://s1.ax1x.com/2022/05/13/OyVHzt.png" alt="OyVHzt.png"></a></p>
<p>因此对于下面的 SQL 语句就可以使用覆盖索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> film_id, title <span class="keyword">from</span> film <span class="keyword">order</span> <span class="keyword">by</span> title;</span><br></pre></td></tr></table></figure>

<p>这条语句没有 WHERE 条件且 film_id 与 title 在同一个索引中。若需要使用 WHERE 语句添加条件，则该条件必须是约束 title 的。</p>
<br>

<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul>
<li>MySQL 排序一般需要生成中间结果集、排序、回表的过程</li>
<li>索引覆盖是最高效的处理排序的方式</li>
</ul>
<br>

<h2 id="随机选取太慢"><a href="#随机选取太慢" class="headerlink" title="随机选取太慢"></a>随机选取太慢</h2><h3 id="ORDER-BY-RAND-原理"><a href="#ORDER-BY-RAND-原理" class="headerlink" title="ORDER BY RAND() 原理"></a>ORDER BY RAND() 原理</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> title, description, <span class="keyword">from</span> `film` <span class="keyword">order</span> <span class="keyword">by</span> rand() limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>创建一个临时表，临时表的字段为 rand、title、description</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Oy1Vwq"><img src="https://s1.ax1x.com/2022/05/13/Oy1Vwq.png" alt="Oy1Vwq.png" style="zoom: 50%;" /></a></p>
</li>
<li><p>从表中取出一行，调用 RAND() 将结果和数据放入临时表，以此类推</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Oy1tk6"><img src="https://s1.ax1x.com/2022/05/13/Oy1tk6.png" alt="Oy1tk6.png" style="zoom: 50%;" /></a></p>
</li>
<li><p>针对临时表，将 rand 字段 + 行位置(或主键) 放入 sort_buffer 中</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Oy1T7q"><img src="https://s1.ax1x.com/2022/05/13/Oy1T7q.png" alt="Oy1T7q.png"></a></p>
</li>
<li><p>对 sort_buffer 进行排序，取出第一个行位置(或主键)来查询临时表</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Oy3aEq"><img src="https://s1.ax1x.com/2022/05/13/Oy3aEq.png" alt="Oy3aEq.png"></a></p>
<p>这里 MySQL 进行了优化：若只需要前几个数据，那么只关心前行数据的排序而对之后数据的排序不关心。</p>
</li>
</ol>
<br>

<h3 id="性能不好的原因"><a href="#性能不好的原因" class="headerlink" title="性能不好的原因"></a>性能不好的原因</h3><ol>
<li>SQL 执行过程中出现了两次中间结果(临时表和 sort_buffer)，且它们都是全长度的。</li>
<li>只需要一个随机结果，却经历了不必要的排序（虽然优化过）。</li>
<li>调用了多次 RAND()。</li>
</ol>
<br>

<h3 id="临时解决方案"><a href="#临时解决方案" class="headerlink" title="临时解决方案"></a>临时解决方案</h3><p>在不修改业务逻辑的情况下可以只修改 SQL 语句来优化：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># <span class="variable">@M</span> <span class="operator">=</span> <span class="built_in">max</span>(film_id)  <span class="variable">@N</span> <span class="operator">=</span> <span class="built_in">min</span>(film_id)</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(film_id), <span class="built_in">min</span>(film_id) <span class="keyword">into</span> <span class="variable">@M</span>, <span class="variable">@N</span> <span class="keyword">from</span> film;</span><br><span class="line"># 随机选取最大ID和最小ID之前的一个ID</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@X</span> <span class="operator">=</span> <span class="built_in">floor</span>((<span class="variable">@M</span> <span class="operator">-</span> <span class="variable">@N</span> <span class="operator">+</span> <span class="number">1</span>) <span class="operator">*</span> rand() <span class="operator">+</span> <span class="variable">@N</span>);</span><br><span class="line"># 取出随机选取的ID</span><br><span class="line"># 由于数据表中的主键不一定连续，因此需要使用<span class="keyword">where</span>条件和limit来取</span><br><span class="line"><span class="keyword">select</span> title, description <span class="keyword">from</span> film <span class="keyword">where</span> film_id <span class="operator">&gt;=</span> <span class="variable">@X</span> limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>选取数据中最大的 ID 和最小的 ID</li>
<li>使用 RAND() 随机选取一个 ID</li>
<li>直接查询此 ID 的数据条目</li>
</ol>
<br>

<h3 id="业务解决方案"><a href="#业务解决方案" class="headerlink" title="业务解决方案"></a>业务解决方案</h3><ol>
<li><p>查询数据表总数 total</p>
</li>
<li><p>在 total 范围内随机选取一个数字 r</p>
</li>
<li><p>执行以下 SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> `title`, `description` <span class="keyword">from</span> `film` limit r, <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<br>

<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ol>
<li>ORDER BY RAND() LIMIT 1 是效率很低的随机查询方式</li>
<li>原因主要是上述方法有两次中间结果且还有排序过程</li>
<li>可以通过修改 SQL 选取随机主键的方式来提升性能</li>
<li>最好还是在业务中处理，尽量减少复杂 SQL</li>
</ol>
<br>

<h2 id="带头大哥丢了"><a href="#带头大哥丢了" class="headerlink" title="带头大哥丢了"></a>带头大哥丢了</h2><p>建立如下数据表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `inventory_2` (</span><br><span class="line">  `inventory_id` mediumint unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `film_id` <span class="type">smallint</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `store_id` tinyint unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `last_update` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`inventory_id`),</span><br><span class="line">  KEY `idx_store_id_film_id`(`store_id`, `film_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">4582</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_ai_ci</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `inventory_2` <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `inventory`</span><br></pre></td></tr></table></figure>

<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>索引下推（Index Condition Pushdown ICP）的<strong>下推</strong>其实就是指将部分上层（服务层）负责的事情，交给了下层（引擎层）去处理。索引下推可以大大减少回表的次数。</p>
<p>在没有使用 ICP 的情况下，MySQL 的查询：</p>
<ul>
<li>存储引擎读取索引记录；</li>
<li>根据索引中的主键值，定位并读取完整的行记录；</li>
<li>存储引擎把记录交给<code>Server</code>层去检测该记录是否满足<code>WHERE</code>条件。</li>
</ul>
<p>使用 ICP 的情况下，查询过程：</p>
<ul>
<li>存储引擎读取索引记录（不是完整的行记录）；</li>
<li>判断条件部分能否用索引中的列来做检查，条件不满足，则处理下一行索引记录；</li>
<li>条件满足，使用索引中的主键去定位并读取完整的行记录（回表）；</li>
<li>存储引擎把记录交给层，层检测该记录是否满足条件的其余部分。</li>
</ul>
<p>虽然我们创建了字段为 store_id 和 film_id 的联合索引，但当执行下列 SQL 语句时是不会使用覆盖索引的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `inventory_2` <span class="keyword">where</span> `store_id` <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>) <span class="keyword">and</span> `film_id` <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>联合索引是主要以第一个字段排序的，当第一个字段相同时才使用第二个字段排序。当我们查询出 <code>store_id in(1, 2) </code> 的数据后会先按照 store_id 排序，然后再按照 film_id 进行排序。但这样排序出来的 film_id 是乱序的，因此无法使用同一条索引将需要的 <code>film_id = 3</code> 的数据查询出来。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OyNi4I"><img src="https://s1.ax1x.com/2022/05/13/OyNi4I.png" alt="OyNi4I.png" style="zoom: 33%;" /></a></p>
<p>在没有使用 ICP 时，由于无法使用覆盖索引，因此本次查询需要四次回表才能完成。而在使用 ICP 的情况下，只需要在找到符合条件的记录时回表获取全部信息即可，只需要一次回表。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Oy0X8A"><img src="https://s1.ax1x.com/2022/05/13/Oy0X8A.png" alt="Oy0X8A.png"></a></p>
<br>

<h3 id="索引跳跃扫描"><a href="#索引跳跃扫描" class="headerlink" title="索引跳跃扫描"></a>索引跳跃扫描</h3><p>当执行下列 SQL 语句时，由于 film_id 不是联合索引的最左字段，因此这条 SQL 无法使用联合索引，需要进行全表扫描：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> `film_id` <span class="keyword">from</span> `inventory_2` <span class="keyword">where</span> `film_id` <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>但在 MySQL 8.0.13 开始支持 Index Skip Scan 即索引跳跃扫描。该优化方式支持那些 SQL 在不符合组合索引最左前缀的原则的情况，优化器依然能使用组合索引。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OyDDTU"><img src="https://s1.ax1x.com/2022/05/13/OyDDTU.png" alt="OyDDTU.png"></a></p>
<p>因此索引跳跃扫描可以打破左侧原则，在带头大哥丢了的情况下也不需要进行全表扫描，解决带头大哥丢失的问题。</p>
<br>

<h2 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h2><p>尝试以下 SQL 语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> film <span class="keyword">where</span> film_id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OyrkXq"><img src="https://s1.ax1x.com/2022/05/14/OyrkXq.png" alt="OyrkXq.png"></a></p>
<p>虽然我们查询的条件为主键，但还是未使用索引。这是因为在 MySQL 中对索引字段做函数操作，优化器会放弃索引。</p>
<h3 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `rental` <span class="keyword">where</span> <span class="keyword">month</span>(rental_date) <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OyrJHK"><img src="https://s1.ax1x.com/2022/05/14/OyrJHK.png" alt="OyrJHK.png"></a></p>
<p>使用 month() 函数后无法使用索引。一旦使用函数后就会破坏原来索引的顺序而导致无法使用索引。</p>
<p>可以去掉 month() 函数，使用 between 来优化(很麻烦)：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `rental` <span class="keyword">where</span> `rental_date` <span class="keyword">between</span> <span class="string">&#x27;2005-5-1&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2005-6-1&#x27;</span> <span class="keyword">or</span> `rental_date` <span class="keyword">between</span> <span class="string">&#x27;2006-5-1&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2006-6-1&#x27;</span>;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="字符串与数字比较"><a href="#字符串与数字比较" class="headerlink" title="字符串与数字比较"></a>字符串与数字比较</h3><p>MySQL 中若出现字符串与数字比较，会将字符串转换为数字。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> f1 <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<p>如果 t1 表中的 f1 字段为 varchar 类型，则此 SQL 语句相当于：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> <span class="built_in">cast</span>(f1 <span class="keyword">as</span> signed <span class="type">int</span>) <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<p>解决方案：将第一条 SQL 语句中的 6 改为 ‘6’。</p>
<p>建表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `t1`(</span><br><span class="line">	`f1` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `f2` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  key `idx_f1`(`f1`),</span><br><span class="line">  key `idx_f2`(`f2`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="string">&#x27;4&#x27;</span>, <span class="number">6</span>),(<span class="string">&#x27;6&#x27;</span>, <span class="number">3</span>),(<span class="string">&#x27;7&#x27;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<br>

<h3 id="隐式字符编码转换"><a href="#隐式字符编码转换" class="headerlink" title="隐式字符编码转换"></a>隐式字符编码转换</h3><p>新建表 t2，并执行以下语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `t2`(</span><br><span class="line">	`f1` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `f2` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  key `idx_f1`(`f1`),</span><br><span class="line">  key `idx_f2`(`f2`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">values</span>(<span class="string">&#x27;4&#x27;</span>, <span class="number">5</span>),(<span class="string">&#x27;2&#x27;</span>, <span class="number">4</span>),(<span class="string">&#x27;2&#x27;</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t2.<span class="operator">*</span> <span class="keyword">from</span> t1, t2 <span class="keyword">where</span> t1.f1 <span class="operator">=</span> t2.f1 <span class="keyword">and</span> t1.f2 <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<p>这条 SQL 语句按理首先查询 t1.f2 时能使用索引，然后查询 t2.f1 时也能使用索引。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Oy6SAK"><img src="https://s1.ax1x.com/2022/05/14/Oy6SAK.png" alt="Oy6SAK.png"></a></p>
<p>但是我们发现在查询 t2 表时使用的全表扫描而未使用索引。</p>
<p>仔细观察两个建表语句可以发现，它们使用了两种不同的字符编码。在 MySQL 中，utf8 与 utf8mb4 字段比较时会把 utf8 转换为 utf8mb4 编码。</p>
<p>因此上面的 SQL 语句相当于：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t2.<span class="operator">*</span> <span class="keyword">from</span> t1, t2 <span class="keyword">where</span> t1.f1 <span class="operator">=</span> <span class="keyword">convert</span>(t2.f1 <span class="keyword">using</span> utf8mb4) <span class="keyword">and</span> t1.f2 <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<p>解决方案：将查询条件转换为索引字段的编码</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t2.<span class="operator">*</span> <span class="keyword">from</span> t1, t2 <span class="keyword">where</span> <span class="keyword">convert</span>(t1.f1 <span class="keyword">using</span> utf8) <span class="operator">=</span> t2.f1 <span class="keyword">and</span> t1.f2 <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><ul>
<li>在 MySQL 中，对索引字段做函数操作会使优化器会放弃索引</li>
<li>这种情况可能包括：时间函数，字符串转数字，字符编码转换</li>
<li>解决方案：时间函数转区间、数字强转字符串、高级编码转低级</li>
</ul>
<br>

<h2 id="分页查询太慢"><a href="#分页查询太慢" class="headerlink" title="分页查询太慢"></a>分页查询太慢</h2><h3 id="偏移量大时效率低"><a href="#偏移量大时效率低" class="headerlink" title="偏移量大时效率低"></a>偏移量大时效率低</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> film_id, title, description <span class="keyword">from</span> film <span class="keyword">order</span> <span class="keyword">by</span> title limit <span class="number">900</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>这条 SQL 语句丢弃了很多无用数据，效率低下。</p>
<br>

<h3 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h3><ul>
<li><p>尽量使用覆盖索引</p>
<p>但在 film 数据表中并没有覆盖了 film_id、title 和 description 的索引。此时若无法再修改索引，则可以：</p>
<ul>
<li>得到所需数据的主键 ID</li>
<li>根据所需数据的 ID 回表得到最终结果集</li>
</ul>
<p>这样就避免了排序的操作（title 索引已经预排序好）。</p>
</li>
</ul>
<p>即：</p>
<ol>
<li><p>得到所需数据的主键 ID</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用了覆盖索引</span><br><span class="line"><span class="keyword">select</span> film_id <span class="keyword">from</span> film <span class="keyword">order</span> <span class="keyword">by</span> title limit <span class="number">900</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>原表与得到的结果连表获取最终结果</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> film_id, title, description <span class="keyword">from</span> film f</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> (<span class="keyword">select</span> film_id <span class="keyword">from</span> film <span class="keyword">order</span> <span class="keyword">by</span> title limit <span class="number">900</span>, <span class="number">10</span>) m</span><br><span class="line"><span class="keyword">on</span> f.film_id <span class="operator">=</span> m.film_id;</span><br></pre></td></tr></table></figure></li>
</ol>
<br>

<h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><h3 id="慢查询的怀疑方向"><a href="#慢查询的怀疑方向" class="headerlink" title="慢查询的怀疑方向"></a>慢查询的怀疑方向</h3><ol>
<li>索引设计有问题</li>
<li>SQL 语句有问题</li>
<li>数据库选错索引</li>
</ol>
<br>

<h1 id="如何处理数据更新"><a href="#如何处理数据更新" class="headerlink" title="如何处理数据更新"></a>如何处理数据更新</h1><h2 id="数据库运行后可能产生的性能问题"><a href="#数据库运行后可能产生的性能问题" class="headerlink" title="数据库运行后可能产生的性能问题"></a>数据库运行后可能产生的性能问题</h2><h3 id="产生日志数据"><a href="#产生日志数据" class="headerlink" title="产生日志数据"></a>产生日志数据</h3><p>数据库在更新时会产生 binlog、redo log、undo log：</p>
<ul>
<li>binlog：Server 层产生的逻辑日志（更新记录）</li>
<li>redo log：InnoDB 产生的物理日志，用来保证持久化（D）</li>
<li>undo log：InnoDB 产生的逻辑日志，用来保证原子性、隔离性（A、I）</li>
</ul>
<br>

<h3 id="客户端之间因为锁而互相影响"><a href="#客户端之间因为锁而互相影响" class="headerlink" title="客户端之间因为锁而互相影响"></a>客户端之间因为锁而互相影响</h3><p>客户端执行 SQL 时会产生各种行锁、表锁、元数据锁，一个客户端产生的锁会干扰其他客户端 SQL 的执行，两个客户端之间可能产生死锁。</p>
<br>

<h3 id="事务造成查询到的数据与磁盘上不一致"><a href="#事务造成查询到的数据与磁盘上不一致" class="headerlink" title="事务造成查询到的数据与磁盘上不一致"></a>事务造成查询到的数据与磁盘上不一致</h3><p>客户端可能暂时看不到已经更新的数据，事务可能产生隐式锁而造成性能问题。</p>
<br>

<h2 id="不给人看的日志"><a href="#不给人看的日志" class="headerlink" title="不给人看的日志"></a>不给人看的日志</h2><h3 id="MySQL-日志体系"><a href="#MySQL-日志体系" class="headerlink" title="MySQL 日志体系"></a>MySQL 日志体系</h3><p>MySQL 为了满足主从复制、事务等功能实现了复杂的日志体系。如 Server 层产生的 binlog，主要用于实现数据的复制。InnoDB 产生的 undo log、redo log 主要用于实现事务的 ACID。MySQL 的日志体系主要不是用来看的，而是运行时必要的资源。</p>
<br>

<h3 id="binlog-归档日志"><a href="#binlog-归档日志" class="headerlink" title="binlog 归档日志"></a>binlog 归档日志</h3><p>binlog <strong>主要记录数据库的操作变化情况</strong>，内容包括数据库所有的更新操作。所有涉及数据变动的操作，都要记录进 binlog 日志中，binlog 被记录在专门的文件中。</p>
<p>因此，有了 binlog 就可以很方便的对数据进行复制和备份，因而也<strong>常用作主从库的同步</strong>。主数据库将所有涉及数据变动记录到 binlog，从数据库读取 binlog 更新。同时由于 binlog 完整地记录了数据库每次的数据操作，因此也可作为数据闪回的手段。</p>
<br>

<h3 id="undo-log-回滚日志"><a href="#undo-log-回滚日志" class="headerlink" title="undo log 回滚日志"></a>undo log 回滚日志</h3><p>undo log 日志的作用是对数据进行回滚，位于表空间的 undo segment 中。当事务对数据库进行修改时，InnoDB 会生成对应的 undo log 日志。如果事务执行失败或调用了rollback，导致事务需要回滚时就可以利用 undo log 中的信息将数据回滚到修改之前的样子。</p>
<p>undo log 记录的是回滚时需要执行的具体操作而不是当前事务执行了什么操作。当发生回滚时，InnoDB 会根据undo log 日志中的记录做与之前相反的工作。比如对于每个数据插入操作（insert），回滚时会执行数据删除操作（delete）；对于每个数据删除操作（delete），回滚时会执行数据插入操作（insert）；对于每个数据更新操作（update），回滚时会执行一个相反的数据更新操作（update），把数据改回去。</p>
<br>

<h3 id="redo-log-重做日志"><a href="#redo-log-重做日志" class="headerlink" title="redo log 重做日志"></a>redo log 重做日志</h3><p>redo log 是 InnoDB 产生的物理日志，用于记录数据页的变化。当修改数据页时，内存中的数据更新后 redo log 会记录数据页的具体变化，之后再根据 redo log 中记录的变化来将数据写入磁盘中持久化。因此，记录 redo log 即可视为数据已经更新。</p>
<p>redo log 存放在 4 个 1GB 文件中并且是循环写入的：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/O627TI"><img src="https://s1.ax1x.com/2022/05/14/O627TI.png" alt="O627TI.png" style="zoom: 33%;" /></a></p>
<ul>
<li>write pos：当前日志写入点</li>
<li>check point：擦除点，当数据更新到硬盘时擦除</li>
</ul>
<p>write pos 到 check point 之间的部分是 redo log 空余部分，用于记录新的记录。check point 到 write pos 之间是 redo log 待落盘的数据页更改记录。</p>
<p>当 write pos 追上 check point 时，会先推动 check point 向前移动，空出位置再记录新的日志。</p>
<p>启动 InnoDB 时，不管上次是正常关闭还是异常关闭，总是会进行恢复操作。因为 redo log 记录的是数据页的物理变化，因此恢复的时候速度比逻辑日志(如 binlog)要快很多。</p>
<p>重启 InnoDB 时，首先会检查磁盘中数据页的 LSN ，如果数据页的 LSN 小于日志中的 LSN ，则会从 check point 开始恢复。如果在宕机前正处于 checkpoint 的刷盘过程，且数据页的刷盘进度超过了日志页的刷盘进度，此时会出现数据页中记录的 LSN 大于日志中的 LSN，这时超出日志进度的部分将不会重做，因为这本身就表示已经做过的事情，无需再重做。 </p>
<br>

<h3 id="redo-log与binlog区别"><a href="#redo-log与binlog区别" class="headerlink" title="redo log与binlog区别"></a>redo log与binlog区别</h3><ol>
<li>redo log 是 InnoDB 引擎特有的，提供了系统 crash-safe 恢复能力。binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li>
<li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”。binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID&#x3D;2 这一行的 c 字段加 1 ”。</li>
<li>redo log 是循环写的，空间固定会用完。binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>
</ol>
<br>

<h2 id="一条数据是如何更新的"><a href="#一条数据是如何更新的" class="headerlink" title="一条数据是如何更新的"></a>一条数据是如何更新的</h2><h3 id="数据更新流程"><a href="#数据更新流程" class="headerlink" title="数据更新流程"></a>数据更新流程</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/O6fYTA"><img src="https://s1.ax1x.com/2022/05/14/O6fYTA.png" alt="O6fYTA.png"></a></p>
<p>比如执行 <code>update T set c=c+1 where ID = 2</code> 语句：</p>
<ol>
<li>执行器先找引擎取 ID&#x3D;2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID&#x3D;2 这一行所在的数据页本来就在内存中，就直接返回给执行器。否则需要先从磁盘将 ID&#x3D;2 这一行所在的数据页读入内存，然后从页中取出行数据。 注意加载缓存的单位是 “page” 而非行。</li>
<li>修改行数据。</li>
<li>记录 undo-log 日志回滚链。</li>
<li>调用执行引擎更新内存数据。</li>
<li>发起写 redo log 日志，将修改操作写到 redo log buffer 中。日志属于 prepare 状态，此时就告诉执行器可以递交事务了。此时整个事务处于非 commit 状态。</li>
<li>执行器生成这个操作的 binlog，并把 binlog 写入内存。</li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成(可能日志未持久化到磁盘)。</li>
</ol>
<p>可以发现这里的 redo log 和 binlog 都是写入的内存而未进行持久化。如果此时断电内存丢失，那么数据就丢失了，这需要刷盘机制来保证数据不丢失。</p>
<h3 id="redo-log-刷盘"><a href="#redo-log-刷盘" class="headerlink" title="redo log 刷盘"></a>redo log 刷盘</h3><p>可以使用 <code>innodb_flush_log_at_trx_commit</code> 参数来控制 redo log 刷盘：</p>
<ul>
<li>0：每秒异步刷盘（可能会损失 1 秒的数据）</li>
<li>1：每 1 个事务刷盘</li>
<li>N：每 N 个事务刷盘</li>
</ul>
<p>建议设置为 1 ，保证数据安全。</p>
<br>

<h3 id="binlog-刷盘"><a href="#binlog-刷盘" class="headerlink" title="binlog 刷盘"></a>binlog 刷盘</h3><p>可以使用 <code>sync_binlog</code> 参数控制 binlog 刷盘：</p>
<ul>
<li>0：自动控制刷盘</li>
<li>1：每 1 个事务刷盘</li>
<li>N：每 N 个事务刷盘</li>
</ul>
<p>建议设置为 1 ，保证数据安全。</p>
<br>

<h3 id="持久化分析"><a href="#持久化分析" class="headerlink" title="持久化分析"></a>持久化分析</h3><ul>
<li><p>redo log 刷盘前系统崩溃：</p>
<p>数据丢失</p>
</li>
<li><p>redo log 刷盘后系统崩溃：</p>
<p>重启时会对 redo log 进行重放、重写内存中的数据页、重写 binlog</p>
</li>
</ul>
<p>可以看出，redo log 是系统的关键节点，相当于“决断点”，因此 redo log 写在 binlog 之前。如果先写 binlog，一旦写入则无法撤回，因为可能已经被传送到从库或备库。若此时系统断电而 redo log 还未写，就会导致从库或备库中写入了数据而主库由于 redo log 断电丢失而没有这些数据，造成主从数据不一致。</p>
<br>

<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><ul>
<li>MySQL 日志主要有 binlog、undo log、redo log</li>
<li>MySQL 实行日志优先的策略(WAL，Write Ahead Log)，日志刷盘数据就不会丢失</li>
<li>无法撤销的操作需要放在写 redo log 之后进行</li>
</ul>
<br>

<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="MySQL-锁的种类"><a href="#MySQL-锁的种类" class="headerlink" title="MySQL 锁的种类"></a>MySQL 锁的种类</h3><p>按照粒度来分，MySQL 锁可以分为：</p>
<ul>
<li>全局锁：锁住整个库，使整个库无法修改</li>
<li>表级锁：表级锁分为表锁（数据锁）和元数据锁</li>
<li>行锁：行锁会锁住数据行，分为共享锁和独占锁</li>
</ul>
<br>

<h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>当需要让整个库处于只读状态时，可以使用命令<code> Flush tables with read lock</code>(FTWRL)，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p>
<p>使用全局锁会导致所有的业务失效，因此谨慎使用。一般主要用途是保证备份的一致性，一般使用从库进行备份。</p>
<br>

<h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>可以使用命令 <code>lock tables XXX read/write</code> 锁住整张表。开销小加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发度最低。一般用在整表数据迁移的场景。在 InnoDB 中表锁是非常重量级的锁因此使用很少，在 MyISAM 中使用较多。</p>
<p>元数据锁(MetaData Lock)也是一种表锁，但它锁的是元数据。元数据是指表的结构、字段、数据类型、索引等。当事务访问数据时，会自动给表加 MDL 读锁。当事务修改元数据时，会自动给表加 MDL 写锁。</p>
<br>

<h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>MySQL 的行锁也分为读锁和写锁（共享锁&#x2F;排他锁、共享锁&#x2F;独占锁、S 锁&#x2F;X 锁）。</p>
<ul>
<li>读锁：别人可以读不能写</li>
<li>写锁：别人不能读和写（InnoDB MVCC 快照使得别人也能读）</li>
</ul>
<p>只有读锁和读锁之间能够兼容。</p>
<p>加锁后的数据更新操作：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/O6XwUf"><img src="https://s1.ax1x.com/2022/05/14/O6XwUf.png" alt="O6XwUf.png"></a></p>
<br>

<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><ul>
<li>锁是 MySQL 高效执行事务的必备基础</li>
<li>锁会引发很多的性能问题，可能造成等待和死锁</li>
<li>锁还会引发很多的功能问题，如脏读和不可重复读等</li>
</ul>
<br>

<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h3><ul>
<li>原子性（Atomicity）</li>
<li>一致性（Consistency）</li>
<li>隔离性（Isolation）</li>
<li>持久性（Durability）</li>
</ul>
<br>

<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>事务中的操作要么全部成功要么全部失败。</p>
<p>MySQL 的两阶段提交机制保证了事务的原子性。可以使用 undo log 来回滚事务的更改。</p>
<br>

<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>在事务开始和完成时数据都必须保持一致状态，也就是事务必须使数据库从一个一致性状态变换到另一个一致性状态。</p>
<p>MySQL 的锁和两阶段提交实现了事务的一致性。</p>
<br>

<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>事务不能被其他事务对数据的操作所影响，多个并发事务之间相互隔离。也就是说事务处理过程中的中间状态对外部是不可见的，一个事务的未递交修改对其他事务不可见。</p>
<p>MySQL 的锁和 undo log 实现了事务的隔离性。</p>
<br>

<h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>一个事务一旦被提交，它对数据库中数据的改变就是永久性的。</p>
<p>MySQL 的 redo log 实现了事务的持久性。</p>
<br>

<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OcpQUI"><img src="https://s1.ax1x.com/2022/05/14/OcpQUI.png" alt="OcpQUI.png"></a></p>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ul>
<li>读未提交（Read Uncommitted）</li>
<li>读提交（Read Committed）</li>
<li>可重复读（Repeatable Read）</li>
<li>串行化（Serializable）</li>
</ul>
<br>

<h3 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h3><p>读、写都不加锁，未隔离。因此会导致每次查询都会得到最新版本的数据（别人未提交的修改也会被读到）。</p>
<p>这种隔离级别性能最好，但相当于没有事务，因此很少采用。</p>
<br>

<h3 id="读提交"><a href="#读提交" class="headerlink" title="读提交"></a>读提交</h3><p>写数据时加写锁，提交时释放。一个事务会读取到另一个事务已提交的数据，但不会读取到未提交的数据。</p>
<p>读提交是 Oracle 默认的隔离级别。</p>
<br>

<h3 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h3><p>写数据时加写锁，提交时释放。读取数据时只会读取到本事务开始时的数据状态。因此就算有别的用户在本次事务中修改了数据，在本事务中读取到的同样是事务开始时的数据。</p>
<p>可重复读是 MySQL 默认的隔离级别。</p>
<br>

<h3 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h3><p>读加读锁、写加写锁，提交时释放。	对于一条数据，同时只能有一个事务进行写操作。</p>
<p>串行化事务的隔离性最高，性能最差，因此很少采用。</p>
<br>

<h2 id="MVCC-并发版本控制"><a href="#MVCC-并发版本控制" class="headerlink" title="MVCC 并发版本控制"></a>MVCC 并发版本控制</h2><h3 id="行记录的版本控制"><a href="#行记录的版本控制" class="headerlink" title="行记录的版本控制"></a>行记录的版本控制</h3><p>由于 undo log 的存在，MySQL 可以从最新版本推算之前的版本。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Oc3LI1"><img src="https://s1.ax1x.com/2022/05/14/Oc3LI1.png" alt="Oc3LI1.png"></a></p>
<h3 id="快照读（一致性非锁定读）"><a href="#快照读（一致性非锁定读）" class="headerlink" title="快照读（一致性非锁定读）"></a>快照读（一致性非锁定读）</h3><p>一致性的非锁定读是指 InnoDB 存储引擎通过行多版本控制（MVCC）的方式来读取当前数据库中的数据。</p>
<p>即若待读取的数据正在执行 DELETE 或 UPDATE 操作，那么读取操作不会阻塞等待锁的释放，而是读取该行的一个历史快照。</p>
<p>当事务需要读取正在被锁定的数据时，不会等待，而是去读取数据的一个历史版本，具体的实现方式是基于行数据的 undo log，undo log 主要用于事务的回滚，读取历史版本的数据无需上锁，因为历史数据是只读的（不会有事务修改历史数据）。</p>
<p>非锁定读机制大大提高了数据的并发性，InnoDB 默认支持非锁定的读。但在不同的事务隔离级别下，并非都采取相同一致性非锁定读：</p>
<ul>
<li>读已提交：根据每次 SELECT 时其他事务的提交情况 undo 到最新已提交的快照数据。</li>
<li>可重复读：根据事务开始时其他事务的提交情况 undo 到 begin 时已提交到数据。</li>
</ul>
<br>

<h3 id="当前读（一致性锁定读）"><a href="#当前读（一致性锁定读）" class="headerlink" title="当前读（一致性锁定读）"></a>当前读（一致性锁定读）</h3><p>在默认情况下，InnoDB 存储引擎对数据采用的是一致性非锁定读。但有些情况下为了保证数据逻辑的一致性，需要对 SELECT 的操作加锁。InnoDB 存储引擎对于 SELECT 语句支持两种一致性的锁定读（Locking Read）操作。</p>
<ol>
<li><p>SELECT … FOR UPDATE</p>
</li>
<li><p>SELECT … LOCK IN SHARE MODE</p>
</li>
</ol>
<p>其中 SELECT … FOR UPDATE 对读取的记录加一个写锁，其他事务不能对已锁定的行加任何锁。</p>
<p>而 SELECT … LOCK IN SHARE MODE 是对读取的记录加一个读锁，其他事物可以向被锁定的行加读锁，如果加写锁则会被阻塞。</p>
<br>

<h2 id="隔离问题"><a href="#隔离问题" class="headerlink" title="隔离问题"></a>隔离问题</h2><ul>
<li><p>脏读：读到了其他事务未提交的数据</p>
</li>
<li><p>不可重复读：同样的查询读到的数据内容不一样</p>
</li>
<li><p>幻读：同样的查询读到的数据条数不一样幻读</p>
<blockquote>
<p>某一次的 SELECT 操作得到的结果所表征的数据状态无法支撑后续的业务操作。更为具体一些：SELECT 某记录是否存在，不存在，准备插入此记录，但执行 INSERT 时发现此记录已存在，无法插入，此时就发生了幻读。</p>
</blockquote>
</li>
</ul>
<br>

<h3 id="MySQL-不同隔离级别的问题"><a href="#MySQL-不同隔离级别的问题" class="headerlink" title="MySQL 不同隔离级别的问题"></a>MySQL 不同隔离级别的问题</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Octets"><img src="https://s1.ax1x.com/2022/05/14/Octets.png" alt="Octets.png" style="zoom: 33%;" /></a></p>
<ul>
<li>读未提交无法解决脏读、不可重复读、幻读问题。</li>
<li>读提交可以解决脏读问题，不能解决不可重复读、幻读问题。</li>
<li>可重复读可以解决脏读、不可重复读问题，不能解决幻读问题。</li>
<li>串行化可以解决脏读、不可重复读、幻读问题。</li>
</ul>
<br>

<h3 id="如何解决幻读问题"><a href="#如何解决幻读问题" class="headerlink" title="如何解决幻读问题"></a>如何解决幻读问题</h3><p>MySQL 在可重复读级别时，通过 Next-Key Lock 部分解决了幻读问题。Next-Key Lock是行锁 + 间隙锁(Gap Lock)。</p>
<p>间隙锁锁的就是两个值之间的空隙。比如对如下表的数据，会产生三个间隙：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OcNRIJ"><img src="https://s1.ax1x.com/2022/05/14/OcNRIJ.png" alt="OcNRIJ.png" style="zoom:33%;" /></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OcUmQ0"><img src="https://s1.ax1x.com/2022/05/14/OcUmQ0.png" alt="OcUmQ0.png" style="zoom: 25%;" /></a></p>
<p>可重复读加锁时，不仅将给行加上了行锁还给行两边的间隙也加上了间隙锁。间隙锁部分读写，它不允许在间隙中修改数据(也可以认为是读锁)。这样在读取数据时其他事务就无法插入数据了，避免了幻读。</p>
<br>

<h3 id="Next-Key-Lock-的加锁逻辑"><a href="#Next-Key-Lock-的加锁逻辑" class="headerlink" title="Next-Key Lock 的加锁逻辑"></a>Next-Key Lock 的加锁逻辑</h3><p>Next-Key 是指一个间隙和它的下一个行记录。</p>
<p>使用以下 SQL 语句建表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `t3`(</span><br><span class="line">	`id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	`c` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	`d` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY(`id`),</span><br><span class="line">	KEY `c`(`c`)</span><br><span class="line">)ENGINE<span class="operator">=</span>INNODB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t3`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), (<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>), (<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>), (<span class="number">30</span>,<span class="number">30</span>,<span class="number">30</span>), (<span class="number">40</span>,<span class="number">40</span>,<span class="number">40</span>), (<span class="number">50</span>,<span class="number">50</span>,<span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p>此时考虑间隙的主键索引：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Oc0fvn"><img src="https://s1.ax1x.com/2022/05/14/Oc0fvn.png" alt="Oc0fvn.png"></a></p>
<h3 id="等值查询间隙锁"><a href="#等值查询间隙锁" class="headerlink" title="等值查询间隙锁"></a>等值查询间隙锁</h3><p>Tx A：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t3 <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">11</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>首先锁 (10, 20]，又因为等值查询最后一个扫描 20 不等于 11，所以不加行锁。</p>
<p>Tx B：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t3 <span class="keyword">value</span>(<span class="number">12</span>,<span class="number">12</span>,<span class="number">12</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t3 <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">20</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>可以发现 Tx B 插入数据时会被阻塞，但在 id &#x3D; 20 处不会，主键索引：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OcD6pQ"><img src="https://s1.ax1x.com/2022/05/14/OcD6pQ.png" alt="OcD6pQ.png"></a></p>
<br>

<h3 id="非唯一索引等值锁"><a href="#非唯一索引等值锁" class="headerlink" title="非唯一索引等值锁"></a>非唯一索引等值锁</h3><p>Tx A：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t3 <span class="keyword">where</span> c <span class="operator">=</span> <span class="number">10</span> lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure>

<p>只涉及辅助索引：首先锁 (0, 10]，向右扫描时锁 (10, 20]，又因为等值查询最后一个扫描 20 不等于 10，所以解除 20 的锁。</p>
<p>Tx B：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t3 <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">20</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t3 <span class="keyword">value</span>(<span class="number">12</span>,<span class="number">12</span>,<span class="number">12</span>);</span><br></pre></td></tr></table></figure>

<p>可以发现可以 Tx B 对 id &#x3D; 20 上写锁，但在插入数据时被阻塞，辅助索引 c：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OcsAxJ"><img src="https://s1.ax1x.com/2022/05/14/OcsAxJ.png" alt="OcsAxJ.png"></a></p>
<br>

<h3 id="主键索引范围锁"><a href="#主键索引范围锁" class="headerlink" title="主键索引范围锁"></a>主键索引范围锁</h3><p>Tx A：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t3 <span class="keyword">where</span> id <span class="keyword">between</span> <span class="number">20</span> <span class="keyword">and</span> <span class="number">30</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>首先等值查询 20，只锁行锁。然后向右扫描到 30，锁 (20, 30]。</p>
<p>Tx B：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t3 <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">20</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t3 <span class="keyword">value</span>(<span class="number">12</span>,<span class="number">12</span>,<span class="number">12</span>);</span><br></pre></td></tr></table></figure>

<p>可以发现 Tx B 对 id &#x3D; 20 上写锁被阻塞，但可以插入数据，主键索引：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OcyQwq"><img src="https://s1.ax1x.com/2022/05/14/OcyQwq.png" alt="OcyQwq.png"></a></p>
<br>

<h3 id="非唯一索引范围锁"><a href="#非唯一索引范围锁" class="headerlink" title="非唯一索引范围锁"></a>非唯一索引范围锁</h3><p>Tx A：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t3 <span class="keyword">where</span> c <span class="keyword">between</span> <span class="number">20</span> <span class="keyword">and</span> <span class="number">30</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>首先等值查询 20，不是唯一索引因此锁 (10, 20]，向右扫描到 30，锁 (20, 30]，继续向右扫描，锁 (30, 40)。</p>
<p>辅助索引 c：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Oc4wBF"><img src="https://s1.ax1x.com/2022/05/14/Oc4wBF.png" alt="Oc4wBF.png"></a></p>
<br>

<h3 id="非索引字段查询"><a href="#非索引字段查询" class="headerlink" title="非索引字段查询"></a>非索引字段查询</h3><p>Tx A：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t3 <span class="keyword">where</span> d <span class="operator">=</span> <span class="number">20</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>由于该字段没有索引，因此使用主键索引扫描，锁全表。</p>
<p>主键索引：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Oc56aQ"><img src="https://s1.ax1x.com/2022/05/14/Oc56aQ.png" alt="Oc56aQ.png"></a></p>
<br>

<h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Next-Key Lock 的目的是在可重复读的隔离级别下部分预防幻读，但它规则复杂。</li>
<li>在当前读时，查询没有索引的字段会导致效率低下。</li>
</ul>
<br>

<h2 id="MySQL-的“垃圾回收”"><a href="#MySQL-的“垃圾回收”" class="headerlink" title="MySQL 的“垃圾回收”"></a>MySQL 的“垃圾回收”</h2><p>MySQL 没有 Java 中那么强大的 GC，当 MySQL 进行数据清理时，数据库会卡顿几秒同时磁盘 IO 很高，这是 MySQL 的“垃圾回收”正在刷脏页。</p>
<h3 id="MySQL-脏页的产生"><a href="#MySQL-脏页的产生" class="headerlink" title="MySQL 脏页的产生"></a>MySQL 脏页的产生</h3><p>当更新数据时，只是更新了内存中的而没有更新磁盘。当内存数据页跟磁盘数据页内容不一致时则称这个内存页为“脏页”。</p>
<br>

<h3 id="刷脏"><a href="#刷脏" class="headerlink" title="刷脏"></a>刷脏</h3><p>刷脏就是将内存中的数据页持久化到磁盘。同时会删除与此页相关的 redo log 并推进 check point。</p>
<p>刷脏的原因：</p>
<ul>
<li>内存中的脏页太多，导致内存不足(OOM)。</li>
<li>redo log 已经写满了因此需要推进 check point 进行持久化。</li>
<li>系统空闲提前刷脏，预防上述情况。</li>
<li>MySQL 关闭前保存数据。</li>
</ul>
<p>前两种情况会产生性能问题而导致 MySQL 卡住，因此需要优化。</p>
<br>

<h3 id="改善刷脏性能"><a href="#改善刷脏性能" class="headerlink" title="改善刷脏性能"></a>改善刷脏性能</h3><p>改善刷脏性能主要是避免被迫刷脏：</p>
<ul>
<li>正确告知 InnoDB 服务器的磁盘性能</li>
<li>合理配置脏页比例上限</li>
<li>控制“顺便刷脏”策略</li>
</ul>
<h4 id="服务器-IO-配置"><a href="#服务器-IO-配置" class="headerlink" title="服务器 IO 配置"></a>服务器 IO 配置</h4><p>可以配置 <code>innodb_io_capacity</code> 参数来告知服务器的硬盘性能，它能决定 InnoDB 刷脏的速度。</p>
<p>常见的 IOPS：</p>
<ul>
<li>7200 RPM SATA，70 IOPS</li>
<li>10000 RPM FC， 125 IOPS</li>
<li>SSD SATA，3000 - 40000 IOPS</li>
</ul>
<p>可以使用 fio 工具测试硬盘的 IO 性能。</p>
<h4 id="脏页比例上限的配置"><a href="#脏页比例上限的配置" class="headerlink" title="脏页比例上限的配置"></a>脏页比例上限的配置</h4><p>可以配置 <code>innodb_max_dirty_pages_pct</code> 参数来控制脏页比例，当脏页比例接近此值时会加速刷脏页。</p>
<h4 id="控制“顺便刷脏”策略"><a href="#控制“顺便刷脏”策略" class="headerlink" title="控制“顺便刷脏”策略"></a>控制“顺便刷脏”策略</h4><p>可以配置 <code>innodb_flush_neighbors</code> 来开启。对于传统机械硬盘来说，连续的写性能更好，可以尽量连续地刷脏页。但对于 SSD 此项会影响 SSD 的随机读写的性能，需要关闭。</p>
<br>

<h2 id="长事务的危害"><a href="#长事务的危害" class="headerlink" title="长事务的危害"></a>长事务的危害</h2><h3 id="锁无法释放"><a href="#锁无法释放" class="headerlink" title="锁无法释放"></a>锁无法释放</h3><p>长事务占用锁资源很长，会导致行级锁长时间无法释放而导致其他事务的长时间等待。同时也容易导致产生死锁的问题。另外，也有可能使 MDL 元数据锁 Hold 住大量事务而造成 MySQL 崩溃。</p>
<br>

<h3 id="行级锁长时间无法释放"><a href="#行级锁长时间无法释放" class="headerlink" title="行级锁长时间无法释放"></a>行级锁长时间无法释放</h3><p>当前读会对数据进行加锁操作，在事务提交前不会释放锁。因此其他事务更新相同数据时就会等待，这样会造成更新的性能变差。</p>
<p>解决方案：</p>
<ul>
<li>调整 <code>innodb_lock_wait_timeout</code> 参数，默认为 50 秒，即等待时间超过 50 秒还未获得锁则当前语句报错。如果等待时间过长可以适当缩短此参数。若设置的等待时间过短则会造成异常事务过多的问题。</li>
</ul>
<br>

<h3 id="造成死锁"><a href="#造成死锁" class="headerlink" title="造成死锁"></a>造成死锁</h3><p>死锁是指两个事务都依赖于对方所占有的锁而双方都不释放锁。长事务的锁长时间不释放很容易与其他事务产生死锁。</p>
<p>死锁的产生：</p>
<p>Tx A</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t3 <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>Tx B</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t3 <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">20</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>Tx A</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t3 <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">20</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>Tx B</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t3 <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>这样事务 A 和事务 B 都拥有对方需要的锁而双方都不退让释放锁，一直互相等待对方释放锁而造成死锁现象。</p>
<p>解决方案：</p>
<ul>
<li>主动死锁检测：<code>innodb_deadlock_detect</code> 。但发现死锁时会回滚代价比较小的事务。</li>
</ul>
<p>因此在执行上面的 SQL 语句时，MySQL 会自动将代价更小的 Tx B 回滚并报错，让 Tx A 继续执行完。</p>
<p>但这种主动死锁检测的方案在事务量非常大时会一个个检测是否会发生死锁而导致 MySQL 的性能问题，当发现 MySQL 执行效率很低时可以检查是否是该机制导致的，若是则可以关闭主动死锁检测而使用调整等待超时参数和优化 SQL 业务逻辑的方案。</p>
<br>

<h3 id="MDL-锁导致-MySQL-崩溃"><a href="#MDL-锁导致-MySQL-崩溃" class="headerlink" title="MDL 锁导致 MySQL 崩溃"></a>MDL 锁导致 MySQL 崩溃</h3><p>在事务访问数据时会自动给表加 MDL 读锁，在事务修改元数据时会自动给表加 MDL 写锁。当遇到锁不兼容的时候，申请 MDL 锁的事务会形成一个队列。</p>
<p>申请 MDL 的等待队列容易出现问题：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OgeTmt"><img src="https://s1.ax1x.com/2022/05/15/OgeTmt.png" alt="OgeTmt.png"></a></p>
<p>当 Tx A 申请完 MDL 读锁后，Tx B 此时想要申请 MDL 写锁就会被阻塞后加入等待队列。此时若有 Tx C 和 Tx D 也需要申请 MDL 读锁，虽然 Tx A 的读锁之间不互斥，但由于等待队列中已经有 Tx B 在等待申请 MDL 写锁了，队列中在 Tx B 之后的 Tx C 和 Tx D 也无法获取到 MDL 读锁。</p>
<p>解决方案：</p>
<ul>
<li>在 Alter Table 之前查看是否还有长事务未提交。查看长事务：<code>information_schema</code> 库 <code>innodb_trx</code> 表。</li>
</ul>
<br>

<h3 id="查看影响性能的锁"><a href="#查看影响性能的锁" class="headerlink" title="查看影响性能的锁"></a>查看影响性能的锁</h3><ul>
<li>查看长事务：<code>information_schema</code> 库 <code>innodb_trx</code> 表。</li>
<li>查看锁：<code>information_schema</code> 库 <code>innodb_locks</code> 表。</li>
<li>查看阻塞的事务：<code>information_schema</code> 库 <code>innodb_locks_waits</code> 表。</li>
</ul>
<p>在 MySQL 8.0 中：</p>
<ul>
<li>查看锁：<code>performance_schema</code> 库 <code>data_locks</code> 表。</li>
<li>查看锁等待：<code>performance_schema</code> 库 <code>data_locks_waits</code> 表。</li>
<li>查看 MDL 锁：<code>performance_schema</code> 库 <code>metadata_locks</code> 表。</li>
</ul>
<br>

<h3 id="业务上的优化"><a href="#业务上的优化" class="headerlink" title="业务上的优化"></a>业务上的优化</h3><ul>
<li>控制长事务，在没有必要的情况下不开启事务。</li>
<li>数据修改（当前读）的操作尽量后移放在事务的后部，降低锁的时间。</li>
</ul>
<br>

<h2 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h2><h3 id="动起来的数据库的问题"><a href="#动起来的数据库的问题" class="headerlink" title="动起来的数据库的问题"></a>动起来的数据库的问题</h3><ul>
<li>产生日志文件</li>
<li>事务之间因为锁而互相影响</li>
<li>事务之间查询到的数据不一致</li>
</ul>
<h3 id="MySQL-日志体系-1"><a href="#MySQL-日志体系-1" class="headerlink" title="MySQL 日志体系"></a>MySQL 日志体系</h3><ul>
<li>MySQL 日志主要有 binlog、undo log、redo log</li>
<li>MySQL 实行日志优先策略，日志刷盘后数据就不会丢失</li>
</ul>
<h3 id="MySQL-的锁"><a href="#MySQL-的锁" class="headerlink" title="MySQL 的锁"></a>MySQL 的锁</h3><ul>
<li>按照粒度分，MySQL 锁可以分为全局锁、表级锁、行锁</li>
<li>全局锁会锁住所有表，整个库无法修改，主要同于数据库备份</li>
<li>表级锁分为表锁(数据锁)和元数据锁</li>
<li>行锁会锁住数据行，分为共享锁和独占锁</li>
</ul>
<h3 id="事务与-MVCC"><a href="#事务与-MVCC" class="headerlink" title="事务与 MVCC"></a>事务与 MVCC</h3><ul>
<li>InnoDB 使用 undo log 实现了行记录历史的查询</li>
<li>快照读不需要加行锁，属于乐观锁的一种思路</li>
<li>当前读为了并发控制而需要加锁</li>
<li>Next-Key 锁解决了可重复读下的幻读问题</li>
</ul>
<h3 id="MySQL-的刷脏策略"><a href="#MySQL-的刷脏策略" class="headerlink" title="MySQL 的刷脏策略"></a>MySQL 的刷脏策略</h3><ul>
<li>刷脏可能会导致 MySQL 卡住，造成性能问题</li>
<li>通过告知服务器 IO 性能，可以控制合理刷脏 IO</li>
<li>合理的脏页比例上限可以改善刷脏性能，建议保持默认</li>
<li>“顺便刷脏”策略功能需要在 SSD 下关闭</li>
</ul>
<h3 id="长事务的危害-1"><a href="#长事务的危害-1" class="headerlink" title="长事务的危害"></a>长事务的危害</h3><ul>
<li>长事务可能会造成行锁(死锁)、MDL 锁等待</li>
<li>可以通过参数调整，降低锁影响</li>
<li>可以通过系统表识别长事务和锁</li>
<li>业务上尽量将加锁的操作后移，降低锁时间</li>
</ul>
<br>

<h1 id="ORM-框架原理"><a href="#ORM-框架原理" class="headerlink" title="ORM 框架原理"></a>ORM 框架原理</h1><h2 id="什么是-ORM-框架"><a href="#什么是-ORM-框架" class="headerlink" title="什么是 ORM 框架"></a>什么是 ORM 框架</h2><p>ORM 框架就是 Object Relational Mapping，即对象与关系型数据库的映射关系。</p>
<p>著名的 ORM 框架有：</p>
<ul>
<li>Java：MyBatis、Hibernate</li>
<li>Python：Django、SQLALchemy</li>
<li>GO：GORM</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/O2KyQg"><img src="https://s1.ax1x.com/2022/05/15/O2KyQg.png" alt="O2KyQg.png"></a></p>
<br>

<h3 id="ORM-框架的意义"><a href="#ORM-框架的意义" class="headerlink" title="ORM 框架的意义"></a>ORM 框架的意义</h3><ul>
<li>将数据库操作与程序编码解耦，提高开发效率</li>
<li>自动拼装生成 SQL 语句，避免 SQL 注入风险</li>
<li>自动管理数据库连接、自动重试、自动回滚等操作</li>
<li>自动管理事务</li>
</ul>
<p>因此，ORM 框架可以大大降低程序员的代码开发工作量，还可以使代码更加安全、更易维护。</p>
<br>

<h2 id="ORM-框架是如何设计的"><a href="#ORM-框架是如何设计的" class="headerlink" title="ORM 框架是如何设计的"></a>ORM 框架是如何设计的</h2><h3 id="ORM-框架-架构层次"><a href="#ORM-框架-架构层次" class="headerlink" title="ORM 框架 - 架构层次"></a>ORM 框架 - 架构层次</h3><ul>
<li>接口层：向上支持程序调用</li>
<li>处理层：参数映射 -&gt; SQL 生成 -&gt; SQL 执行 -&gt; 结果处理</li>
<li>支撑层：事务管理、连接池管理</li>
<li>连接层：数据库连接驱动</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/O2QjxO"><img src="https://s1.ax1x.com/2022/05/15/O2QjxO.png" alt="O2QjxO.png"></a></p>
<p>可以看出 ORM 框架体现了软件架构设计的经典模式，如分层架构、管道-过滤器、微核架构。</p>
<br>

<h2 id="ORM-框架常见问题"><a href="#ORM-框架常见问题" class="headerlink" title="ORM 框架常见问题"></a>ORM 框架常见问题</h2><h3 id="ORM-与-DAO-的关系"><a href="#ORM-与-DAO-的关系" class="headerlink" title="ORM 与 DAO 的关系"></a>ORM 与 DAO 的关系</h3><p>DAO(Data Access Object) 是 ORM 框架的接口层，在 Java 中比较常见，一般是 ORM 生成的。</p>
<p>DAO 并不等于 ORM 框架，它是 ORM 框架的一部分。</p>
<br>

<h3 id="定位出问题的-SQL"><a href="#定位出问题的-SQL" class="headerlink" title="定位出问题的 SQL"></a>定位出问题的 SQL</h3><p>在 ORM 框架的支持下，很多 SQL 语句都不是开发人员或 DBA 写的，而开发人员更加注重业务逻辑，经常会忽视 SQL 本身的性能。</p>
<p>因此，当 SQL 语句出问题时定位 SQL：</p>
<ul>
<li>业务应用：根据代码推断、查看相关日志</li>
<li>数据库：查看慢日志</li>
<li>网络：监听数据库端口，解析 TCP 报文</li>
</ul>
<br>

<h1 id="怎样给数据库上保险"><a href="#怎样给数据库上保险" class="headerlink" title="怎样给数据库上保险"></a>怎样给数据库上保险</h1><h2 id="数据库备份的种类"><a href="#数据库备份的种类" class="headerlink" title="数据库备份的种类"></a>数据库备份的种类</h2><h3 id="备份的分类维度"><a href="#备份的分类维度" class="headerlink" title="备份的分类维度"></a>备份的分类维度</h3><ul>
<li>备份时数据库的状态</li>
<li>备份文件的格式</li>
<li>备份的内容</li>
</ul>
<br>

<h3 id="备份时数据库的状态"><a href="#备份时数据库的状态" class="headerlink" title="备份时数据库的状态"></a>备份时数据库的状态</h3><ul>
<li>Hot Backup(热备)：正常运行中直接备份，对业务侵入最小。</li>
<li>Cold Backup(冷备)：完全停止后备份，对业务侵入最大。</li>
<li>Warm Backup(温备)：数据库只读。</li>
</ul>
<br>

<h3 id="备份文件的格式"><a href="#备份文件的格式" class="headerlink" title="备份文件的格式"></a>备份文件的格式</h3><ul>
<li>逻辑备份：输出文本或 SQL 语句</li>
<li>物理备份(裸文件)：备份数据库底层文件</li>
</ul>
<br>

<h3 id="备份的内容"><a href="#备份的内容" class="headerlink" title="备份的内容"></a>备份的内容</h3><ul>
<li>完全备份：备份完整数据</li>
<li>增量备份：备份数据差异</li>
<li>日志备份：备份 Binlog 的内容</li>
</ul>
<br>

<h3 id="备份工具"><a href="#备份工具" class="headerlink" title="备份工具"></a>备份工具</h3><ul>
<li>MySQLDump：逻辑、热、全量备份</li>
<li>XtraBackup：物理、热、全量+增量备份</li>
</ul>
<br>

<h2 id="使用-OUTFILE-命令备份"><a href="#使用-OUTFILE-命令备份" class="headerlink" title="使用 OUTFILE 命令备份"></a>使用 OUTFILE 命令备份</h2><h3 id="OUTFILE"><a href="#OUTFILE" class="headerlink" title="OUTFILE"></a>OUTFILE</h3><p>OUTFILE 是 MySQL 原生的 SQL 指令。它是最原始的逻辑备份方式，备份的功能和效果取决于如何写 SQL 语句。</p>
<br>

<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>首先查询 MySQL 的导出路径：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%secure%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>使用 <code>into outfile</code> 指令将查询结果导出至文件：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">into</span> outfile <span class="string">&#x27;/var/lib/mysql-files/out_file_test1&#x27;</span> <span class="keyword">from</span> t1;</span><br></pre></td></tr></table></figure>

<p>查看文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/lib/mysql-files/out_file_test1</span><br><span class="line">4			6</span><br><span class="line">6			3</span><br><span class="line">7			1</span><br></pre></td></tr></table></figure>

<br>

<h3 id="OUTFILE-注意事项"><a href="#OUTFILE-注意事项" class="headerlink" title="OUTFILE 注意事项"></a>OUTFILE 注意事项</h3><p>在 InnoDB 事务下可以做到一致性视图。</p>
<p>如果需要修改导出数据的形式：</p>
<ul>
<li>修改分隔符</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">into</span> outfile <span class="string">&#x27;/var/lib/mysql-files/out_file_test1&#x27;</span> fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> <span class="keyword">from</span> t1;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改换行符</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">into</span> outfile <span class="string">&#x27;/var/lib/mysql-files/out_file_test1&#x27;</span> lines terminated <span class="keyword">by</span> <span class="string">&#x27;.&#x27;</span> <span class="keyword">from</span> t1;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="OUTFILE-的缺陷"><a href="#OUTFILE-的缺陷" class="headerlink" title="OUTFILE 的缺陷"></a>OUTFILE 的缺陷</h3><ul>
<li>OUTFILE 输出的文本比较简略</li>
<li>很难使用 OUTFILE 输出的文本还原数据库</li>
</ul>
<p>现在往往只使用 OUTFILE 来导出数据。</p>
<br>

<h3 id="改进-OUTFILE"><a href="#改进-OUTFILE" class="headerlink" title="改进 OUTFILE"></a>改进 OUTFILE</h3><ul>
<li>自动发 SELECT 语句，不需要手动发送</li>
<li>自动开启事务</li>
<li>输出 INSERT 语句，可以用来直接还原</li>
</ul>
<p>MySQLDump 就实现了这些功能。</p>
<br>

<h2 id="使用-MySQLDump-备份"><a href="#使用-MySQLDump-备份" class="headerlink" title="使用 MySQLDump 备份"></a>使用 MySQLDump 备份</h2><p>MySQLDump 是一个 MySQL 自带的非常常用的 MySQL 逻辑备份工具。它输出的备份内容为 SQL 语句，平衡了阅读和还原，而且 SQL 语句占用空间较小。</p>
<h3 id="MySQLDump-原理"><a href="#MySQLDump-原理" class="headerlink" title="MySQLDump 原理"></a>MySQLDump 原理</h3><p>MySQLDump 使用以下语句对数据进行备份：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SQL_NO_CACHE <span class="keyword">FROM</span> <span class="string">&#x27;t&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><code>SQL_NO_CACHE</code> 查询出的数据不会进入 SQL 缓存。这是因为使用 MySQLDump 备份数据时一般都是使用全量备份，查出的数据会影响缓存的性能，占用缓存空间。</p>
<br>

<h3 id="MySQLDump-使用方法"><a href="#MySQLDump-使用方法" class="headerlink" title="MySQLDump 使用方法"></a>MySQLDump 使用方法</h3><p>可以使用以下语句对数据进行备份：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p123456 <span class="comment">--databases d1 --single-transaction &gt; test.sql</span></span><br></pre></td></tr></table></figure>

<p>这样直接执行导出的 sql 文件即可进行还原：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source test.sql</span><br></pre></td></tr></table></figure>

<br>

<h3 id="MySQLDump-注意事项"><a href="#MySQLDump-注意事项" class="headerlink" title="MySQLDump 注意事项"></a>MySQLDump 注意事项</h3><ul>
<li><code>--single-transaction</code>：在 RR 级别下进行（InnoDB）</li>
<li><code>--lock-all-tables</code>：使用 FTWRL 锁所有表（MyISAM）</li>
<li><code>--lock-tables</code>：使用 Read Lock 锁当前库的表（MyISAM）</li>
<li><code>--all-databases</code>：备份所有库</li>
</ul>
<br>

<h3 id="MySQLDump-的缺点"><a href="#MySQLDump-的缺点" class="headerlink" title="MySQLDump 的缺点"></a>MySQLDump 的缺点</h3><ul>
<li>导出逻辑数据，备份较慢</li>
<li>还原需要执行 SQL 语句，速度较慢</li>
</ul>
<br>

<h2 id="使用-MySQLDump-增量备份"><a href="#使用-MySQLDump-增量备份" class="headerlink" title="使用 MySQLDump 增量备份"></a>使用 MySQLDump 增量备份</h2><h3 id="MySQLDump-增量备份思路"><a href="#MySQLDump-增量备份思路" class="headerlink" title="MySQLDump 增量备份思路"></a>MySQLDump 增量备份思路</h3><p>MySQLDump 无法进行增量备份。 Binlog 记录了 MySQL 数据的变化，因此可以在 MySQLDump 全量备份之后使用 Binlog 作为增量而实现增量备份。</p>
<p>由于 Binlog 日志文件写到一定时候会创建一个新的日志文件接着写：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mysql</span>-bin.<span class="number">000001</span></span><br><span class="line"><span class="attribute">mysql</span>-bin.<span class="number">000002</span></span><br><span class="line"><span class="attribute">mysql</span>-bin.<span class="number">000003</span></span><br></pre></td></tr></table></figure>

<p>在 MySQLDump 进行全量备份时使用到了 3 号 Binlog 文件，全量备份完成后就更换下一个 Binlog 文件，这样在 3 号 Binlog 文件之后就全部都记录的是增量数据了。从 0 还原时，采用全量还原 + Binlog 还原。</p>
<br>

<h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><ol>
<li>MySQLDump 使用以下语句对数据进行全量备份：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p123456 <span class="comment">--databases d1 --single-transaction --flush-logs --master-data=2 &gt; test.sql</span></span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>--flush-logs</code>：开启备份后切换 Binlog 文件</li>
<li><code>--master-data=2</code>：以注释形式记录切换后的 Binlog 文件名</li>
</ul>
<ol start="2">
<li>Binlog 增量备份</li>
</ol>
<p>需要增量备份时切换 Binlog 文件将所有新增的 Binlog 文件备份：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin <span class="operator">-</span>uroot <span class="operator">-</span>p123456 flush<span class="operator">-</span>logs</span><br></pre></td></tr></table></figure>

<p>因为若全量备份完后切换到的 Binlog 文件编号为 4，此时若直接使用 4 号文件进行增量备份可能会导致该日志文件还没有写完整就被用于增量备份了。因此在进行增量备份之前需要切换 Binlog 文件(5 号)。这样，4 号文件中就记录的是全量备份之后到本次增量备份时这个区间内的增量，5 号文件从本次增量备份后开始写。</p>
<ol start="3">
<li>还原</li>
</ol>
<p>首先还原旧的全量备份：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source test.sql</span><br></pre></td></tr></table></figure>

<p>然后将 Binlog 增量还原至数据库：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog MYSQL<span class="operator">-</span>bin<span class="number">.000004</span> MYSQL<span class="operator">-</span>bin<span class="number">.000005</span>... <span class="operator">|</span> mysql <span class="operator">-</span>uroot <span class="operator">-</span>p123456</span><br></pre></td></tr></table></figure>

<br>

<h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><ul>
<li>MySQLDump + Binlog 可以有效地对数据进行全量 + 增量备份。</li>
<li>两个组件各司其职，是工程实践中的经典做法。</li>
<li>理论上来说，可以将数据库恢复至 Binlog 的任意时刻。</li>
<li>但这种办法操作起来十分复杂。</li>
</ul>
<br>

<h2 id="使用-XtraBackup-物理备份"><a href="#使用-XtraBackup-物理备份" class="headerlink" title="使用 XtraBackup 物理备份"></a>使用 XtraBackup 物理备份</h2><h3 id="为什么要使用物理备份"><a href="#为什么要使用物理备份" class="headerlink" title="为什么要使用物理备份"></a>为什么要使用物理备份</h3><ul>
<li>直接备份 InnoDB 底层数据文件</li>
<li>导出不需要转换，速度快</li>
<li>工作时对数据库的压力较小</li>
<li>更容易实现增量备份</li>
</ul>
<br>

<h3 id="直接拷贝裸文件的问题"><a href="#直接拷贝裸文件的问题" class="headerlink" title="直接拷贝裸文件的问题"></a>直接拷贝裸文件的问题</h3><ul>
<li>要同时备份 frm 文件、ibd 文件、binlog 文件、redo log 文件等。而数据库在此时不是一成不变的，容易导致拷贝的文件与实际不同的情况。</li>
<li>若使用冷备份则十分影响业务。</li>
<li>在不同版本的数据库和操作系统上还原可能有兼容问题。</li>
</ul>
<br>

<h3 id="实现-物理-热-全量-备份"><a href="#实现-物理-热-全量-备份" class="headerlink" title="实现 物理+热+全量 备份"></a>实现 物理+热+全量 备份</h3><p>利用 redo log 备份 ibd 文件 + 备份期间变化的 redo log。</p>
<ol>
<li>启动 redo log 线程监听，开始收集从此起变化的 redo log</li>
<li>拷贝 ibd 文件</li>
<li>停止收集 redo log</li>
<li>加 FTWRL 锁拷贝元数据 frm 文件（温备）</li>
</ol>
<br>

<h3 id="实现-物理-热-增量-备份"><a href="#实现-物理-热-增量-备份" class="headerlink" title="实现 物理+热+增量 备份"></a>实现 物理+热+增量 备份</h3><p>根据每个页的 LSN 号确定变化的页，备份从上次全量备份之后产生变化的页。</p>
<br>

<h3 id="实现物理还原"><a href="#实现物理还原" class="headerlink" title="实现物理还原"></a>实现物理还原</h3><p>mysqld crash 奔溃恢复流程相似。</p>
<p>还原 ibd 文件，重放 redo log 就可以实现物理还原。</p>
<br>

<h3 id="ibbackup"><a href="#ibbackup" class="headerlink" title="ibbackup"></a>ibbackup</h3><p>MySQL Enterprise Backup，InnoDB 官方出品。它实现了上述的功能，性能优秀。</p>
<h3 id="XtraBackup"><a href="#XtraBackup" class="headerlink" title="XtraBackup"></a>XtraBackup</h3><p>Percona 公司开发的开源版本，实现 ibbackup 的所有功能。</p>
<ul>
<li>XtraBackup 8.0 - MySQL 8.0</li>
<li>XtraBackup 2.4 - MySQL 5.1，5.5，5.6，5.7</li>
</ul>
<p>下载</p>
<p><a target="_blank" rel="noopener" href="https://www.percona.com/downloads/Percona-XtraBackup-LATEST/#">https://www.percona.com/downloads/Percona-XtraBackup-LATEST/#</a></p>
<p>安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh --nodeps --force percona-xtrabackup-24-2.4.22-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>

<br>

<h3 id="XtraBackup-使用方法"><a href="#XtraBackup-使用方法" class="headerlink" title="XtraBackup 使用方法"></a>XtraBackup 使用方法</h3><p>全量备份：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bakdir/ 为需要存放备份文件的位置</span></span><br><span class="line">innobackupex --user=root --password=123456 bakdir/</span><br></pre></td></tr></table></figure>

<p>数据还原：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innobackupex --copy-back bakdir/XXXX-XX-XX/</span><br></pre></td></tr></table></figure>

<p>增量备份：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一个bakdir/为输出路径，第二个basedir为增量路径</span></span><br><span class="line">innobackupex --user=root --password=123456 --increamental bakdir/ --increamental-basedir=<span class="string">&#x27;/bakdir/XXXX-XX-XX/&#x27;</span></span><br></pre></td></tr></table></figure>

<p>增量备份合并至全量备份：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innobackupex --apply-log bakdir/XXXX-XX-XX/ --incremental-dir=bakdir/YYYY-YY-YY/</span><br></pre></td></tr></table></figure>

<br>

<h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><ul>
<li>物理备份是一种高效的备份方式</li>
<li>XtraBackup 采用了备份 ibd + 备份期间 redo log 方式</li>
<li>XtraBackup 是最常用的 MySQL 物理备份工具</li>
<li>物理备份的缺点是备份文件无法直接阅读</li>
</ul>
<br>

<h2 id="防患于未然"><a href="#防患于未然" class="headerlink" title="防患于未然"></a>防患于未然</h2><h3 id="权限隔离"><a href="#权限隔离" class="headerlink" title="权限隔离"></a>权限隔离</h3><ul>
<li>给业务分配的账号只给 DML 权限</li>
<li>开发人员使用只读账号</li>
<li>DBA 平时使用时只用只读账号需要特殊操作时切换账号</li>
</ul>
<br>

<h3 id="SQL-审计"><a href="#SQL-审计" class="headerlink" title="SQL 审计"></a>SQL 审计</h3><ul>
<li>DBA 在开发环境审计即将上线的 SQL 语句</li>
<li>开发人员修改在线数据，提交交给 DBA 执行</li>
<li>Inception 自动审核工具</li>
</ul>
<br>

<h3 id="伪删表"><a href="#伪删表" class="headerlink" title="伪删表"></a>伪删表</h3><ul>
<li>删表之前修改表名，观察业务是否受影响</li>
<li>不直接删表，给表加特殊后缀表示不使用此表</li>
</ul>
<br>

<h3 id="完善流程"><a href="#完善流程" class="headerlink" title="完善流程"></a>完善流程</h3><ul>
<li>上线之前备份数据</li>
<li>准备生产环境事故预案</li>
</ul>
<br>

<h1 id="如何实现数据冗余"><a href="#如何实现数据冗余" class="headerlink" title="如何实现数据冗余"></a>如何实现数据冗余</h1><h2 id="三高架构之路"><a href="#三高架构之路" class="headerlink" title="三高架构之路"></a>三高架构之路</h2><h3 id="什么是三高"><a href="#什么是三高" class="headerlink" title="什么是三高"></a>什么是三高</h3><ul>
<li>高并发：同时处理的事务数多</li>
<li>高性能：事务&#x2F;SQL 的执行速度高</li>
<li>高可用：系统可用时间高</li>
</ul>
<br>

<h3 id="实现三高"><a href="#实现三高" class="headerlink" title="实现三高"></a>实现三高</h3><p>实现三高的手段有：</p>
<ul>
<li>复制<ul>
<li>目的：数据冗余</li>
<li>手段：Binlog 传送</li>
<li>收获：并发量提升，可用性提升</li>
<li>问题：占用更多的硬件资源</li>
</ul>
</li>
<li>扩展<ul>
<li>目的：扩展数据库容量</li>
<li>手段：数据库的分库分表</li>
<li>收获：性能和并发量的提升</li>
<li>问题：可能降低可用性</li>
</ul>
</li>
<li>切换<ul>
<li>目的：提高可用性</li>
<li>手段：主从身份的切换</li>
<li>收获：并发量的提升</li>
<li>问题：丢失切换时期的数据</li>
</ul>
</li>
</ul>
<p>实现三高：</p>
<ul>
<li>高并发：通过复制和扩展将数据分散至多节点</li>
<li>高性能：复制提升速度，扩展提升容量</li>
<li>高可用：节点间身份切换保证随时可用</li>
</ul>
<br>

<h2 id="复制的原理和类型"><a href="#复制的原理和类型" class="headerlink" title="复制的原理和类型"></a>复制的原理和类型</h2><h3 id="复制的基本原理"><a href="#复制的基本原理" class="headerlink" title="复制的基本原理"></a>复制的基本原理</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OWWgBT"><img src="https://s1.ax1x.com/2022/05/16/OWWgBT.png" alt="OWWgBT.png"></a></p>
<p>MySQL 使用 3 个线程来执行复制功能（1 个在主服务器上，另 2 个在从服务器上）。当发出 START SLAVE 时，从服务器创建一个 I&#x2F;O 线程，以连接主服务器并让它发送记录在其二进制日志 Binlog 中的语句。</p>
<p>主服务器创建一个 dump thread 线程将 Binlog 中的内容读取并发送到从服务器的 I&#x2F;O 线程。从服务器 I&#x2F;O 线程读取主服务器 dump thread 发送的内容并将该数据拷贝到从服务器数据目录中的本地文件中，即中继日志 relay log。</p>
<p>第 3 个线程是从服务器的 SQL 线程，是从服务器创建用于读取中继日志并执行日志中包含的更新。</p>
<br>

<h3 id="复制的类型"><a href="#复制的类型" class="headerlink" title="复制的类型"></a>复制的类型</h3><p>根据复制同步的类型可以分为：</p>
<ul>
<li>异步复制(Asynchronous Replication)</li>
<li>半同步复制(Semisynchronous Replication)</li>
<li>组复制(Group Replication)</li>
</ul>
<h3 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h3><p>MYSQL 默认的复制方式。主库写入 Binlog 日志后提价完成即可成功返回客户端，无须等待 Binlog 日志传递给从库的过程。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OWfXLV"><img src="https://s1.ax1x.com/2022/05/16/OWfXLV.png" alt="OWfXLV.png"></a></p>
<p>异步复制原理简单，对网络延迟要求较小。但主从库数据有延迟、不能保证日志被传送到了从库，可能会造成数据丢失。</p>
<br>

<h3 id="半同步复制"><a href="#半同步复制" class="headerlink" title="半同步复制"></a>半同步复制</h3><p>主库写入 Binlog 日志后需要等待从库生成自己的 relay log 后发送 ACK 给主库才能提交。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OWhaWj"><img src="https://s1.ax1x.com/2022/05/16/OWhaWj.png" alt="OWhaWj.png"></a></p>
<p>半同步复制原理简单，可以保证日志被传送到了从库，不易丢失数据。但对网络延迟有一定要求，且若某从库一直未发送 ACK 或 ACK 发送了但网络延迟太高则会导致主库一直等待从库的 ACK 而无法提交。因此可以配置参数 <code>rpl_semi_sync_master_timeout</code> 来调整超时时间，当超时时则会自动退化成异步复制。也可以配置参数 <code>rpl_semi_sync_master_wait_for_slave_count</code> 来指定至少等待到几个从库提交 ACK 主库才可以返回提交。</p>
<br>

<h3 id="组复制"><a href="#组复制" class="headerlink" title="组复制"></a>组复制</h3><p>组由多个服务器构成，通过传递消息进行交互，通信层保证原子消息传递。组中的每个服务器独立地执行事务，但是所有读写事务只有在得到组的批准后才会提交。只读事务在组内不需要协调，因此立即提交。对于任何读写事务，当事务准备好在始发服务器处提交时，服务器以原子方式广播写入值（更改的行）和对应的写入集（更新的行的唯一标识符），然后将该事务加入全局事务列表。最终所有服务器都以相同的顺序接收并应用相同的事务集，所以它们在组内保持一致。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OW5BZV"><img src="https://s1.ax1x.com/2022/05/16/OW5BZV.png" alt="OW5BZV.png"></a></p>
<p>组复制的原理复杂，需要依赖共识算法。虽然组复制实际使用的很少，但它是数据库走向原生分布式的示范。</p>
<br>

<h2 id="主从复制的配置"><a href="#主从复制的配置" class="headerlink" title="主从复制的配置"></a>主从复制的配置</h2><p>修改 MySQL 主库和从库的配置文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-8-13-centos ~]<span class="comment"># vim /etc/my.cnf</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OWqnFx"><img src="https://s1.ax1x.com/2022/05/16/OWqnFx.png" alt="OWqnFx.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OWqGmd"><img src="https://s1.ax1x.com/2022/05/16/OWqGmd.png" alt="OWqGmd.png"></a></p>
<p>重启 Mysql：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-8-13-centos ~]<span class="comment"># systemctl restart mysqld</span></span><br></pre></td></tr></table></figure>

<p>备份主库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-8-13-centos ~]<span class="comment"># mysql -uhjc -p123456</span></span><br><span class="line">mysql&gt; flush tables with <span class="built_in">read</span> lock;</span><br><span class="line">mysql&gt; show master status;</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| mysql-bin.000008 |   306037 |              |                  |                   |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"><span class="comment"># 当前 binlog 文件写到了 000008 号的 306037 位置</span></span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="built_in">exit</span></span><br><span class="line">[root@VM-8-13-centos ~]<span class="comment"># mysqldump -uhjc -p123456 --alldatabases -master-data &gt; dump.sql</span></span><br><span class="line">[root@VM-8-13-centos ~]<span class="comment"># scp dump.sql root@43.138.201.82:/root/dump.sql</span></span><br><span class="line"></span><br><span class="line">[root@VM-8-13-centos ~]<span class="comment"># mysql -uhjc -p123456</span></span><br><span class="line">mysql&gt; unlock tables;</span><br></pre></td></tr></table></figure>

<p>从库还原主库数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-8-13-centos ~]<span class="comment"># mysql -uroot -p123456</span></span><br><span class="line">mysql&gt; <span class="built_in">source</span> /root/dump.sql</span><br><span class="line">mysql&gt; show slave status;</span><br><span class="line"></span><br><span class="line">mysql&gt; change master to </span><br><span class="line">		-&gt; MASTER_HOST=<span class="string">&#x27;43.138.82.201&#x27;</span></span><br><span class="line">		-&gt; MASTER_USER=<span class="string">&#x27;hjc&#x27;</span>,</span><br><span class="line">		-&gt; MASTER_PASSWORD=123456,</span><br><span class="line">		-&gt; MASTER_LOG_FILE=<span class="string">&#x27;mysql-bin.000008&#x27;</span>,</span><br><span class="line">		-&gt; MASTER_LOG_POS=306037;</span><br></pre></td></tr></table></figure>

<p>配置半同步复制：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-8-13-centos ~]<span class="comment"># vim /etc/my.cnf</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OWvcWt"><img src="https://s1.ax1x.com/2022/05/16/OWvcWt.png" alt="OWvcWt.png"></a></p>
<br>

<h2 id="更方便地复制"><a href="#更方便地复制" class="headerlink" title="更方便地复制"></a>更方便地复制</h2><p>使用 LOG_FILE + LOG_POS 对于主从复制的配置十分不方便，需要指明 Binlog 的位置即当前 Binlog 写的位置。造成这样的原因就是从库不知道该从哪个 log 开始复制。因此可以为每个事务分配一个唯一 ID。</p>
<h3 id="GTID-Global-Transaction-Identifier"><a href="#GTID-Global-Transaction-Identifier" class="headerlink" title="GTID(Global Transaction Identifier)"></a>GTID(Global Transaction Identifier)</h3><p>在 MySQL 5.6 版本中引入了 GTID。GTID &#x3D; server_uuid:gon，其中 server_uuid 是节点的 uuid，gon 是事务的流水号（回滚会收回）。</p>
<br>

<h3 id="启用-GTID"><a href="#启用-GTID" class="headerlink" title="启用 GTID"></a>启用 GTID</h3><p>主库和从库都需要开启：</p>
<ul>
<li><code>gtid_mode = on</code></li>
<li><code>enforce_gtid_consistency = on</code></li>
</ul>
<br>

<h3 id="使用-GTID-进行主从复制"><a href="#使用-GTID-进行主从复制" class="headerlink" title="使用 GTID 进行主从复制"></a>使用 GTID 进行主从复制</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> change master <span class="keyword">to</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> MASTER_HOST<span class="operator">=</span><span class="string">&#x27;43.138.82.201&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> MASTER_USER<span class="operator">=</span><span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> MASTER_PASSWORD<span class="operator">=</span><span class="number">123456</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> MASTER_AUTO_POSITION<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>



<br>

<h2 id="Binlog-的格式问题"><a href="#Binlog-的格式问题" class="headerlink" title="Binlog 的格式问题"></a>Binlog 的格式问题</h2><h3 id="Statement-格式的-Binlog"><a href="#Statement-格式的-Binlog" class="headerlink" title="Statement 格式的 Binlog"></a>Statement 格式的 Binlog</h3><p>在 MySQL 5.0 之前默认使用 Statement 格式的 Binlog。这种格式的 Binlog 记录的是 SQL 语句的原文。</p>
<p>但由于主从库对于 SQL 的执行不一致，可能存在数据安全风险。如当我们在主库中删除一条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> sakila.t3 limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>而该语句没有指定排序规则而直接删除一行，可能使用主键索引或辅助索引，因此对于从库来讲使用 Statement 格式的 Binlog 就是记录了一条删除的 SQL 语句而不清楚是如何排序删除的，这样就会导致删除的行可能不同。</p>
<br>

<h3 id="ROW-格式的-Binlog"><a href="#ROW-格式的-Binlog" class="headerlink" title="ROW 格式的 Binlog"></a>ROW 格式的 Binlog</h3><p>ROW 格式的 Binlog 不记录 SQL 语句的原文，而是记录的数据行的变化。它不是物理日志而是逻辑日志，占用的空间比较大。</p>
<p>当我们同样使用上述 SQL 语句进行删除时，ROW 格式的 Binlog 记录了变化的行 ID 及其对应操作。这样对于从库就明确了变动的行是哪一行，变动的操作是什么。</p>
<br>

<h3 id="Mixed-格式的-Binlog"><a href="#Mixed-格式的-Binlog" class="headerlink" title="Mixed 格式的 Binlog"></a>Mixed 格式的 Binlog</h3><p>Mixed 格式的 Binlog 就是 Statement 格式和 ROW 格式混合使用。当 MySQL 发现该 SQL 语句有数据风险时则选择使用 ROW 格式，其余没有风险的 SQL 语句则使用 Statement 格式的 Binlog 来节省空间。</p>
<br>

<h3 id="基于语句或行的复制"><a href="#基于语句或行的复制" class="headerlink" title="基于语句或行的复制"></a>基于语句或行的复制</h3><ul>
<li>基于语句的复制：Statement</li>
<li>基于行的复制：ROW</li>
</ul>
<br>

<h2 id="从库的延迟问题"><a href="#从库的延迟问题" class="headerlink" title="从库的延迟问题"></a>从库的延迟问题</h2><p>在从库的 Status 中有关于从库此时是多少秒前主库的数据的信息：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> slave status;</span><br><span class="line">...</span><br><span class="line">Seconds_Behind_Master: <span class="number">0</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="从库延迟的原因"><a href="#从库延迟的原因" class="headerlink" title="从库延迟的原因"></a>从库延迟的原因</h3><p>即使主从复制时使用了半同步复制也只是保证了主库的 Binlog 被顺利传送到了从库，但从库的 SQL_Thread 读取和重放 relay log 还是需要耗费一定时间的。而且从库的性能往往不如主库，从库也经常承担了很多分析 SQL，也有可能主库的长事务还未提交而从库收不到 Binlog 等等原因都会造成从库的延迟问题。因此，从库延迟的主要原因就是从库执行太慢。</p>
<br>

<h3 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h3><ul>
<li>主从使用相同配置的机器</li>
<li>从库关闭 log 实事落盘</li>
<li>增加从库数量来应对分析 SQL</li>
<li>Binlog 传送至大数据系统来分析</li>
<li>将一个大事务分为多个小事务</li>
</ul>
<p>但这样依然会存在问题：由于 MySQL 天然是多线程多用户的，因此对于主库的操作也是多线程的。而从库是单线程执行的，这就会导致多线程执行产生的 Binlog 会交给单线程的从库使用。即从库对硬件资源的利用天然不如主库。</p>
<br>

<h3 id="并行复制的思路"><a href="#并行复制的思路" class="headerlink" title="并行复制的思路"></a>并行复制的思路</h3><p>从库的 SQL_Thread 的线程不再重放 relay log，它负责读取并将 relay log 分配给多线程的 worker，让 worker 对分配到的 relay log 进行重放。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OfiAC4"><img src="https://s1.ax1x.com/2022/05/16/OfiAC4.png" alt="OfiAC4.png"></a></p>
<p>这样就能解决主从库一个多线程一个单线程的问题。但现在需要解决的是如何进行分配的问题。对于多线程并行重放 relay log 来说，我们不能将相互依赖的语句并行执行，如插入并修改一条数据，若并行执行先执行了修改但此时插入还未执行就会导致产生问题。</p>
<br>

<h3 id="MySQL-5-6-并行复制"><a href="#MySQL-5-6-并行复制" class="headerlink" title="MySQL 5.6 并行复制"></a>MySQL 5.6 并行复制</h3><p>MySQL 5.6 使用按库并行的策略。对于不同库操作的 SQL 语句才会分配给不同的 worker。</p>
<p>可以配置 <code>slave_parallel-type=DATABASE</code> 参数开启按库并行。</p>
<p>按库并行的分发选择快而且支持各种 log 格式。但这样的粒度太大，很难实现负载均衡。</p>
<br>

<h3 id="MySQL-5-7-事务组并行的策略"><a href="#MySQL-5-7-事务组并行的策略" class="headerlink" title="MySQL 5.7 事务组并行的策略"></a>MySQL 5.7 事务组并行的策略</h3><p>首先需要明确的是 Binlog 刷盘其实是两步动作：</p>
<ol>
<li>先把 Binlog 从 Binlog Cache 中写到内存中的 Binlog 文件</li>
<li>调用 fsync 持久化到硬盘</li>
</ol>
<p>不考虑 redo log 时 Binlog 的并行刷盘：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OfE4mR"><img src="https://s1.ax1x.com/2022/05/16/OfE4mR.png" alt="OfE4mR.png"></a></p>
<p>虽然是并行执行，但其实读写磁盘进行了多次，其实可以只进行一次持久化：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OfVkcQ"><img src="https://s1.ax1x.com/2022/05/16/OfVkcQ.png" alt="OfVkcQ.png"></a></p>
<p>这样，这里的 1、2、3 号就属于一个事务组。对于事务组的配置：</p>
<ul>
<li><code>binlog_group_commit_sync_delay</code>：延迟调用 fsync 的微秒数</li>
<li><code>binlog_group_commit_sync_no_delay_count</code>：调用 fsync 的累积数</li>
</ul>
<p>这两个配置是或的关系，如延迟 1 微秒调用 fsync，当在这 1 微秒之内有 10 个事务累积则调用 fsync，否则在 1 微秒后调用 fsync。</p>
<p>因此，在主库上同时处于 prepare 状态的事务在从库执行时也是可以并行的。</p>
<p>可以配置 <code>slave_parallel_type = LOGICAL_CLOCK</code> 参数开启事务组并行策略。</p>
<br>

<h3 id="MySQL-5-7-22-并行复制"><a href="#MySQL-5-7-22-并行复制" class="headerlink" title="MySQL 5.7.22 并行复制"></a>MySQL 5.7.22 并行复制</h3><p>参数 <code>binlog-transaction-dependency-tracking</code>：</p>
<ul>
<li><code>COMMIT_ORDER</code>：按事务组并行</li>
<li><code>WRITESET</code>：没有修改相同行的事务可以并行（按行分发）</li>
<li><code>WRITESET_SESSION</code>：同一个线程先后执行的两个事务不能并行</li>
</ul>
<br>

<h2 id="如何在从库读到最新数据"><a href="#如何在从库读到最新数据" class="headerlink" title="如何在从库读到最新数据"></a>如何在从库读到最新数据</h2><h3 id="判断从库已经同步"><a href="#判断从库已经同步" class="headerlink" title="判断从库已经同步"></a>判断从库已经同步</h3><ul>
<li>强制延时</li>
<li><code>seconds_behind_master=0</code></li>
<li>对比 Binlog 的执行位点</li>
<li>对比 GTID 执行情况</li>
</ul>
<p>但其实从库延迟在理论上是无法消灭的，Binlog 传送、relay log 重放都需要时间。因此，从库延迟只能减小而无法消灭。在从库读取数据时永远会面临数据延迟的问题。</p>
<br>

<h3 id="判断具体事务已经重放"><a href="#判断具体事务已经重放" class="headerlink" title="判断具体事务已经重放"></a>判断具体事务已经重放</h3><ul>
<li><p>等待 Binlog 位点：</p>
<p><code>select master_pos_wait(file, pos[, timeout]);</code></p>
</li>
<li><p>等待 GTID（5.7.6 之后可以返回每次的 GTID）</p>
<p><code>select wait_for_executed_gtid_set(gtid_set, 1);</code></p>
</li>
</ul>
<br>

<h2 id="实现最简单的高可用架构"><a href="#实现最简单的高可用架构" class="headerlink" title="实现最简单的高可用架构"></a>实现最简单的高可用架构</h2><h3 id="主-主复制架构"><a href="#主-主复制架构" class="headerlink" title="主-主复制架构"></a>主-主复制架构</h3><p>在主-主复制架构中两个节点均为 Master，同时两个节点又互为 Slave。这样，当一个节点出现故障时无需切换仍能继续正常使用服务。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OfMiad"><img src="https://s1.ax1x.com/2022/05/16/OfMiad.png"></a></p>
<p>当 MySQL A 出现故障时，只需要关闭 MySQL B 的只读即可：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OfM7SP"><img src="https://s1.ax1x.com/2022/05/16/OfM7SP.png" alt="OfM7SP.png"></a></p>
<p>若 MySQL A 重新上线，也只需要开启 MySQL A 的只读：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OfQSWq"><img src="https://s1.ax1x.com/2022/05/16/OfQSWq.png" alt="OfQSWq.png"></a></p>
<p>在之前主从复制的配置时已经配置了从库复制主库，因此要配置主-主复制架构只需要让主库去复制从库即可：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> change master <span class="keyword">to</span> </span><br><span class="line">		<span class="operator">-</span><span class="operator">&gt;</span> MASTER_HOST<span class="operator">=</span><span class="string">&#x27;43.138.201.82&#x27;</span></span><br><span class="line">		<span class="operator">-</span><span class="operator">&gt;</span> MASTER_USER<span class="operator">=</span><span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">		<span class="operator">-</span><span class="operator">&gt;</span> MASTER_PASSWORD<span class="operator">=</span><span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line">		<span class="operator">-</span><span class="operator">&gt;</span> MASTER_AUTO_POSITION<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">start</span> slave;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="主-主架构的问题"><a href="#主-主架构的问题" class="headerlink" title="主-主架构的问题"></a>主-主架构的问题</h3><ul>
<li><p>数据冲突问题</p>
<p>若没有为其中一个节点开启只读，则两边插入相同 ID 时可能出现冲突。因此可以开启一个只读或两个节点约定好插入不同 ID。</p>
</li>
<li><p>客户端切换问题</p>
<p>应用自己切换客户端比较麻烦，可以使用 keepalived 等手段完成自动切换</p>
</li>
<li><p>循环复制问题</p>
<p>在未开启 GTID 时可以使用 ServerID 过滤。开启 GTID 则可以避免该问题。</p>
</li>
</ul>
<br>

<h2 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h2><h3 id="复制的类型-1"><a href="#复制的类型-1" class="headerlink" title="复制的类型"></a>复制的类型</h3><ul>
<li>按照同步类型，可以分为异步、半同步、组复制</li>
<li>半同步是兼顾数据安全与效率的较好选择</li>
</ul>
<h3 id="GTID"><a href="#GTID" class="headerlink" title="GTID"></a>GTID</h3><ul>
<li>GTID 可以给事务分配全局唯一 ID</li>
<li>GTID 方便了主从复制的配置，推荐打开</li>
<li>GTID 对主从切换、故障恢复也有很大意义</li>
</ul>
<h3 id="Binlog-格式"><a href="#Binlog-格式" class="headerlink" title="Binlog 格式"></a>Binlog 格式</h3><ul>
<li>Statement 格式记录了实际执行的 SQL 语句</li>
<li>ROW 格式按照整行记录了数据的变化</li>
<li>推荐直接使用 ROW 格式</li>
</ul>
<h3 id="从库延迟"><a href="#从库延迟" class="headerlink" title="从库延迟"></a>从库延迟</h3><ul>
<li>提升性能：设计备库硬件、关闭 log 实时落盘</li>
<li>减少负担：增加数量、使用其他组件</li>
</ul>
<h3 id="并行复制"><a href="#并行复制" class="headerlink" title="并行复制"></a>并行复制</h3><ul>
<li>从库延迟的根本原因是主库多线程而从库是单线程</li>
<li>并行复制思路：按表复制、按行复制</li>
<li>MySQL 5.7 借鉴了事务组的思想，将同一个事务组的 relay log 并行</li>
<li>MySQL 5.7.22 引入了没有修改相同行的事务并行的方法</li>
</ul>
<h3 id="判断主从同步的情况"><a href="#判断主从同步的情况" class="headerlink" title="判断主从同步的情况"></a>判断主从同步的情况</h3><ul>
<li>可以通过对比执行位点的方法判断从库延时</li>
<li>从库延时可能无法消灭</li>
<li>可以通过 Binlog 位点和 GTID 等待方法等待具体事务</li>
</ul>
<h3 id="主-主复制架构-1"><a href="#主-主复制架构-1" class="headerlink" title="主-主复制架构"></a>主-主复制架构</h3><ul>
<li>主主架构是最简单的高可用架构</li>
<li>存在数据冲突、客户端切换不便等问题</li>
</ul>
<br>

<h1 id="如何解决数据库超大容量"><a href="#如何解决数据库超大容量" class="headerlink" title="如何解决数据库超大容量"></a>如何解决数据库超大容量</h1><h2 id="最简单地扩展容量"><a href="#最简单地扩展容量" class="headerlink" title="最简单地扩展容量"></a>最简单地扩展容量</h2><h3 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h3><p>MySQL 数据库在 5.1 版本时添加了对于分区的支持，这个过程是将一个表或者索引物分解为多个更小、更可管理的部分。就访问数据库的应用而言，从逻辑上讲，只有一个表或者一个索引，但是在物理上这个表或者索引可能由数十个物理分区组成。每个分区都是独立的对象，可以独自处理，也可以作为一个更大对象的一部分进行处理。</p>
<p>分区功能并不是在存储引擎层完成的，因此不只有 InnoDB 存储引擎支持分区，常见的存储引擎 MyISAM、NDB 等都支持。</p>
<p>建表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `t4` (</span><br><span class="line">	`ftime` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  KEY(`ftime`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> latin1</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(<span class="keyword">YEAR</span>(ftime))(</span><br><span class="line">	<span class="keyword">PARTITION</span> p_2030</span><br><span class="line">  <span class="keyword">VALUES</span></span><br><span class="line">  	LESS THAN(<span class="number">2030</span>) ENGINE <span class="operator">=</span> InnoDB,</span><br><span class="line">  	<span class="keyword">PARTITION</span> p_2031</span><br><span class="line">  <span class="keyword">VALUES</span></span><br><span class="line">  	LESS THAN(<span class="number">2031</span>) ENGINE <span class="operator">=</span> InnoDB,</span><br><span class="line">  	<span class="keyword">PARTITION</span> p_2032</span><br><span class="line">  <span class="keyword">VALUES</span></span><br><span class="line">  	LESS THAN(<span class="number">2032</span>) ENGINE <span class="operator">=</span>InnoDB,</span><br><span class="line">  	<span class="keyword">PARTITION</span> p_others</span><br><span class="line">  <span class="keyword">VALUES</span></span><br><span class="line">  	LESS THAN MAXVALUE ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>对于 Server 层来说只有一个 t4 表，而对于 InnoDB 来说分成了四个表。还可以指定分区位置：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">  LESS THAN(<span class="number">2030</span>) ENGINE <span class="operator">=</span> InnoDB,</span><br><span class="line">  INDEX DIRECTORY <span class="operator">=</span> <span class="string">&#x27;/data1&#x27;</span></span><br><span class="line">  DATA DIRECTORY <span class="operator">=</span> <span class="string">&#x27;/data2&#x27;</span>,</span><br><span class="line"> 	<span class="keyword">PARTITION</span> p_2031</span><br></pre></td></tr></table></figure>

<br>

<h3 id="分区方式"><a href="#分区方式" class="headerlink" title="分区方式"></a>分区方式</h3><ul>
<li>范围分区</li>
<li>Hash 分区</li>
<li>List 分区</li>
</ul>
<br>

<h3 id="分区表的优劣"><a href="#分区表的优劣" class="headerlink" title="分区表的优劣"></a>分区表的优劣</h3><p><strong>优势</strong></p>
<ul>
<li>降低 B+ 树的层级，加速搜索</li>
<li>将一个数据表物理上分为多个文件，方便处理</li>
</ul>
<p><strong>缺陷</strong></p>
<ul>
<li>第一次需要访问所有分区</li>
<li>共用 MDL 锁</li>
<li>分区之后所有的分区依然位于同一节点</li>
</ul>
<br>

<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h3><ul>
<li>垂直分表：按照字段分表，一般分为冷热字段</li>
<li>水平分表：按照行分表，常用范围、Hash 切分。水平分表类似于分区表但其 Server 层也进行了切分。</li>
</ul>
<br>

<h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OfwoM4"><img src="https://s1.ax1x.com/2022/05/16/OfwoM4.png" alt="OfwoM4.png"></a></p>
<p>一般根据字段的冷热来进行切分，热数据和冷数据分开来存放。</p>
<br>

<h3 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Of0H1S"><img src="https://s1.ax1x.com/2022/05/16/Of0H1S.png" alt="Of0H1S.png"></a></p>
<br>

<h3 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h3><ul>
<li>垂直分库：将数据表分散在多个数据库或节点中</li>
<li>水平分库：将所有表水平拆分，每个数据库结构相同</li>
</ul>
<br>

<h3 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OfByEn"><img src="https://s1.ax1x.com/2022/05/16/OfByEn.png" alt="OfByEn.png"></a></p>
<br>

<h3 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OfB5DJ"><img src="https://s1.ax1x.com/2022/05/16/OfB5DJ.png" alt="OfB5DJ.png"></a></p>
<br>

<h3 id="分库分表的优劣"><a href="#分库分表的优劣" class="headerlink" title="分库分表的优劣"></a>分库分表的优劣</h3><p><strong>优势</strong></p>
<ul>
<li>增加了隔离性</li>
<li>提升了容量和并发性能</li>
</ul>
<p><strong>缺陷</strong></p>
<ul>
<li>部分失效可能性成倍增加</li>
<li>无法使用单点事务</li>
<li>垂直切分后无法 JOIN</li>
<li>范围查询更新困难</li>
</ul>
<br>

<h3 id="分库分表后的使用"><a href="#分库分表后的使用" class="headerlink" title="分库分表后的使用"></a>分库分表后的使用</h3><ul>
<li>业务特殊处理</li>
<li>业务应用使用中间层</li>
<li>使用分库分表中间件</li>
</ul>
<br>

<h2 id="DBLE"><a href="#DBLE" class="headerlink" title="DBLE"></a>DBLE</h2><p>DBLE 是由上海爱可生公司基于 MyCat 开发的企业级开源分布式高性能、高可用的 MySQL 分库分表中间件，被称为 “MyCat Plus”。以其简单稳定，持续维护，良好的社区环境和广大的群众基础得到了社区的大力支持。</p>
<h3 id="分库分表中间件的原理"><a href="#分库分表中间件的原理" class="headerlink" title="分库分表中间件的原理"></a>分库分表中间件的原理</h3><p>当分库分表中间件接收到 SQL 语句时：</p>
<ol>
<li>分析 SQL 语句</li>
<li>根据 SQL 语义将 SQL 拆分成多个并发送至数据节点</li>
<li>将多个数据节点的结果聚集，返回给客户端</li>
</ol>
<br>

<h3 id="DBLE-架构设计"><a href="#DBLE-架构设计" class="headerlink" title="DBLE 架构设计"></a>DBLE 架构设计</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OfrztI"><img src="https://s1.ax1x.com/2022/05/16/OfrztI.png" alt="OfrztI.png"></a></p>
<p>首先外部应用通过 NIO&#x2F;AIO 进行连接操作来到 SQL Parser 层进行解析。SQL Parser 进行判断是否为 Simply Query，如果是则直接继续普通流程；如果不是则进行生产执行计划分为多个 Basic SQL，然后路由下发到 SQL Executer 作为客户端与各个底层 MySQL Sharding 数据库进行连接并执行 SQL，这个后台执行的过程也是通过 NIO&#x2F;AIO 来实现的。底层各个数据库执行完成之后再返回到中间层进行合并、过滤、分组、排序等操作，最终在返回给客户端。</p>
<br>

<h3 id="DBLE-对-MyCat-做的增强"><a href="#DBLE-对-MyCat-做的增强" class="headerlink" title="DBLE 对 MyCat 做的增强"></a>DBLE 对 MyCat 做的增强</h3><ul>
<li>缺陷修复</li>
<li>实现改进</li>
<li>功能增强</li>
<li>功能裁剪</li>
</ul>
<br>

<h3 id="DBLE-的基础概念"><a href="#DBLE-的基础概念" class="headerlink" title="DBLE 的基础概念"></a>DBLE 的基础概念</h3><ul>
<li>schema：虚拟数据库（不同于传统的 schema）</li>
<li>shardingTable：虚拟表（被拆分的表）</li>
<li>shardingNode：虚拟节点</li>
<li>dbGroup：实际的 MySQL集群</li>
<li>database：实际的 database</li>
</ul>
<p><strong>DBLE 表拆分图示</strong>：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OfgpVg"><img src="https://s1.ax1x.com/2022/05/16/OfgpVg.png" alt="OfgpVg.png"></a></p>
<br>

<h3 id="DBLE-表的类型"><a href="#DBLE-表的类型" class="headerlink" title="DBLE 表的类型"></a>DBLE 表的类型</h3><ul>
<li>全局表：每个节点上都有保存表的完整数据</li>
<li>拆分表：被拆分的表，存入不同节点中</li>
<li>非拆分表：不拆分的表，存在单一节点中</li>
</ul>
<br>

<h2 id="安装-DBLE"><a href="#安装-DBLE" class="headerlink" title="安装 DBLE"></a>安装 DBLE</h2><h3 id="DBLE-最简运行环境搭建"><a href="#DBLE-最简运行环境搭建" class="headerlink" title="DBLE 最简运行环境搭建"></a>DBLE 最简运行环境搭建</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Of2uOf"><img src="https://s1.ax1x.com/2022/05/16/Of2uOf.png" alt="Of2uOf.png"></a></p>
<p>首先需要 Java 运行环境。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-8-13-centos ~]<span class="comment"># yum install java</span></span><br></pre></td></tr></table></figure>

<p>然后配置环境变量。</p>
<p>下载链接：<a target="_blank" rel="noopener" href="https://github.com/actiontech/dble/releases/tag/3.22.01.0%2Ftag">https://github.com/actiontech/dble/releases/tag/3.22.01.0%2Ftag</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-8-13-centos ~]<span class="comment"># wget https://github.com/actiontech/dble/releases/download/3.22.01.0%2Ftag/dble-3.22.01.0-20220427091933-java1.8.0_151-linux.tar.gz</span></span><br><span class="line">[root@VM-8-13-centos ~]<span class="comment"># tar -xvf dble-3.22.01.0-20220427091933-java1.8.0_151-linux.tar.gz -C &#x27;/var/lib&#x27;</span></span><br><span class="line">[root@VM-8-13-centos conf]<span class="comment"># cd /var/lib/dble/conf</span></span><br></pre></td></tr></table></figure>

<p>我们需要修改配置文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-8-13-centos conf]<span class="comment"># mv cluster_template.cnf cluster.cnf</span></span><br><span class="line">[root@VM-8-13-centos conf]<span class="comment"># mv bootstrap_template.cnf bootstrap.cnf</span></span><br><span class="line">[root@VM-8-13-centos conf]<span class="comment"># vim db_template.xml</span></span><br></pre></td></tr></table></figure>

<p>主要是要指定 dbInstance，url 为已搭建 MySQL 的节点 IP 和端口。user 是 MySQL 登录用户名，password 是 MySQL 登录密码。其他参数可以参考<a target="_blank" rel="noopener" href="https://actiontech.github.io/dble-docs-cn/">官网文档</a></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">dble</span>:db <span class="keyword">SYSTEM</span> <span class="string">&quot;db.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dble:db</span> <span class="attr">xmlns:dble</span>=<span class="string">&quot;http://dble.cloud/&quot;</span> <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dbGroup</span> <span class="attr">name</span>=<span class="string">&quot;host_1&quot;</span> <span class="attr">rwSplitMode</span>=<span class="string">&quot;0&quot;</span> <span class="attr">delayThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">heartbeat</span> &gt;</span>select 1<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dbInstance</span> <span class="attr">name</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;43.138.201.82:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;hjc&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">primary</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dbGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dbGroup</span> <span class="attr">name</span>=<span class="string">&quot;host_2&quot;</span> <span class="attr">rwSplitMode</span>=<span class="string">&quot;0&quot;</span> <span class="attr">delayThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">heartbeat</span> &gt;</span>select 1<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dbInstance</span> <span class="attr">name</span>=<span class="string">&quot;hostM2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;43.138.82.201:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">primary</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dbGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dble:db</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>保存后重命名：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-8-13-centos conf]<span class="comment"># mv db_template.xml db.xml</span></span><br><span class="line">[root@VM-8-13-centos conf]<span class="comment"># vim user_template.xml</span></span><br></pre></td></tr></table></figure>

<p>managerUser 是属于 DBLE 的管理员账号，用于管理元数据库。shardingUser 是分库⽤⼾配置账号，可以用于登录创建虚拟数据库和表。shardingUser 中的 schemas 要和 sharding.xml 中的 schema 的 name 对应。readOnly 配置只读用户，可配置 true&#x2F;false， 默认 false，如果设置成 true 则只能进行 show 或 select，不能进行运维管理。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">dble</span>:user <span class="keyword">SYSTEM</span> <span class="string">&quot;user.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dble:user</span> <span class="attr">xmlns:dble</span>=<span class="string">&quot;http://dble.cloud/&quot;</span> <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">managerUser</span> <span class="attr">name</span>=<span class="string">&quot;admin&quot;</span> <span class="attr">password</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">shardingUser</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span> <span class="attr">schemas</span>=<span class="string">&quot;testdb&quot;</span> <span class="attr">readOnly</span>=<span class="string">&quot;false&quot;</span>  <span class="attr">maxCon</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dble:user</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>保存后重命名：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-8-13-centos conf]<span class="comment"># mv user_template.xml user.xml</span></span><br><span class="line">[root@VM-8-13-centos conf]<span class="comment"># vim sharding_template.xml</span></span><br></pre></td></tr></table></figure>



<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">dble</span>:sharding <span class="keyword">SYSTEM</span> <span class="string">&quot;sharding.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dble:sharding</span> <span class="attr">xmlns:dble</span>=<span class="string">&quot;http://dble.cloud/&quot;</span> <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;testdb&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">shardingTable</span> <span class="attr">name</span>=<span class="string">&quot;tb_enum_sharding&quot;</span> <span class="attr">shardingNode</span>=<span class="string">&quot;dn1,dn2&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;200&quot;</span> <span class="attr">function</span>=<span class="string">&quot;func_enum&quot;</span> <span class="attr">shardingColumn</span>=<span class="string">&quot;code&quot;</span>/&gt;</span></span><br><span class="line">      	<span class="tag">&lt;<span class="name">shardingTable</span> <span class="attr">name</span>=<span class="string">&quot;tb_range_sharding&quot;</span> <span class="attr">shardingNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">function</span>=<span class="string">&quot;func_range&quot;</span> <span class="attr">shardingColumn</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">      	<span class="tag">&lt;<span class="name">shardingTable</span> <span class="attr">name</span>=<span class="string">&quot;tb_hash_sharding&quot;</span> <span class="attr">shardingNode</span>=<span class="string">&quot;dn1,dn2&quot;</span> <span class="attr">function</span>=<span class="string">&quot;func_common_hash&quot;</span> <span class="attr">shardingColumn</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">shardingTable</span> <span class="attr">name</span>=<span class="string">&quot;tb_hash_sharding_er1&quot;</span> <span class="attr">shardingNode</span>=<span class="string">&quot;dn1,dn2&quot;</span> <span class="attr">function</span>=<span class="string">&quot;func_common_hash&quot;</span> <span class="attr">shardingColumn</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">shardingTable</span> <span class="attr">name</span>=<span class="string">&quot;tb_hash_sharding_er2&quot;</span> <span class="attr">shardingNode</span>=<span class="string">&quot;dn1,dn2&quot;</span> <span class="attr">function</span>=<span class="string">&quot;func_common_hash&quot;</span> <span class="attr">shardingColumn</span>=<span class="string">&quot;id2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">shardingTable</span> <span class="attr">name</span>=<span class="string">&quot;tb_hash_sharding_er3&quot;</span> <span class="attr">shardingNode</span>=<span class="string">&quot;dn1,dn2&quot;</span> <span class="attr">function</span>=<span class="string">&quot;func_common_hash&quot;</span> <span class="attr">shardingColumn</span>=<span class="string">&quot;id&quot;</span> <span class="attr">incrementColumn</span>=<span class="string">&quot;id2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">shardingTable</span> <span class="attr">name</span>=<span class="string">&quot;tb_uneven_hash&quot;</span> <span class="attr">shardingNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">function</span>=<span class="string">&quot;func_uneven_hash&quot;</span> <span class="attr">shardingColumn</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">      	<span class="tag">&lt;<span class="name">shardingTable</span> <span class="attr">name</span>=<span class="string">&quot;tb_mod&quot;</span> <span class="attr">shardingNode</span>=<span class="string">&quot;dn1,dn2,dn3,dn4&quot;</span> <span class="attr">function</span>=<span class="string">&quot;func_mod&quot;</span> <span class="attr">shardingColumn</span>=<span class="string">&quot;id&quot;</span> <span class="attr">sqlRequiredSharding</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">      	<span class="tag">&lt;<span class="name">shardingTable</span> <span class="attr">name</span>=<span class="string">&quot;tb_jump_hahs&quot;</span> <span class="attr">shardingNode</span>=<span class="string">&quot;dn1,dn2&quot;</span> <span class="attr">function</span>=<span class="string">&quot;func_jumpHash&quot;</span> <span class="attr">shardingColumn</span>=<span class="string">&quot;code&quot;</span>/&gt;</span></span><br><span class="line">      	<span class="tag">&lt;<span class="name">shardingTable</span> <span class="attr">name</span>=<span class="string">&quot;tb_hash_string&quot;</span> <span class="attr">shardingNode</span>=<span class="string">&quot;dn1,dn2,dn3,dn4&quot;</span> <span class="attr">function</span>=<span class="string">&quot;func_hashString&quot;</span> <span class="attr">shardingColumn</span>=<span class="string">&quot;code&quot;</span>/&gt;</span></span><br><span class="line">      	<span class="tag">&lt;<span class="name">shardingTable</span> <span class="attr">name</span>=<span class="string">&quot;tb_date&quot;</span> <span class="attr">shardingNode</span>=<span class="string">&quot;dn1,dn2,dn3,dn4&quot;</span> <span class="attr">function</span>=<span class="string">&quot;func_date&quot;</span> <span class="attr">shardingColumn</span>=<span class="string">&quot;create_date&quot;</span>/&gt;</span></span><br><span class="line">      	<span class="tag">&lt;<span class="name">shardingTable</span> <span class="attr">name</span>=<span class="string">&quot;tb_pattern&quot;</span> <span class="attr">shardingNode</span>=<span class="string">&quot;dn1,dn2&quot;</span> <span class="attr">function</span>=<span class="string">&quot;func_pattern&quot;</span> <span class="attr">shardingColumn</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">      	<span class="tag">&lt;<span class="name">globalTable</span> <span class="attr">name</span>=<span class="string">&quot;tb_global1&quot;</span> <span class="attr">shardingNode</span>=<span class="string">&quot;dn1,dn2&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;103&quot;</span>/&gt;</span></span><br><span class="line">      	<span class="tag">&lt;<span class="name">globalTable</span> <span class="attr">name</span>=<span class="string">&quot;tb_global2&quot;</span> <span class="attr">shardingNode</span>=<span class="string">&quot;dn1,dn2,dn3,dn4&quot;</span> <span class="attr">corn</span>=<span class="string">&quot;0 0 0 * * ?&quot;</span> <span class="attr">checkClass</span>=<span class="string">&quot;CHECKSUM&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">schema</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;testdb2&quot;</span> <span class="attr">shardingNode</span>=<span class="string">&quot;dn5&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">shardingNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dbGroup</span>=<span class="string">&quot;dbGrou1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db_1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">shardingNode</span> <span class="attr">name</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">dbGroup</span>=<span class="string">&quot;dbGrou2&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db_2&quot;</span>/&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">shardingNode</span> <span class="attr">name</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">dbGroup</span>=<span class="string">&quot;dbGrou1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db_3&quot;</span>/&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">shardingNode</span> <span class="attr">name</span>=<span class="string">&quot;dn4&quot;</span> <span class="attr">dbGroup</span>=<span class="string">&quot;dbGrou2&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db_4&quot;</span>/&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">shardingNode</span> <span class="attr">name</span>=<span class="string">&quot;dn5&quot;</span> <span class="attr">dbGroup</span>=<span class="string">&quot;dbGrou1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db_5&quot;</span>/&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">shardingNode</span> <span class="attr">name</span>=<span class="string">&quot;dn6&quot;</span> <span class="attr">dbGroup</span>=<span class="string">&quot;dbGrou2&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db-6&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;mod&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Hash&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;partitionCount&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;partitionLength&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dble:sharding</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>schema 对应的 name 表示在分库用户端存在的数据库名。配置的 shardingTable 的 name 对应分库用户端存在的数据表名。</p>
<p>保存后重命名：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-8-13-centos conf]<span class="comment"># mv sharding_template.xml sharding.xml</span></span><br></pre></td></tr></table></figure>

<p>启动 DBLE：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-8-13-centos dble]<span class="comment"># cd ..</span></span><br><span class="line">[root@VM-8-13-centos dble]<span class="comment"># bin/dble start</span></span><br><span class="line">[root@VM-8-13-centos dble]<span class="comment"># mysql -h&#x27;127.0.0.1&#x27; -uadmin -P9066 -padmin</span></span><br></pre></td></tr></table></figure>

<p>创建数据库：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> database @<span class="variable">@shardingnode</span><span class="operator">=</span><span class="string">&#x27;dn$1-6&#x27;</span>;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="提高分库分表架构的可靠性"><a href="#提高分库分表架构的可靠性" class="headerlink" title="提高分库分表架构的可靠性"></a>提高分库分表架构的可靠性</h2><h3 id="复制与分库分表架构的结合"><a href="#复制与分库分表架构的结合" class="headerlink" title="复制与分库分表架构的结合"></a>复制与分库分表架构的结合</h3><p>对于分库分表的数据库来说，如果其中有一个数据库宕机出现问题，那么会导致整个数据库数据的丢失，因此可以考虑为每个数据库配置从节点实现主从复制。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OfTqjH"><img src="https://s1.ax1x.com/2022/05/16/OfTqjH.png" alt="OfTqjH.png"></a></p>
<br>

<h3 id="使用-DBLE-进行读写分离"><a href="#使用-DBLE-进行读写分离" class="headerlink" title="使用 DBLE 进行读写分离"></a>使用 DBLE 进行读写分离</h3><p>DBLE 会分析 SQL 语义，然后将写语句发给主节点，将读语句发给从节点。</p>
<ul>
<li><code>rwSplitMode=0</code> ：直接分发到主实例</li>
<li><code>rwSplitMode=1</code>：读操作必须在所有从实例中均衡</li>
<li><code>rwSplitMode=2</code>：读操作在所有实例中均衡</li>
<li><code>rwSplitMode=3</code>：读操作尽量在所有从实例中均衡</li>
</ul>
<p>此时的架构：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OfHudI"><img src="https://s1.ax1x.com/2022/05/16/OfHudI.png" alt="OfHudI.png"></a></p>
<br>

<h2 id="解决分库分表后性能下降问题"><a href="#解决分库分表后性能下降问题" class="headerlink" title="解决分库分表后性能下降问题"></a>解决分库分表后性能下降问题</h2><h3 id="查询语句中尽量带有拆分字段"><a href="#查询语句中尽量带有拆分字段" class="headerlink" title="查询语句中尽量带有拆分字段"></a>查询语句中尽量带有拆分字段</h3><p>DBLE 是根据拆分字段来判断数据在哪个节点的，若无法判断数据节点则只能遍历全部节点的数据。</p>
<br>

<h3 id="插入语句中必须带有拆分字段"><a href="#插入语句中必须带有拆分字段" class="headerlink" title="插入语句中必须带有拆分字段"></a>插入语句中必须带有拆分字段</h3><p>DBLE 是根据拆分字段来判断数据在哪个节点的，若新数据无拆分字段则无法插入。</p>
<br>

<h3 id="拆分字段尽量等值"><a href="#拆分字段尽量等值" class="headerlink" title="拆分字段尽量等值"></a>拆分字段尽量等值</h3><p>范围拆分字段会导致扫描过多节点，若使用 IN 子句则应缩减 IN 子句值的数量。</p>
<br>

<h3 id="减少表的搜索遍历"><a href="#减少表的搜索遍历" class="headerlink" title="减少表的搜索遍历"></a>减少表的搜索遍历</h3><p>当不带拆分字段时，DISTINCT、GROUP BY、ORDER BY 应尽量少出现，不要同时使用多于一种。</p>
<br>

<h3 id="减少结果集"><a href="#减少结果集" class="headerlink" title="减少结果集"></a>减少结果集</h3><p>在分布式系统中，节点间有大量的数据交互，而数据交互会影响查询性能。过大的结果集会增大数据汇集的网络交互量。</p>
<br>

<h3 id="跨节点连表"><a href="#跨节点连表" class="headerlink" title="跨节点连表"></a>跨节点连表</h3><p>经常使用 JOIN 的表尽量使用相同的拆分规则，尽量使用拆分字段作为 JOIN 的条件，尽量对驱动表添加更多的过滤条件，尽量少使用跨节点排序、分页等功能，尽量将大事务拆成小事务，复杂语句拆分成多条语句。</p>
<br>

<h1 id="如何解决数据库宕机问题"><a href="#如何解决数据库宕机问题" class="headerlink" title="如何解决数据库宕机问题"></a>如何解决数据库宕机问题</h1><h2 id="保业务还是保数据"><a href="#保业务还是保数据" class="headerlink" title="保业务还是保数据"></a>保业务还是保数据</h2><h3 id="如何进行身份切换"><a href="#如何进行身份切换" class="headerlink" title="如何进行身份切换"></a>如何进行身份切换</h3><ol>
<li>停止从库同步</li>
<li>配置主库复制从库</li>
</ol>
<p>身份切换的策略有：可靠性优先策略和可用性优先策略</p>
<br>

<h3 id="可靠性优先策略"><a href="#可靠性优先策略" class="headerlink" title="可靠性优先策略"></a>可靠性优先策略</h3><p>首先需要检查从库 B 库的 <code>Seconds_Behind_Master</code> 参数是否特别大，若不是则将主库 A 库开启只读模式 <code>readonly=true</code>。然后再次检查 B 库的 <code>Seconds_Behind_Master</code> 参数是否等于 0，当等于 0 时则将 B 库的只读模式关闭 <code>readonly=false</code>，再让 B 库停止复制 A 库，让 A 库开始复制 B 库。</p>
<p>特点：</p>
<ul>
<li>数据无丢失</li>
<li>有一段时间内两个数据库均不可写</li>
<li>若一开始未检查  <code>Seconds_Behind_Master</code>  则不可用时间无法控制</li>
</ul>
<br>

<h3 id="可用性优先策略"><a href="#可用性优先策略" class="headerlink" title="可用性优先策略"></a>可用性优先策略</h3><p>可用性优先策略取消了等待数据一致的过程，直接让 A 库只读、B 库关闭只读并让 B 库停止复制 A 库，A 库开始复制 B 库。</p>
<p>特点：</p>
<ul>
<li>系统没有不可写的时间</li>
<li>若切换时还有未重放的 relay log 则可能造成数据不一致的问题</li>
</ul>
<br>

<h3 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h3><p>执行普通业务时尽量使用可靠性优先策略，日志、流水等不太需要数据可靠性的业务使用可用性优先策略。</p>
<br>

<h2 id="数据库切换了业务怎么办"><a href="#数据库切换了业务怎么办" class="headerlink" title="数据库切换了业务怎么办"></a>数据库切换了业务怎么办</h2><h3 id="业务切换至新地址"><a href="#业务切换至新地址" class="headerlink" title="业务切换至新地址"></a>业务切换至新地址</h3><p>可以在业务预留接口，通知新的数据库地址；也可以使用微服务框架通知业务。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OfXJVH"><img src="https://s1.ax1x.com/2022/05/16/OfXJVH.png" alt="OfXJVH.png"></a></p>
<br>

<h3 id="使用内部-DNS-通过域名链接"><a href="#使用内部-DNS-通过域名链接" class="headerlink" title="使用内部 DNS 通过域名链接"></a>使用内部 DNS 通过域名链接</h3><p>通过自己搭建的 CoreDNS 解析域名，当切换完数据库后修改 DNS 域名解析即可。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OfXTZ4"><img src="https://s1.ax1x.com/2022/05/16/OfXTZ4.png" alt="OfXTZ4.png"></a></p>
<br>

<h3 id="VIP-漂移"><a href="#VIP-漂移" class="headerlink" title="VIP 漂移"></a>VIP 漂移</h3><p>使用 Keepalived 实现自动 VIP 漂移。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OfjFJI"><img src="https://s1.ax1x.com/2022/05/16/OfjFJI.png" alt="OfjFJI.png"></a></p>
<br>

<h3 id="使用代理"><a href="#使用代理" class="headerlink" title="使用代理"></a>使用代理</h3><p>使用 HaProxy 等代理组件将转发地址切换至新库。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OfjeOS"><img src="https://s1.ax1x.com/2022/05/16/OfjeOS.png" alt="OfjeOS.png"></a></p>
<br>

<h3 id="使用-DBLE-时的主从切换"><a href="#使用-DBLE-时的主从切换" class="headerlink" title="使用 DBLE 时的主从切换"></a>使用 DBLE 时的主从切换</h3><p>使用 DBLE 等分库分表中间件将数据分片地址切换至新库。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OfjaTJ"><img src="https://s1.ax1x.com/2022/05/16/OfjaTJ.png" alt="OfjaTJ.png"></a></p>
<br>

<h3 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h3><ul>
<li>业务切换至新地址：不影响性能，业务可能不支持</li>
<li>使用内部 DNS：方便，需要多余的硬件资源</li>
<li>VIP 漂移：自动漂移，需要多余的 IP 资源</li>
<li>使用代理：自动更新，需要多余的资源</li>
<li>DBLE：客户端无感知，需要被动通知</li>
</ul>
<br>

<h2 id="实现自动主从切换"><a href="#实现自动主从切换" class="headerlink" title="实现自动主从切换"></a>实现自动主从切换</h2><h3 id="Keepalived"><a href="#Keepalived" class="headerlink" title="Keepalived"></a>Keepalived</h3><p>Keepalived 是集群管理中保证集群高可用的一个服务软件。它可以监测节点的状态自动执行切换脚本来切换负载。</p>
<p>可以使用 Keepalived 进行身份切换 + VIP 漂移。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OfjFJI"><img src="https://s1.ax1x.com/2022/05/16/OfjFJI.png" alt="OfjFJI.png"></a></p>
<br>

<h3 id="MHA-Master-High-Availability"><a href="#MHA-Master-High-Availability" class="headerlink" title="MHA(Master High Availability)"></a>MHA(Master High Availability)</h3><p>MHA是一款成熟且开源的 MySQ L高可用程序，它实现了 MySQL 主从环境下 MASTER 宕机后能够自动进行单次故障转移的功能，其本身由perl语言编写，安装方便使用简单。MHA 支持 GTID 方式，它可以在 Binlog 来不及传送时会尝试登录 A 库传送 Binlog，但 MHA 不能自动漂移 VIP。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Ofx5sf"><img src="https://s1.ax1x.com/2022/05/16/Ofx5sf.png" alt="Ofx5sf.png"></a></p>
<p>当主库宕机后，MHA 会从宕机崩溃的 Master 中抢救还未传送的 Binlog，等待 Slave 执行中继日志追赶 Master，然后在 Slave 执行从 Master 中抢救出的 Binlog，再根据算法提升一个 Slave 成为新的 Master，使用其他 Slave 连接新的 Master 进行复制，同时旧的已宕机主库信息将会从 Manager 项目配置文件中移除。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Ofz6XV"><img src="https://s1.ax1x.com/2022/05/16/Ofz6XV.png" alt="Ofz6XV.png"></a></p>
<p>至此整个 MHA 软件服务结束，Manager 不会再对 Node 进行管理，接下来需要管理员手动对已宕机主库进行排查恢复，并且手动搭建旧主库与新主库之间的主从关系然后重新启动整个 MHA 服务。</p>
<br>

<h3 id="MHA-与-DBLE-联动"><a href="#MHA-与-DBLE-联动" class="headerlink" title="MHA 与 DBLE 联动"></a>MHA 与 DBLE 联动</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OhSm3n"><img src="https://s1.ax1x.com/2022/05/16/OhSm3n.png" alt="OhSm3n.png"></a></p>
<br>

<h2 id="实现高可用集群还是会挂"><a href="#实现高可用集群还是会挂" class="headerlink" title="实现高可用集群还是会挂"></a>实现高可用集群还是会挂</h2><h3 id="DRDS-Distributed-Relational-Database-Service"><a href="#DRDS-Distributed-Relational-Database-Service" class="headerlink" title="DRDS(Distributed Relational Database Service)"></a>DRDS(Distributed Relational Database Service)</h3><p>在 MHA 与 DBLE 的架构中仍有单点问题：DBLE。若 DBLE 服务宕机那么也会导致整个服务不可用。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OhpYdS"><img src="https://s1.ax1x.com/2022/05/16/OhpYdS.png" alt="OhpYdS.png"></a></p>
<p>这样我们很容易就能想到可以冗余布置 DBLE 服务：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Ohp2i4"><img src="https://s1.ax1x.com/2022/05/16/Ohp2i4.png" alt="Ohp2i4.png"></a></p>
<p>布置多台 DBLE 服务，每个 DBLE 都做相同的配置。但这样布置造成 DBLE 集群之间元数据的同步问题，客户端连接某个 DBLE 进行建表的配置对于其他 DBLE 来说是不可知的，这样就会造成 DBLE 配置不同的问题。为了解决这个问题 DBLE 使用了 Zookeeper：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Oh9vh4"><img src="https://s1.ax1x.com/2022/05/16/Oh9vh4.png" alt="Oh9vh4.png"></a></p>
<p>Zookeeper 可以保存元数据，在保存数据量不大时 Zookeeper 自己也能做到高可用。这样就不需要 DBLE 如何进行主从复制，当遇到任何与元数据相关的问题都可以从 Zookeeper 中拉取。</p>
<p>同时还需要考虑的问题是 DBLE 如何进行负载均衡。对于 Client 来说可以进行人为的负载均衡，而对于 MHA Manager 来说它只能配置连接一个 DBLE，当该 DBLE 宕机故障时 MHA Manager 就无法找到其他的 DBLE 服务器了，因此可以为 DBLE 配置 VIP 并使用 Keepalived 实现自动切换的功能：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OhPtIO"><img src="https://s1.ax1x.com/2022/05/16/OhPtIO.png" alt="OhPtIO.png"></a></p>
<p>Client 与 MHA Manager 都能够连接 VIP，当当前连接的 DBLE 宕机时，其他 DBLE 会选择一个优先级高的 DBLE 赋予VIP，这样 Client 与 MHA Manger 就能够在不知不觉中切换了 DBLE。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OhP7wV"><img src="https://s1.ax1x.com/2022/05/16/OhP7wV.png" alt="OhP7wV.png"></a></p>
<p>但对于 Client 来说，若所有的业务都连接同一个 DBLE 会导致 DBLE 负载过大而容易宕机。因此可以考虑使用云服务厂商提供的 SLB 或使用 Haproxy 等负载均衡服务：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Ohi0tU"><img src="https://s1.ax1x.com/2022/05/16/Ohi0tU.png" alt="Ohi0tU.png"></a></p>
<p>这样就解决了负载均衡的问题。若不使用 SLB 我们还需要解决 Haproxy 等负载均衡服务单点故障的问题，可以通过冗余部署与 Keepalived 结合的方式：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Ohiv4S"><img src="https://s1.ax1x.com/2022/05/16/Ohiv4S.png" alt="Ohiv4S.png"></a></p>
<p>为了进一步实现三高架构，还可以实现读写分离（粗线写细线读）：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OhFlHx"><img src="https://s1.ax1x.com/2022/05/16/OhFlHx.png" alt="OhFlHx.png"></a></p>
<p>这样就达成了我们追求的<strong>高并发、高性能、高可用的分布式 MySQL 集群</strong>。</p>
<br>

<h3 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h3><ul>
<li>DBLE 的单点问题可能造成数据库系统无法使用</li>
<li>DBLE 变为多节点后，数据协调可以使用 Zookeeper</li>
<li>多节点 DBLE 可以使用 Keepalived 提供统一 VIP 或者使用负载均衡</li>
<li>至此，三高分布式数据库系统已经初具规模</li>
</ul>
<br>


    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>Buy me a coffee</div>
  <button onclick="document.querySelector('.post-reward').classList.toggle('active');">
    Donate
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="Ssssv11 WeChat Pay">
        <span>WeChat Pay</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/MySQL/" rel="tag"># MySQL</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/05/02/SpringCloud/" rel="prev" title="Spring Cloud">
                  <i class="fa fa-chevron-left"></i> Spring Cloud
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/05/18/JUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7/" rel="next" title="JUC并发工具">
                  JUC并发工具 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ssssv11</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/local-search.js"></script>






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
