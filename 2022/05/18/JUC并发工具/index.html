<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="baidu-site-verification" content="code-jbS6cVmQ2r">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.lug.ustc.edu.cn/css?family=JetBrains+Mono:300,300italic,400,400italic,700,700italic%7CFira+Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ssssv11.github.io","root":"/","images":"/images","scheme":"Pisces","version":"8.2.2","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"manual"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="JUC并发工具">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC并发工具">
<meta property="og:url" content="https://ssssv11.github.io/2022/05/18/JUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7/index.html">
<meta property="og:site_name" content="Ssssv">
<meta property="og:description" content="JUC并发工具">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/18/OoXzUU.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/18/Ooxi0x.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/18/OTQICF.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/18/O7SZuj.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/19/ObCXJ1.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/20/OLLRLd.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/14/bOE9cd.jpg">
<meta property="og:image" content="https://s2.loli.net/2022/03/25/usjpfJ9Id5OUHlK.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/21/OjaKns.md.png">
<meta property="og:image" content="https://s2.loli.net/2022/03/25/hnHQdtLoxcOpUjE.png">
<meta property="og:image" content="https://s1.imagehub.cc/images/2022/03/09/e1fe9925bc315c6034a8da4d73e1dc1349540923d94a.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/23/XppRc4.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/23/Xp9orj.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/23/XpCcy4.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/23/XpPFmj.png">
<meta property="og:image" content="https://s2.loli.net/2022/03/25/9a4rnUBTj6ZQJwW.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/25/XkVF4U.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/26/XELtXD.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/26/XEjFkd.png">
<meta property="article:published_time" content="2022-05-18T06:23:37.812Z">
<meta property="article:modified_time" content="2022-09-27T10:12:20.407Z">
<meta property="article:author" content="Ssssv11">
<meta property="article:tag" content="JavaSE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s1.ax1x.com/2022/05/18/OoXzUU.png">


<link rel="canonical" href="https://ssssv11.github.io/2022/05/18/JUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>
<title>JUC并发工具 | Ssssv</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Ssssv</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">26</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">44</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-%E2%80%94-%E5%88%86%E7%B1%BB"><span class="nav-number">1.</span> <span class="nav-text">并发工具类 — 分类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BA%86%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%88%E4%BB%8E%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%9D%A5%E5%88%86%E7%B1%BB%EF%BC%89"><span class="nav-number">1.1.</span> <span class="nav-text">为了线程安全（从底层原理来分类）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5"><span class="nav-number">1.1.1.</span> <span class="nav-text">互斥同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5"><span class="nav-number">1.1.2.</span> <span class="nav-text">非互斥同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E4%B8%8E%E9%9D%9E%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5%E7%BB%93%E5%90%88"><span class="nav-number">1.1.3.</span> <span class="nav-text">互斥与非互斥同步结合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88"><span class="nav-number">1.1.4.</span> <span class="nav-text">无同步方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BA%86%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%88%E4%BB%8E%E4%BD%BF%E7%94%A8%E8%80%85%E8%A7%92%E5%BA%A6%E5%88%86%E7%B1%BB%EF%BC%89"><span class="nav-number">1.2.</span> <span class="nav-text">为了线程安全（从使用者角度分类）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BA%86%E6%96%B9%E4%BE%BF%E7%AE%A1%E7%90%86%E7%BA%BF%E7%A8%8B%E3%80%81%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87"><span class="nav-number">1.3.</span> <span class="nav-text">为了方便管理线程、提高效率</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3%E7%B1%BB"><span class="nav-number">1.3.1.</span> <span class="nav-text">线程池相关类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%BD%E8%8E%B7%E5%8F%96%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="nav-number">1.3.2.</span> <span class="nav-text">能获取子线程的运行结果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BA%86%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E9%85%8D%E5%90%88%E6%9D%A5%E6%BB%A1%E8%B6%B3%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91"><span class="nav-number">1.4.</span> <span class="nav-text">为了线程之间配合来满足业务逻辑</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">2.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.1.</span> <span class="nav-text">线程池的介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">2.1.1.</span> <span class="nav-text">什么是线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">2.1.2.</span> <span class="nav-text">为什么需要线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E5%90%88%E5%BA%94%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%9C%BA%E5%90%88"><span class="nav-number">2.1.3.</span> <span class="nav-text">适合应用线程池的场合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">2.2.</span> <span class="nav-text">线程池构造函数的参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#corePoolSize-%E4%B8%8E-maxPoolSize"><span class="nav-number">2.2.1.</span> <span class="nav-text">corePoolSize 与 maxPoolSize</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B7%BB%E5%8A%A0%E8%A7%84%E5%88%99"><span class="nav-number">2.2.2.</span> <span class="nav-text">线程添加规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A2%9E%E5%87%8F%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">2.2.3.</span> <span class="nav-text">增减线程的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#keepAliveTime"><span class="nav-number">2.2.4.</span> <span class="nav-text">keepAliveTime</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadFactory"><span class="nav-number">2.2.5.</span> <span class="nav-text">ThreadFactory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#workQueue"><span class="nav-number">2.2.6.</span> <span class="nav-text">workQueue</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%89%8B%E5%8A%A8%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA"><span class="nav-number">2.3.</span> <span class="nav-text">线程池的手动创建与自动创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FixedThreadPool"><span class="nav-number">2.3.1.</span> <span class="nav-text">FixedThreadPool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SingleThreadExecutor"><span class="nav-number">2.3.2.</span> <span class="nav-text">SingleThreadExecutor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CachedThreadPool"><span class="nav-number">2.3.3.</span> <span class="nav-text">CachedThreadPool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ScheduledThreadPool"><span class="nav-number">2.3.4.</span> <span class="nav-text">ScheduledThreadPool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WorkStealingPool"><span class="nav-number">2.3.5.</span> <span class="nav-text">WorkStealingPool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E7%A1%AE%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">2.3.6.</span> <span class="nav-text">正确创建线程池的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">2.4.</span> <span class="nav-text">停止线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#shutdown"><span class="nav-number">2.4.1.</span> <span class="nav-text">shutdown</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#isShutdown"><span class="nav-number">2.4.2.</span> <span class="nav-text">isShutdown</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#isTerminated"><span class="nav-number">2.4.3.</span> <span class="nav-text">isTerminated</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#awaitTermination"><span class="nav-number">2.4.4.</span> <span class="nav-text">awaitTermination</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shutdownNow"><span class="nav-number">2.4.5.</span> <span class="nav-text">shutdownNow</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="nav-number">2.5.</span> <span class="nav-text">拒绝策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%92%E7%BB%9D%E6%97%B6%E6%9C%BA"><span class="nav-number">2.5.1.</span> <span class="nav-text">拒绝时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AbortPolicy"><span class="nav-number">2.5.2.</span> <span class="nav-text">AbortPolicy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DiscardPolicy"><span class="nav-number">2.5.3.</span> <span class="nav-text">DiscardPolicy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DiscardOldestPolicy"><span class="nav-number">2.5.4.</span> <span class="nav-text">DiscardOldestPolicy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CallerRunsPolicy"><span class="nav-number">2.5.5.</span> <span class="nav-text">CallerRunsPolicy</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0"><span class="nav-number">2.6.</span> <span class="nav-text">钩子函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">2.7.</span> <span class="nav-text">线程池的状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Executor-%E5%AE%B6%E6%97%8F"><span class="nav-number">2.8.</span> <span class="nav-text">Executor 家族</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Executor"><span class="nav-number">2.8.1.</span> <span class="nav-text">Executor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ExecutorService"><span class="nav-number">2.8.2.</span> <span class="nav-text">ExecutorService</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AbstractExecutorService"><span class="nav-number">2.8.3.</span> <span class="nav-text">AbstractExecutorService</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadPoolExecutor"><span class="nav-number">2.8.4.</span> <span class="nav-text">ThreadPoolExecutor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Executors"><span class="nav-number">2.8.5.</span> <span class="nav-text">Executors</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%A4%8D%E7%94%A8%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">2.8.6.</span> <span class="nav-text">线程池实现线程复用的原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">2.9.</span> <span class="nav-text">使用线程池的注意事项</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">3.</span> <span class="nav-text">ThreadLocal</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal-%E7%9A%84%E4%B8%A4%E5%A4%A7%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.1.</span> <span class="nav-text">ThreadLocal 的两大使用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%8F%E4%B8%AA%E7%BA%BF%E7%A8%8B%E9%83%BD%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AA%E7%8B%AC%E4%BA%AB%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.1.1.</span> <span class="nav-text">每个线程都需要一个独享对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E9%9C%80%E8%A6%81%E8%A2%AB%E7%BA%BF%E7%A8%8B%E5%86%85%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E5%85%B1%E4%BA%AB"><span class="nav-number">3.1.2.</span> <span class="nav-text">当前用户信息需要被线程内所有方法共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.1.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal-%E5%8E%9F%E7%90%86"><span class="nav-number">3.2.</span> <span class="nav-text">ThreadLocal 原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.1.</span> <span class="nav-text">主要方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#T-get"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">T get()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#T-setInitialValue"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">T  setInitialValue()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#void-set-T-t"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">void set(T t)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#void-remove"><span class="nav-number">3.2.1.4.</span> <span class="nav-text">void remove()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocalMap"><span class="nav-number">3.2.2.</span> <span class="nav-text">ThreadLocalMap</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98"><span class="nav-number">3.3.</span> <span class="nav-text">内存泄漏问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">4.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Lock-%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.1.</span> <span class="nav-text">Lock 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-Lock"><span class="nav-number">4.1.1.</span> <span class="nav-text">为什么需要 Lock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lock-%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="nav-number">4.1.2.</span> <span class="nav-text">Lock 的主要方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">4.2.</span> <span class="nav-text">锁的分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BF%9D%E8%AF%81"><span class="nav-number">4.3.</span> <span class="nav-text">锁的可见性保证</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">4.3.1.</span> <span class="nav-text">volatile关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hanpens-before-%E5%8E%9F%E5%88%99"><span class="nav-number">4.3.2.</span> <span class="nav-text">hanpens-before 原则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="nav-number">4.4.</span> <span class="nav-text">乐观锁和悲观锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">4.4.1.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%92%8C%E9%9D%9E%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="nav-number">4.5.</span> <span class="nav-text">可重入锁和非可重入锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E8%AF%86%E6%BA%90%E7%A0%81"><span class="nav-number">4.5.1.</span> <span class="nav-text">初识源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReetrantLock-%E6%96%B9%E6%B3%95"><span class="nav-number">4.5.2.</span> <span class="nav-text">ReetrantLock 方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-number">4.6.</span> <span class="nav-text">公平锁和非公平锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%94%E7%A4%BA%E5%85%AC%E5%B9%B3%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">4.6.1.</span> <span class="nav-text">演示公平与非公平的情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">4.6.2.</span> <span class="nav-text">优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E8%AF%86%E6%BA%90%E7%A0%81-1"><span class="nav-number">4.6.3.</span> <span class="nav-text">初识源码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E6%8E%92%E4%BB%96%E9%94%81"><span class="nav-number">4.7.</span> <span class="nav-text">共享锁和排他锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">4.7.1.</span> <span class="nav-text">读写锁的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E8%A7%84%E5%88%99"><span class="nav-number">4.7.2.</span> <span class="nav-text">读写锁的规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E6%BC%94%E7%A4%BA"><span class="nav-number">4.7.3.</span> <span class="nav-text">读写锁演示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E6%8F%92%E9%98%9F%E7%AD%96%E7%95%A5"><span class="nav-number">4.7.4.</span> <span class="nav-text">读写锁的插队策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E8%AF%86%E6%BA%90%E7%A0%81-2"><span class="nav-number">4.7.5.</span> <span class="nav-text">初识源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7%E5%92%8C%E9%99%8D%E7%BA%A7"><span class="nav-number">4.7.6.</span> <span class="nav-text">锁的升级和降级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">4.7.7.</span> <span class="nav-text">常见问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E9%98%BB%E5%A1%9E%E9%94%81"><span class="nav-number">4.8.</span> <span class="nav-text">自旋锁和阻塞锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">4.8.1.</span> <span class="nav-text">自旋锁的缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E8%AF%86%E6%BA%90%E7%A0%81-3"><span class="nav-number">4.8.2.</span> <span class="nav-text">初识源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">4.8.3.</span> <span class="nav-text">适用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%94%81"><span class="nav-number">4.9.</span> <span class="nav-text">可中断锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E4%BC%98%E5%8C%96"><span class="nav-number">4.10.</span> <span class="nav-text">锁优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">4.10.1.</span> <span class="nav-text">Java 虚拟机对锁的优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81%E6%97%B6%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E9%94%81"><span class="nav-number">4.10.2.</span> <span class="nav-text">编写代码时如何优化锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="nav-number">5.</span> <span class="nav-text">原子类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">5.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E5%A4%A7%E7%B1%BB%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="nav-number">5.2.</span> <span class="nav-text">6 大类原子类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="nav-number">5.3.</span> <span class="nav-text">基本类型原子类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">5.3.1.</span> <span class="nav-text">常用方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="nav-number">5.4.</span> <span class="nav-text">数组类型原子类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="nav-number">5.5.</span> <span class="nav-text">引用类型原子类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%87%E7%BA%A7%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="nav-number">5.6.</span> <span class="nav-text">升级类型原子类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">5.6.1.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%AF%E5%8A%A0%E5%99%A8"><span class="nav-number">5.7.</span> <span class="nav-text">累加器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Adder-%E7%B4%AF%E5%8A%A0%E5%99%A8"><span class="nav-number">5.7.1.</span> <span class="nav-text">Adder 累加器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">5.7.1.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sum-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">5.7.1.2.</span> <span class="nav-text">sum() 源码分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-number">5.7.1.3.</span> <span class="nav-text">适用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Accumulator-%E7%B4%AF%E5%8A%A0%E5%99%A8"><span class="nav-number">5.7.2.</span> <span class="nav-text">Accumulator 累加器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CAS"><span class="nav-number">6.</span> <span class="nav-text">CAS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="nav-number">6.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAS-%E7%AD%89%E4%BB%B7%E4%BB%A3%E7%A0%81"><span class="nav-number">6.2.</span> <span class="nav-text">CAS 等价代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">6.3.</span> <span class="nav-text">应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">6.3.1.</span> <span class="nav-text">CAS 实现原子操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAS-%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">6.4.</span> <span class="nav-text">CAS 的缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ABA-%E9%97%AE%E9%A2%98"><span class="nav-number">6.4.1.</span> <span class="nav-text">ABA 问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E6%97%B6%E9%97%B4%E9%95%BF%E5%BC%80%E9%94%80%E5%A4%A7"><span class="nav-number">6.4.1.1.</span> <span class="nav-text">循环时间长开销大</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AA%E8%83%BD%E4%BF%9D%E8%AF%81%E4%B8%80%E4%B8%AA%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">6.4.2.</span> <span class="nav-text">只能保证一个共享变量的原子操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#final-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E4%B8%8D%E5%8F%98%E6%80%A7"><span class="nav-number">7.</span> <span class="nav-text">final 关键字与不变性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%8F%98%E6%80%A7-Immutable"><span class="nav-number">7.1.</span> <span class="nav-text">不变性(Immutable)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">7.2.</span> <span class="nav-text">final 的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final-%E7%9A%84%E4%B8%89%E7%A7%8D%E7%94%A8%E6%B3%95"><span class="nav-number">7.3.</span> <span class="nav-text">final 的三种用法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#final-%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F"><span class="nav-number">7.3.1.</span> <span class="nav-text">final 修饰变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final-%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95"><span class="nav-number">7.3.2.</span> <span class="nav-text">final 修饰方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final-%E4%BF%AE%E9%A5%B0%E7%B1%BB"><span class="nav-number">7.3.3.</span> <span class="nav-text">final 修饰类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%8F%98%E6%80%A7%E4%B8%8E-final-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">7.4.</span> <span class="nav-text">不变性与 final 的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E5%B0%81%E9%97%AD"><span class="nav-number">7.4.1.</span> <span class="nav-text">栈封闭</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">7.5.</span> <span class="nav-text">面试题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="nav-number">8.</span> <span class="nav-text">并发容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">8.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentHashMap"><span class="nav-number">8.2.</span> <span class="nav-text">ConcurrentHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Map"><span class="nav-number">8.2.1.</span> <span class="nav-text">Map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap"><span class="nav-number">8.2.2.</span> <span class="nav-text">HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap-%E7%BB%93%E6%9E%84"><span class="nav-number">8.2.2.1.</span> <span class="nav-text">HashMap 结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap-%E5%85%B3%E4%BA%8E%E5%B9%B6%E5%8F%91%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">8.2.2.2.</span> <span class="nav-text">HashMap 关于并发的特点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap-1"><span class="nav-number">8.2.3.</span> <span class="nav-text">ConcurrentHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentHashMap-%E7%BB%93%E6%9E%84"><span class="nav-number">8.2.3.1.</span> <span class="nav-text">ConcurrentHashMap 结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-8-%E8%BE%83-1-7-%E7%9A%84%E5%8D%87%E7%BA%A7"><span class="nav-number">8.2.3.2.</span> <span class="nav-text">1.8 较 1.7 的升级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98"><span class="nav-number">8.2.3.3.</span> <span class="nav-text">组合操作问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CopyOnWriteArrayList"><span class="nav-number">8.3.</span> <span class="nav-text">CopyOnWriteArrayList</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E8%A7%84%E5%88%99"><span class="nav-number">8.3.1.</span> <span class="nav-text">读写规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">8.3.2.</span> <span class="nav-text">实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-number">8.3.3.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">8.3.4.</span> <span class="nav-text">源码分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97"><span class="nav-number">8.4.</span> <span class="nav-text">并发队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BlockingQueue"><span class="nav-number">8.4.1.</span> <span class="nav-text">BlockingQueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BlockingQueue-%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="nav-number">8.4.2.</span> <span class="nav-text">BlockingQueue 主要方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayBlockingQueue"><span class="nav-number">8.4.3.</span> <span class="nav-text">ArrayBlockingQueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedBlockingQueue"><span class="nav-number">8.4.4.</span> <span class="nav-text">LinkedBlockingQueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PriorityBlockingQueue"><span class="nav-number">8.4.5.</span> <span class="nav-text">PriorityBlockingQueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SynchronousQueue"><span class="nav-number">8.4.6.</span> <span class="nav-text">SynchronousQueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DelayQueue"><span class="nav-number">8.4.7.</span> <span class="nav-text">DelayQueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E9%98%9F%E5%88%97"><span class="nav-number">8.4.8.</span> <span class="nav-text">选择合适的队列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">9.</span> <span class="nav-text">并发流程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="nav-number">9.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CountDownLatch"><span class="nav-number">9.2.</span> <span class="nav-text">CountDownLatch</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95-1"><span class="nav-number">9.2.1.</span> <span class="nav-text">主要方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E7%94%A8%E6%B3%95"><span class="nav-number">9.2.2.</span> <span class="nav-text">典型用法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Semaphore"><span class="nav-number">9.3.</span> <span class="nav-text">Semaphore</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95-2"><span class="nav-number">9.3.1.</span> <span class="nav-text">主要方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="nav-number">9.3.2.</span> <span class="nav-text">使用流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Condition-%E6%8E%A5%E5%8F%A3"><span class="nav-number">9.4.</span> <span class="nav-text">Condition 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95-3"><span class="nav-number">9.4.1.</span> <span class="nav-text">主要方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CyclicBarrier"><span class="nav-number">9.5.</span> <span class="nav-text">CyclicBarrier</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CyclicBarrier-%E5%92%8C-CountDownLatch-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">9.5.1.</span> <span class="nav-text">CyclicBarrier 和 CountDownLatch 的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AQS"><span class="nav-number">10.</span> <span class="nav-text">AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="nav-number">10.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86"><span class="nav-number">10.2.</span> <span class="nav-text">AQS 内部原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#state-%E7%8A%B6%E6%80%81"><span class="nav-number">10.2.1.</span> <span class="nav-text">state 状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FIFO-%E9%98%9F%E5%88%97"><span class="nav-number">10.2.2.</span> <span class="nav-text">FIFO 队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96-x2F-%E9%87%8A%E6%94%BE%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">10.2.3.</span> <span class="nav-text">获取&#x2F;释放的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS-%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="nav-number">10.3.</span> <span class="nav-text">AQS 应用实例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS-%E6%BA%90%E7%A0%81"><span class="nav-number">10.3.1.</span> <span class="nav-text">AQS 源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CountDownLatch-1"><span class="nav-number">10.3.2.</span> <span class="nav-text">CountDownLatch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Semaphore-1"><span class="nav-number">10.3.3.</span> <span class="nav-text">Semaphore</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">10.3.4.</span> <span class="nav-text">ReentrantLock</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A9%E7%94%A8-AQS-%E5%AE%9E%E7%8E%B0-Latch"><span class="nav-number">10.4.</span> <span class="nav-text">利用 AQS 实现 Latch</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Future-%E4%B8%8E-Callable"><span class="nav-number">11.</span> <span class="nav-text">Future 与 Callable</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Runnable-%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="nav-number">11.1.</span> <span class="nav-text">Runnable 的缺陷</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E8%83%BD%E6%8B%BF%E5%88%B0%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C"><span class="nav-number">11.1.0.1.</span> <span class="nav-text">不能拿到任务的返回结果</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E8%83%BD%E6%8A%9B%E5%87%BA-checked-Exception"><span class="nav-number">11.1.0.2.</span> <span class="nav-text">不能抛出 checked Exception</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E8%BF%99%E6%A0%B7%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="nav-number">11.1.0.3.</span> <span class="nav-text">为什么有这样的缺陷</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%BE%E8%AE%A1%E6%88%90%E8%BF%99%E6%A0%B7"><span class="nav-number">11.1.0.4.</span> <span class="nav-text">为什么设计成这样</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Callable-%E6%8E%A5%E5%8F%A3"><span class="nav-number">11.1.1.</span> <span class="nav-text">Callable 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Callable-%E5%92%8C-Runnable-%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="nav-number">11.1.2.</span> <span class="nav-text">Callable 和 Runnable 的不同之处</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Future"><span class="nav-number">11.2.</span> <span class="nav-text">Future</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Future-%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="nav-number">11.2.1.</span> <span class="nav-text">Future 的主要方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="nav-number">11.2.2.</span> <span class="nav-text">方法示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84-submit-%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E-Future-%E5%AF%B9%E8%B1%A1"><span class="nav-number">11.2.2.1.</span> <span class="nav-text">线程池的 submit() 方法返回 Future 对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FutureTask-%E5%88%9B%E5%BB%BA-Future"><span class="nav-number">11.2.2.2.</span> <span class="nav-text">FutureTask 创建 Future</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%93%E9%80%A0%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98"><span class="nav-number">12.</span> <span class="nav-text">打造高性能缓存</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ssssv11"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">Ssssv11</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTE=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Ssssv11"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ssssv11.github.io/2022/05/18/JUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="Ssssv11">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ssssv">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JUC并发工具
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-05-18 14:23:37" itemprop="dateCreated datePublished" datetime="2022-05-18T14:23:37+08:00">2022-05-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-09-27 18:12:20" itemprop="dateModified" datetime="2022-09-27T18:12:20+08:00">2022-09-27</time>
      </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <center>JUC并发工具</center>

<span id="more"></span>

<h1 id="并发工具类-—-分类"><a href="#并发工具类-—-分类" class="headerlink" title="并发工具类 — 分类"></a>并发工具类 — 分类</h1><ol>
<li>为了并发安全：互斥同步、非互斥同步、无同步方案</li>
<li>管理线程、提高效率</li>
<li>线程协作</li>
</ol>
<br>

<h2 id="为了线程安全（从底层原理来分类）"><a href="#为了线程安全（从底层原理来分类）" class="headerlink" title="为了线程安全（从底层原理来分类）"></a>为了线程安全（从底层原理来分类）</h2><h3 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h3><p><strong>使用各种互斥同步的锁：</strong></p>
<ul>
<li>synchronized</li>
<li>ReentrantLook</li>
<li>ReadWriteLock</li>
</ul>
<p><strong>使用同步的工具类：</strong></p>
<ul>
<li><code>Collections.synchronizedList(new ArrayList&lt;E&gt;(())</code> 等</li>
<li>Vector 等<br></li>
</ul>
<h3 id="非互斥同步"><a href="#非互斥同步" class="headerlink" title="非互斥同步"></a>非互斥同步</h3><p><strong>基本类型原子类</strong></p>
<ul>
<li><code>AtomicInteger</code>：整型原子类</li>
<li><code>AtomicLong</code>：长整型原子类</li>
<li><code>AtomicBoolean</code>：布尔型原子类</li>
</ul>
<p><strong>数组类型原子类</strong><br>数组中的元素都可以保证原子性：</p>
<ul>
<li><code>AtomicIntegerArray</code>：整型数组原子类</li>
<li><code>AtomicLongArray</code>：长整型数组原子类</li>
<li><code>AtomicReferenceArray</code>：引用类型数组原子类</li>
</ul>
<p><strong>引用类型原子类</strong></p>
<ul>
<li><code>AtomicReference</code>：引用类型原子类</li>
<li><code>AtomicStamped Reference</code>：引用类型原子类的升级，带时间戳，可以解决 ABA 问题</li>
<li><code>AtomicMarkableReference</code>-</li>
</ul>
<p><strong>升级原子类</strong></p>
<ul>
<li><code>AtomicIntegerFieldUpdater</code>：原子更新整型字段的更新器</li>
<li><code>AtomicLongFieldUpdater</code>：原子更新长整型字段的更新器</li>
</ul>
<p><strong>加法器</strong></p>
<ul>
<li><code>LongAdder</code></li>
<li><code>DoubleAdder</code></li>
</ul>
<p><strong>累加器</strong></p>
<ul>
<li><code>LongAccumulator</code></li>
<li><code>DoubleAccumulator</code><br></li>
</ul>
<h3 id="互斥与非互斥同步结合"><a href="#互斥与非互斥同步结合" class="headerlink" title="互斥与非互斥同步结合"></a>互斥与非互斥同步结合</h3><p>线程安全的并发容器：</p>
<ul>
<li><p>ConcurrentHashMap</p>
</li>
<li><p>CopyOnWriteArrayList</p>
</li>
<li><p>并发队列</p>
<p>  阻塞队列</p>
<ul>
<li>ArrayBlockingQueue</li>
<li>Linked BlockingQuwue</li>
<li>PriorityBlockingQueue</li>
<li>SynchronousQueue</li>
<li>DelayedQueue</li>
<li>TransferQueue</li>
</ul>
<p>  非阻塞队列</p>
<ul>
<li>ConcurrentLinkedQueue</li>
<li>ConcurrentSkipListMap 和  ConcurrentSkipListSet</li>
</ul>
</li>
</ul>
<br>

<h3 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h3><ul>
<li>final 关键字</li>
<li>线程封闭<ul>
<li>ThreadLocal</li>
<li>栈封闭</li>
</ul>
</li>
</ul>
<br>

<h2 id="为了线程安全（从使用者角度分类）"><a href="#为了线程安全（从使用者角度分类）" class="headerlink" title="为了线程安全（从使用者角度分类）"></a>为了线程安全（从使用者角度分类）</h2><ul>
<li>避免共享变量<ul>
<li>线程封闭</li>
</ul>
</li>
<li>共享变量但加以限制和处理<ul>
<li>互斥同步</li>
<li>final 关键字</li>
</ul>
</li>
<li>使用成熟的工具类<ul>
<li>线程安全的并发容器</li>
<li>atomic 包，原子类<br></li>
</ul>
</li>
</ul>
<h2 id="为了方便管理线程、提高效率"><a href="#为了方便管理线程、提高效率" class="headerlink" title="为了方便管理线程、提高效率"></a>为了方便管理线程、提高效率</h2><h3 id="线程池相关类"><a href="#线程池相关类" class="headerlink" title="线程池相关类"></a>线程池相关类</h3><ul>
<li>Executor</li>
<li>Executors</li>
<li>ExecutorService</li>
<li>常见线程池<ul>
<li>FixedThreadPool</li>
<li>CachedTreadPool</li>
<li>ScheduledThreadPool</li>
<li>SingleThreadExecutor</li>
<li>ForkJoinPool<br></li>
</ul>
</li>
</ul>
<h3 id="能获取子线程的运行结果"><a href="#能获取子线程的运行结果" class="headerlink" title="能获取子线程的运行结果"></a>能获取子线程的运行结果</h3><ul>
<li>Callable</li>
<li>Future</li>
<li>FutureTask<br></li>
</ul>
<h2 id="为了线程之间配合来满足业务逻辑"><a href="#为了线程之间配合来满足业务逻辑" class="headerlink" title="为了线程之间配合来满足业务逻辑"></a>为了线程之间配合来满足业务逻辑</h2><ul>
<li>CountDownLatch</li>
<li>CyclicBarrier </li>
<li>Semaphore </li>
<li>Condition </li>
<li>Exchanger </li>
<li>Phaser <br></li>
</ul>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="线程池的介绍"><a href="#线程池的介绍" class="headerlink" title="线程池的介绍"></a>线程池的介绍</h2><h3 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h3><p>软件中的“池”可以理解为如计划经济一样。由于线程的创建和销毁对资源的开销很大，因此需要线程池来对线程进行统一分配，需要线程时从线程池中获取线程即可，这样就避免了反复的创建和销毁线程，实现了控制线程总数和线程复用。</p>
<br>

<h3 id="为什么需要线程池"><a href="#为什么需要线程池" class="headerlink" title="为什么需要线程池"></a>为什么需要线程池</h3><p>不使用线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EveryTaskAThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行了任务&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当线程数特别多时可以使用 for 循环来创建线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ManyTaskAThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行了任务&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这样开销太大了，我们希望有固定数量的线程来执行这 1000 个线程，这样就避免了反复创建并销毁线程所带来的开销问题。</p>
<p>线程池能够对线程进行统一分配，调优和监控:</p>
<ul>
<li>降低资源消耗(线程无限制地创建，然后使用完毕后销毁)</li>
<li>提高响应速度(无须创建线程)</li>
<li>提高线程的可管理性</li>
</ul>
<br>

<h3 id="适合应用线程池的场合"><a href="#适合应用线程池的场合" class="headerlink" title="适合应用线程池的场合"></a>适合应用线程池的场合</h3><ul>
<li>服务器接受到大量请求时，使用线程池技术是非常合适的，它可以大大减少线程的创建和销毁次数，提高服务器的工作效率</li>
<li>在开发中，如果需要创建5个以上的线程，就可以使用线程池来管理</li>
</ul>
<br>

<h2 id="线程池构造函数的参数"><a href="#线程池构造函数的参数" class="headerlink" title="线程池构造函数的参数"></a>线程池构造函数的参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.acc = System.getSecurityManager() == <span class="literal">null</span> ?</span><br><span class="line">            <span class="literal">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>int</td>
<td>核心线程数</td>
</tr>
<tr>
<td>maxPoolSize</td>
<td>int</td>
<td>最大线程数</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>long</td>
<td>保持存活时间</td>
</tr>
<tr>
<td>workQueue</td>
<td>BlockingQueue</td>
<td>任务存储队列</td>
</tr>
<tr>
<td>threadFactory</td>
<td>ThreadFactory</td>
<td>当线程池需要新的线程时会使用 threadFactory 来生成新的线程</td>
</tr>
<tr>
<td>Handler</td>
<td>RejectedExecutionHandler</td>
<td>线程池无法接受提交的任务时的拒绝策略</td>
</tr>
<tr>
<td>unit</td>
<td>TimeUnit</td>
<td>keepAliveTime 的时间单位</td>
</tr>
</tbody></table>
<h3 id="corePoolSize-与-maxPoolSize"><a href="#corePoolSize-与-maxPoolSize" class="headerlink" title="corePoolSize 与 maxPoolSize"></a>corePoolSize 与 maxPoolSize</h3><blockquote>
<p>corePoolSize – the number of threads to keep in the pool, even if they are idle, unless allowCoreThreadTimeOut is set<br>maximumPoolSize – the maximum number of threads to allow in the pool</p>
</blockquote>
<p>corePoolSize 指的是核心线程数：线程池完成初始化后，默认情况下线程池中没有任何线程。线程池会等待有任务到来时再创建新线程去执行任务。在任务执行完后即使它们是空闲的也会保留下来(unless allowCoreThreadTimeOut is set)。</p>
<p>同时线程池可能会在核心线程数的基础上额外增加一些线程，而总的线程数具有一个上限，即 maxPoolSize。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OoXzUU"><img data-src="https://s1.ax1x.com/2022/05/18/OoXzUU.png" alt="OoXzUU.png"></a></p>
<br>

<h3 id="线程添加规则"><a href="#线程添加规则" class="headerlink" title="线程添加规则"></a>线程添加规则</h3><ol>
<li>如果线程数小于 corePoolSize，即使其他工作线程都处于空闲状态也会创建一个新的线程来执行新任务。</li>
<li>如果线程数等于(或大于)corePoolSize 但少于 maxPoolSize，则将任务放入任务队列。</li>
<li>如果任务队列已满并且线程数小于 maxPoolSize，则创建一个新的线程来执行任务。</li>
<li>如果任务队列已满并且线程数大于等于 maxPoolSize，则拒绝该任务。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Ooxi0x"><img data-src="https://s1.ax1x.com/2022/05/18/Ooxi0x.png" alt="Ooxi0x.png"></a></p>
<p>因此，是否需要增加线程的判断顺序是：</p>
<ul>
<li>corePoolSize</li>
<li>workQueue</li>
<li>maxPoolSize</li>
</ul>
<br>

<h3 id="增减线程的特点"><a href="#增减线程的特点" class="headerlink" title="增减线程的特点"></a>增减线程的特点</h3><ol>
<li>通过设置 corePoolSize 与 maxPoolSize 数量相同就可以创建一个固定大小的线程池。</li>
<li>线程池希望保持比较少的线程数，且只有在负载变得很大时才增加它。</li>
<li>通过设置 maxPoolSize 为很大值时，如 Integer.MAX_VALUE，那么就可以允许线程池容纳任意数量的并发任务。</li>
<li>只有在队列被填满时才创建多于 corePoolSize 的线程，因此如果使用无界队列，如 LinkedBlockingQueue，那么线程数就不会超过 corePoolSize。</li>
</ol>
<br>

<h3 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h3><blockquote>
<p>When the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating.</p>
</blockquote>
<p>如果线程池当前的线程数多于 corePoolSize，那么多余核心线程数的线程在空闲 keepAliveTime 后将被终止。</p>
<p>对于 keepAliveTime 的单位 TimeUnit：</p>
<ul>
<li>NANOSECONDS</li>
<li>MICROSECONDS</li>
<li>MILLISECONDS</li>
<li>SECONDS</li>
<li>MINUTES</li>
<li>HOURS</li>
<li>DAYS</li>
</ul>
<br>

<h3 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h3><blockquote>
<p> The factory to use when the executor creates a new thread</p>
</blockquote>
<p>新的线程是由 ThreadFactory 创建的，默认使用 Executors.defaultThreadFactory()。</p>
<p>创建出来的线程都在同一个线程组，拥有同样的 NORM_PRIORITY 优先级并且都不是守护线程。如果指定使用某个ThreadFactory 就可以改变线程名、线程组、优先级、是否是守护线程等。</p>
<p>通常情况下使用默认的 ThreadFactory 即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ThreadFactory <span class="title function_">defaultThreadFactory</span><span class="params">()</span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultThreadFactory</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default thread factory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">poolNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">threadNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">    DefaultThreadFactory() &#123;</span><br><span class="line">        <span class="type">SecurityManager</span> <span class="variable">s</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">        group = (s != <span class="literal">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                              Thread.currentThread().getThreadGroup();</span><br><span class="line">        namePrefix = <span class="string">&quot;pool-&quot;</span> +</span><br><span class="line">                      poolNumber.getAndIncrement() +</span><br><span class="line">                     <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(group, r,</span><br><span class="line">                              namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                              <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">            t.setDaemon(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="workQueue"><a href="#workQueue" class="headerlink" title="workQueue"></a>workQueue</h3><blockquote>
<p>The queue to use for holding tasks before they are executed. This queue will hold only the Runnable tasks submitted by the execute method.</p>
</blockquote>
<p>工作队列即线程等待队列，当线程池中无法分配线程执行任务的时候，就会将任务暂时存到等待队列中，直到有线程资源可用为止。</p>
<p>有三种常见的队列：</p>
<ul>
<li><p>直接交接：SynchronousQueue</p>
<p>它的 capacity 为 0，即当任务较少时可以用来简单地作为中转</p>
</li>
<li><p>无界队列：LinkedBlockingQueue</p>
<p>它不会被装满，maxPoolSize 对线程池不会产生影响。因此可以用来应对流量突增的情况。但可能对造成内存浪费或导致 OOM</p>
</li>
<li><p>有界队列：ArrayBlockingQueue</p>
<p>可以设置队列大小。</p>
</li>
</ul>
<br>

<h2 id="线程池的手动创建与自动创建"><a href="#线程池的手动创建与自动创建" class="headerlink" title="线程池的手动创建与自动创建"></a>线程池的手动创建与自动创建</h2><p>手动创建线程池可以让我们更加明确线程池的运行规则，避免资源耗尽的风险。若自动创建（调用 JDK 封装好的构造函数）可能会带来一些问题。</p>
<h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><p>比如创建一个 newFixedThreadPool 传入参数 <code>nThreads</code> 为 5，然后执行一千次任务输出当前线程名称：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FixedThreadPoolTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现就算需要执行 1000 次任务，线程池也一直使用传入的 <code>nThreads</code> 规定的线程数二不会创建新的线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line">  ...</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>在 <code>Executos.newFixedThreadPool</code> 源码中可以看到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它还是使用的 <code>ThreadPoolExecutor</code> 来创建线程池，而传入的 <code>corePoolSize</code> 和 <code>maxPoolSize</code> 都被设置为了我们传入 <code>newFixedThreadPool</code> 中的 <code>nThreads</code>，这样就让线程池的线程数固定下来了。同时它使用了 <code>LinkedBlockingQueue</code> 这个无界队列来作为工作队列，无论多少的任务都可以放在该队列中等待。</p>
<p>因此，由于 <code>LinkedBlockingQueue</code> 是没有容量上限的，所以当请求数越来越多并且无法及时处理完毕时（请求堆积时）容易造成占用大量的内存，可能会导致 OOM。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FixedThreadPoolOOM</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> <span class="title class_">SubThread</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.NullPointerException</span><br><span class="line">	at threadPool.FixedThreadPoolOOM.main(FixedThreadPoolOOM.java:<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<br>

<h3 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><p>只有一个线程的线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleThreadExecutorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的任务都是使用的同一个线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>在 <code>newSingleThreadExecutor</code> 源码中可以看到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它与 <code>FixedThreadPool</code> 相似，只是 <code>corePoolSize</code> 和 <code>maxPoolSize</code> 被设置为了 1，所以这个线程池只有一个线程。</p>
<p>因此，<code>SingleThreadPool</code> 也有可能占用大量内存、导致 OOM 的问题。</p>
<br>

<h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><p><code>CachedThreadPool</code> 即可缓存线程池，它是无界线程池，具有自动回收多余线程的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CachedThreadPoolTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它会根据任务的需要来创建线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">498</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">497</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">495</span></span><br><span class="line">...</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">386</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">469</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">806</span></span><br></pre></td></tr></table></figure>

<p>在它的源码中可以看到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>corePoolSize</code> 为 0，<code>maxPoolSize</code> 为最大整数，<code>keepAliveTime</code> 为 60s，使用 <code>SynchronousQueue</code> 作为工作队列。这样，当有大量任务来临时，<code>SynchronousQueue</code> 会将任务直接交给线程池，每交一个任务线程池就会创建一个新的线程来执行，执行完毕线程空闲 60 秒后线程就失效。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OTQICF"><img data-src="https://s1.ax1x.com/2022/05/18/OTQICF.png" alt="OTQICF.png"></a></p>
<p>对于 <code>CachedThreadPool</code>，它的 <code>maxPoolSize</code> 被设置为了 <code>Integer.MAX_VALUE</code> 也可能会导致创建数量非常多的线程，甚至导致 OOM。</p>
<br>

<h3 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h3><p><code>ScheduledThreadPool</code> 支持定时以及周期性地执行任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledThreadPoolTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledService</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 在指定时间后执行</span></span><br><span class="line">        scheduledService.schedule(<span class="keyword">new</span> <span class="title class_">Task</span>(), <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按一定频率执行</span></span><br><span class="line">        scheduledService.scheduleAtFixedRate(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + LocalTime.now()), <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> <span class="number">17</span>:<span class="number">01</span>:<span class="number">38.501</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> <span class="number">17</span>:<span class="number">01</span>:<span class="number">41.484</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> <span class="number">17</span>:<span class="number">01</span>:<span class="number">44.484</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> <span class="number">17</span>:<span class="number">01</span>:<span class="number">47.480</span></span><br></pre></td></tr></table></figure>

<p>在它源码中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是将 <code>corePoolSize</code> 传入 <code>ScheduledThreadPoolExecutor</code> 构造方法中，它也继承自 <code>ThreadPoolExecutor</code> 类。在创建时将 <code>maxPoolSize</code> 设置为了最大整数，同时工作队列使用了 <code>DelayedWorkQueue</code>。该队列是基于优先队列的延迟队列，是以时间作为比较基准的优先级队列。</p>
<p>因此 <code>ScheduledThreadPool</code> 同样面临着大量占用内存和导致 OOM 的风险。</p>
<br>

<h3 id="WorkStealingPool"><a href="#WorkStealingPool" class="headerlink" title="WorkStealingPool"></a>WorkStealingPool</h3><p><code>WorkStealingPool</code> 是在 JDK 1.8 加入的线程池，与前四种线程池不同，通常来说，当这个任务可以产生子任务（如树的遍历、处理矩阵）时才适合使用这个线程池。这种线程池拥有一定的窃取能力，每一个线程之间会合作，任务会放在线程独有的队列而不是公共的队列中，线程之间会有互相帮助的现象。</p>
<p> 为了提高效率，这种线程池的任务最好不要加锁，因为任务可能被不同的线程执行。由于线程之间会窃取任务，因此不保证执行顺序。</p>
<br>

<h3 id="正确创建线程池的方法"><a href="#正确创建线程池的方法" class="headerlink" title="正确创建线程池的方法"></a>正确创建线程池的方法</h3><p>在前面我们使用 JDK 封装好的线程池的构造方法来创建线程池都会面临一些问题，为了尽量避免这些问题我们应该根据不同的业务场景自己设置线程池的参数。</p>
<p>最重要的是线程池大小的限定，合理地分配大小会使得线程池的执行效率事半功倍：</p>
<p>需要分析业务的类型</p>
<ul>
<li><p><strong>CPU 密集型：</strong>主要是执行计算任务，响应时间很快，CPU 一直在运行，这种任务 CPU 的利用率很高，线程数应该是根据 CPU 核心数来决定，最佳线程数为 CPU 核心数的 1-2 倍。</p>
</li>
<li><p><strong>IO 密集型：</strong>主要是进行 IO 操作，因为执行 IO 操作的时间比较长，如从硬盘读取数据等过程 CPU 会等待 IO 操作，很容易出现空闲状态而导致 CPU 的利用率不高。这种情况可以参考 Brain Goetz 推荐的计算方法：</p>
<p>线程数 &#x3D; CPU 核心数 * (1 + 平均等待时间&#x2F;平均工作时间)</p>
</li>
</ul>
<br>

<h2 id="停止线程池"><a href="#停止线程池" class="headerlink" title="停止线程池"></a>停止线程池</h2><h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><p>它可以安全地关闭一个线程池，调用 <code>shutdown()</code> 方法之后线程池并不是立刻就被关闭，因为这时线程池中可能还有很多任务正在被执行，或是任务队列中有大量正在等待被执行的任务。</p>
<p>线程池会在执行完正在执行的任务和队列中等待的任务后才彻底关闭。</p>
<p>调用 <code>shutdown()</code> 方法后如果还有新的任务被提交，线程池则会根据拒绝策略直接拒绝后续新提交的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShutDownTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        executorService.execute(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.util.concurrent.RejectedExecutionException: Task destroyThreadPool.ShutDownTest$$Lambda$<span class="number">2</span>/<span class="number">999966131</span>@58372a00 rejected from java.util.concurrent.ThreadPoolExecutor@4dd8dc3[Shutting down, <span class="type">pool</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">10</span>, <span class="type">active</span> <span class="variable">threads</span> <span class="operator">=</span> <span class="number">10</span>, <span class="type">queued</span> <span class="variable">tasks</span> <span class="operator">=</span> <span class="number">970</span>, <span class="type">completed</span> <span class="variable">tasks</span> <span class="operator">=</span> <span class="number">20</span>]</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:<span class="number">2063</span>)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:<span class="number">830</span>)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:<span class="number">1379</span>)</span><br><span class="line">	at destroyThreadPool.ShutDownTest.main(ShutDownTest.java:<span class="number">21</span>)</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">9</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>当调用 <code>shutdown()</code> 方法后会发现任务还是在一直执行，但此时若再次提交任务则会抛出 <code>RejectedExecutionException</code>。</p>
<br>

<h3 id="isShutdown"><a href="#isShutdown" class="headerlink" title="isShutdown"></a>isShutdown</h3><p>还可以使用 <code>isShutdown()</code> 方法返回 true 或 false 来判断线程池是否已经开始了关闭工作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(executorService.isShutdown());</span><br><span class="line">executorService.shutdown();</span><br><span class="line">System.out.println(executorService.isShutdown());</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">9</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>如果调用 <code>isShutdown()</code> 方法的返回的结果为 true 并不代表线程池此时已经彻底关闭了，这仅仅代表线程池开始了关闭的流程。也就是说，此时可能线程池中依然有线程在执行任务，队列里也可能有等待被执行的任务。</p>
<br>

<h3 id="isTerminated"><a href="#isTerminated" class="headerlink" title="isTerminated"></a>isTerminated</h3><p>要想得知整个线程池是否已经完全终止可以使用 <code>isTerminated()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(executorService.isShutdown());</span><br><span class="line">executorService.shutdown();</span><br><span class="line">System.out.println(executorService.isShutdown());</span><br><span class="line">System.out.println(executorService.isTerminated());</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">10</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>当它返回 true 时不仅代表线程池已关闭，同时代表线程池中的所有任务都已经都执行完毕了。</p>
<br>

<h3 id="awaitTermination"><a href="#awaitTermination" class="headerlink" title="awaitTermination"></a>awaitTermination</h3><p>它本身并不是用来关闭线程池的，而是主要用来判断线程池状态的。</p>
<p>比如给 <code>awaitTermination</code> 方法传入的参数是 10 秒，那么它就会陷入 10 秒钟的等待，直到发生以下三种情况之一：</p>
<ul>
<li><p>等待期间（包括进入等待状态之前）线程池已关闭并且所有已提交的任务（包括正在执行的和队列中等待的）都执行完毕，相当于线程池已经“终结”了，方法便会返回 true</p>
</li>
<li><p>等待超时时间到后，第一种线程池“终结”的情况始终未发生，方法返回 false</p>
</li>
<li><p>等待期间线程被中断，方法会抛出 <code>InterruptedException</code> 异常</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">executorService.shutdown();</span><br><span class="line">System.out.println(executorService.awaitTermination(<span class="number">3</span>, TimeUnit.SECONDS));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>调用 <code>awaitTermination</code> 方法后当前线程会尝试等待一段指定的时间，如果在等待时间内，线程池已关闭并且内部的任务都执行完毕了，也就是说线程池真正“终结”了，那么方法就返回 true，否则超时返回 fasle。</p>
<br>

<h3 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h3><p>在执行 <code>shutdownNow()</code> 方法之后，首先会给所有线程池中的线程发送 <code>interrupt</code> 中断信号，尝试中断这些任务的执行，然后会将任务队列中正在等待的所有任务转移到一个 List 中并返回，我们可以根据返回的任务 List 来进行一些补救的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShutDownTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;被中断&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        System.out.println(executorService.shutdownNow());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span></span><br><span class="line">...</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">9</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>被中断</span><br><span class="line">...</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>被中断</span><br><span class="line">[destroyThreadPool.ShutDownTest$$Lambda$<span class="number">1</span>/<span class="number">1915318863</span>@7cca494b, destroyThreadPool.ShutDownTest$$Lambda$<span class="number">1</span>/<span class="number">1915318863</span>@7cca494b,</span><br><span class="line"> ...</span><br><span class="line">destroyThreadPool.ShutDownTest$$Lambda$<span class="number">1</span>/<span class="number">1915318863</span>@7cca494b]</span><br></pre></td></tr></table></figure>

<p>不推荐使用这一种方式关闭线程池。</p>
<br>

<h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><h3 id="拒绝时机"><a href="#拒绝时机" class="headerlink" title="拒绝时机"></a>拒绝时机</h3><ol>
<li>当 Executor 关闭后，提交的新任务会被拒绝</li>
<li>当 Executor 对最大线程和工作队列容量的使用有限制且已经饱和时提交的新任务会被拒绝</li>
</ol>
<br>

<h3 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h3><p>当任务添加到线程池中被拒绝时，它将抛出 <code>RejectedExecutionException</code> 异常。（该策略下会直接丢弃任务并抛出 <code>RejectedExecutionException</code> 异常）。</p>
<br>

<h3 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h3><p>当任务添加到线程池中被拒绝时，默认情况下它将丢弃被拒绝的任务。（即该策略下会直接丢弃任务，什么都不做）。</p>
<br>

<h3 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h3><p>当任务添加到线程池中被拒绝时，线程池会放弃等待队列中最旧的未处理任务，然后将被拒绝的任务添加到等待队列中。（该策略下会抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列）</p>
<br>

<h3 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h3><p>不进入线程池执行，在这种方式中，任务将由调用者线程去执行。（用于被拒绝任务的处理程序，它直接在 execute 方法的调用线程中运行被拒绝的任务。如果执行程序已关闭，则会丢弃该任务）。</p>
<br>

<h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h2><p>钩子函数就是一个空方法，预留空方法给具体业务来实现。在设计类时为了增强扩展性，会预留一些执行的机制，便于在实际处理业务的时候进行具体扩展，钩子函数是其中的一种实现方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StoppableThreadPool</span> <span class="keyword">extends</span> <span class="title class_">ThreadPoolExecutor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">unStopped</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isStopped;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StoppableThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize, <span class="type">int</span> maximumPoolSize, <span class="type">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.beforeExecute(t, r);</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isStopped)&#123;</span><br><span class="line">                unStopped.await();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isStopped = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resume</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isStopped = <span class="literal">false</span>;</span><br><span class="line">            unStopped.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">StoppableThreadPool</span> <span class="variable">stoppableThreadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StoppableThreadPool</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            stoppableThreadPool.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;执行了&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        stoppableThreadPool.stop();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程池暂停&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        stoppableThreadPool.resume();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程池恢复&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">执行了</span><br><span class="line">执行了</span><br><span class="line">线程池暂停</span><br><span class="line">线程池恢复</span><br><span class="line">执行了</span><br><span class="line">执行了</span><br></pre></td></tr></table></figure>

<p>钩子函数可以在每个任务执行前后被执行，可以用来进行统计或生成日志。</p>
<br>

<h2 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h2><ul>
<li>RUNNING：接受新任务并处理排队任务。线程池的初始化状态是 RUNNING。</li>
<li>SHUTDOWN：不接受新任务但仍会处理已有的任务。调用线程池的 <code>shutdown()</code> 接口时线程池会由 RUNNING 状态进入 SHUTDOWN 状态。</li>
<li>STOP：不接受新任务也不处理排队任务，会中断正在进行的任务。调用线程池的 <code>shutdownNow()</code> 接口时线程池会由(RUNNING or SHUTDOWN ) 状态进入 STOP状态。</li>
<li>TIDYING：所有任务都已经终止、<code>workerCount()</code> 为 0 时线程池会进入 TIDYING 状态，会运行<code>terminate()</code> 钩子方法。当线程池在 SHUTDOWN 状态，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN 状态进入 TIDYING 状态。当线程池在 STOP 状态，线程池中执行的任务为空时，就会由 STOP 状态 进入 TIDYING 状态。</li>
<li>TERMINATIED：线程池彻底终止就进入 TERMINATED 状态。当线程池在 TIDYING 状态，执行完 <code>terminated()</code> 后，就会由 TIDYING 状态进入 TERMINATED 状态。</li>
</ul>
<h2 id="Executor-家族"><a href="#Executor-家族" class="headerlink" title="Executor 家族"></a>Executor 家族</h2><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/O7SZuj"><img data-src="https://s1.ax1x.com/2022/05/18/O7SZuj.png" alt="O7SZuj.png"></a></p>
<h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>Executor 家族的首长。父接口，其中只有一个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line"><span class="comment">// 在将来的某个时间执行给定的命令</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h3><p>Executor的扩展接口，包含的所有方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动有序关闭，在该关闭中执行先前提交的任务，但不接受任何新任务。如果已经关闭，则调用不会产生任何其他影响。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试停止所有正在执行的任务，暂停正在等待的任务的处理，并返回正在等待执行的任务的列表。</span></span><br><span class="line">List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果该执行程序已关闭，则返回true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isShutdown</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果所有任务在关闭后都已完成，则返回true</span></span><br><span class="line"><span class="comment">// 请注意，除非首先调用shutdown或code shutdownNow，否则isTerminated永远不会是true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isTerminated</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当等待超过设定时间时，会监测 ExecutorService是否已经关闭，若关闭则返回true，否则返回false</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">awaitTermination</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交一个callable任务，并返回一个一个代表任务执行结果的Future</span></span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//当task执行成功的时候future.get()返回result  </span></span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span>;  </span><br><span class="line"></span><br><span class="line"> <span class="comment">//当task执行成功的时候future.get()返回null  </span></span><br><span class="line">Future&lt;?&gt; submit(Runnable task);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量执行任务，并返回执行结果的Future的List。</span></span><br><span class="line"><span class="comment">// 如果在进行此操作时修改了给定的任务集合，则此方法的结果不确定。</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span>  <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量执行任务,并返回执行结果的Future的List。指定超时时间</span></span><br><span class="line"><span class="comment">// 如果操作没有超时，每个任务都会完成。 如果超时，其中一些任务将不会完成。也就拿不到任务的执行结果</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                                  <span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量执行任务,并返回一个执行成功的任何一个执行结果（就是没有抛异常的）</span></span><br><span class="line"><span class="comment">// 在正常或异常返回时，尚未完成的任务将被取消。</span></span><br><span class="line">&lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与它的重载方法一致，只不过加了超时时间</span></span><br><span class="line">&lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                    <span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br></pre></td></tr></table></figure>

<h3 id="AbstractExecutorService"><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a>AbstractExecutorService</h3><p>实现了 ExecutorService 接口并提供了 ExecutorService 执行方法的默认实现。</p>
<h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>继承自 AbstractExecutorService.</p>
<h3 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h3><p>工具类，一般使用它来创建线程池。</p>
<br>

<h3 id="线程池实现线程复用的原理"><a href="#线程池实现线程复用的原理" class="headerlink" title="线程池实现线程复用的原理"></a>线程池实现线程复用的原理</h3><p>主要是依靠相同的线程执行不同的任务来实现的。</p>
<p><code>execute()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">  <span class="comment">// 如果工作线程小于corePoolSize，则尝试以给定的任务作为任务启动一个新线程</span></span><br><span class="line">  <span class="comment">// 调用 addWorker 创建新线程时会自动地检查runState和workerCount</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">      <span class="comment">// 当前workerCount小于核心线程数，传入true判断与核心线程数的关系</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">//如果线程添加失败（有可能其他线程也在对线程池进行操作）就更新一下c的值</span></span><br><span class="line">        c = ctl.get();	</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 如果一个任务可以成功排队，那么我们仍然需要再次检查我们是否应该添加一个线程</span></span><br><span class="line">	<span class="comment">// 因为已经存在的线程在上次检查之后可能已经死亡或者线程池在进入这个方法之后已经关闭</span></span><br><span class="line">  <span class="comment">// 如果当前线程池是运行状态就尝试向工作队列中添加一个新的等待任务</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">				<span class="comment">// 如果线程池在添加任务后关闭了就remove添加的任务</span></span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">          <span class="comment">//拒绝当前任务的提交</span></span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 如果线程池依然在运行状态且没有工作线程就启动一个新线程。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">          	<span class="comment">// 此时的workerCount大于核心线程数，传入false判断与maxPoolSize的关系</span></span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 添加失败，说明线程池关闭或饱和了，就拒绝此任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出主要是依靠 <code>addWorker()</code> 方法来添加工作线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">  <span class="comment">// 重试起点</span></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">	      <span class="comment">// 获取当前线程池的状态，如果是STOP,TIDYING,TERMINATED状态的话，则返回false</span></span><br><span class="line">      <span class="comment">// 如果现在状态是SHUTDOWN，只有在要运行的任务为空且还有还有工作任务时才可以添加线程</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="comment">// 获取当前的工作线程数量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">          <span class="comment">// 判断线程池是否饱和</span></span><br><span class="line">          <span class="comment">// 首先判断要添加的Worker是否是corePool</span></span><br><span class="line">          <span class="comment">// 若是则判断当前的workerCount是否大于corePoolsize</span></span><br><span class="line">          <span class="comment">// 否则判断是否大于maximumPoolSize，如果大于说明workerCount超出了线程池大小，返回false</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          <span class="comment">// 判断是否成功将WorkerCount通过CAS操作增加1，成功则跳出retry</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">          <span class="comment">// 失败则判断当前线程池的状态，若获取到的状态与进入自旋的状态不一致则继续外层for循环</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">          <span class="comment">// 如果是其他原因导致的CAS失败，只可能是其他线程同时在自增，所以重新执行内层for循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 成功将WorkerCount通过CAS操作增加1后创建新Woker</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line">              <span class="comment">// 若当前线程池是运行状态或SHUTDOWN状态且firstTask为空才继续</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">                  <span class="comment">// 检查线程是否正在运行状态</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                  <span class="comment">// 直接将新创建的Work放进workers集合</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                  <span class="comment">// 更新线程池线程数</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 添加成功则启动线程</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 若线程在启动过程中失败会将w移出workers并将计数器-1</span></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 返回是否添加成功</span></span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以创建一个新的工作线程了。</p>
<p>Worker类继承自 AbstractQueuedSynchronizer，它本身就是一把锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">// 要执行的第一个任务，构造时已确定</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">// 线程完成的任务数</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">      <span class="comment">// 执行Task之前不能中断，将AQS的state设定为-1</span></span><br><span class="line">        setState(-<span class="number">1</span>); </span><br><span class="line">        <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">      <span class="comment">// 通过预定义或自定义的线程工厂创建线程</span></span><br><span class="line">        <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        runWorker(<span class="built_in">this</span>);  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">// 0加锁，1已加锁</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Worker 的 <code>run()</code> 方法中调用了 <code>runWorker()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">    w.firstTask = <span class="literal">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 只要任务不为null或任务为空但可以从等待队列中取出任务就开始执行这个任务</span></span><br><span class="line">      <span class="comment">// 如果当前没有任务，就在getTask方法中卡住，因为要从阻塞队列中取任务</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 执行任务</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="literal">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>runWorker()</code> 方法中获取到一个个 Runnable 的 Task 并直接调用 <code>run()</code> 方法，这样就可以实现用相同线程去执行不同的 <code>run()</code> 方法。</p>
<p>线程池关闭：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通的shutdown会继续将等待队列中的线程执行完成后再关闭线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">// 判断是否有权限终止</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">      	<span class="comment">// CAS将线程池运行状态改为SHUTDOWN状态</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">       	<span class="comment">// 让空闲的线程（比如正在等新的任务）中断，不会影响正在运行的线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">      	<span class="comment">// 给ScheduledThreadPoolExecutor提供的构造方法</span></span><br><span class="line">      	<span class="comment">// 当前类没有实现</span></span><br><span class="line">        onShutdown(); </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 尝试终止线程池</span></span><br><span class="line">    tryTerminate();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tryTerminate()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">tryTerminate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">      	<span class="comment">// 若线程池处于</span></span><br><span class="line">      	<span class="comment">// 正在运行或线程池基本关闭或处于SHUTDOWN状态且工作队列不为空</span></span><br><span class="line">      	<span class="comment">// 则不能关闭线程池，返回</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 若线程池处于SHUTDOWN状态且等待队列为空或是STOP状态</span></span><br><span class="line">      	<span class="comment">// 如果工作线程数不是0，中断空闲状态下的线程</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; </span><br><span class="line">          	<span class="comment">// 最多只中断一个空闲线程</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);   </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      	<span class="comment">// 工作线程为空，终止线程池</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          	<span class="comment">// CAS将状态设定为TIDYING表示基本终止</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;   </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  	<span class="comment">// 终止</span></span><br><span class="line">                    terminated();   </span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  	<span class="comment">// 将状态设定为TERMINATED，线程池结束</span></span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));   </span><br><span class="line">                  	<span class="comment">// 如果有线程调用了awaitTermination方法，会等待当前线程池终止唤醒</span></span><br><span class="line">                    termination.signalAll();    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 结束</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 如果CAS失败则进下一轮循环重新判断</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="使用线程池的注意事项"><a href="#使用线程池的注意事项" class="headerlink" title="使用线程池的注意事项"></a>使用线程池的注意事项</h2><ul>
<li>避免任务堆积</li>
<li>避免线程数过度增加</li>
<li>排查线程泄露</li>
</ul>
<br>

<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h2 id="ThreadLocal-的两大使用场景"><a href="#ThreadLocal-的两大使用场景" class="headerlink" title="ThreadLocal 的两大使用场景"></a>ThreadLocal 的两大使用场景</h2><ol>
<li>每个线程都需要一个独享的对象（通常是工具类，如 SimpleDateFormat 和 Random）</li>
<li>每个线程内需要保存全局变量（如在拦截器中获取用户信息），可以让不同的方法直接使用，避免频繁的传递参数。</li>
</ol>
<br>

<h3 id="每个线程都需要一个独享对象"><a href="#每个线程都需要一个独享对象" class="headerlink" title="每个线程都需要一个独享对象"></a>每个线程都需要一个独享对象</h3><p>每个 Thread 中都有自己的实例副本，不共享。</p>
<p>如一个班只有一本教材，所有人会共同使用一本书并一起做笔记，会有线程安全问题。但将课本复制后每个人都拥有书的副本了，解决了线程安全问题。</p>
<p>使用 SimpleDateFormat：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalUsage1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="keyword">new</span> <span class="title class_">ThreadLocalUsage1</span>().date(<span class="number">10</span>))).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="keyword">new</span> <span class="title class_">ThreadLocalUsage1</span>().date(<span class="number">109876</span>))).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">date</span><span class="params">(<span class="type">int</span> seconds)</span>&#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(seconds * <span class="number">1000L</span>);</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sdf.format(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">02</span> <span class="number">02</span>:<span class="number">31</span>:<span class="number">16</span></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> 08:<span class="number">00</span>:<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>当只有两个线程分别使用独自的 SimpleDateFormat 打印日期并没有问题。</p>
<p>当线程变多起来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="keyword">new</span> <span class="title class_">ThreadLocalUsage2</span>().date(finalI * <span class="number">10</span>))).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要单独创建并销毁多个线程，开销很大，因此可以使用线程池来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalUsage3</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            executorService.submit(() -&gt; System.out.println(<span class="keyword">new</span> <span class="title class_">ThreadLocalUsage3</span>().date(finalI * <span class="number">10</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">date</span><span class="params">(<span class="type">int</span> seconds)</span>&#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(seconds * <span class="number">1000L</span>);</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sdf.format(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用线程池的效率很高，但是也可以发现这 10 个线程执行 1000 个任务时创建了调用了 1000 次 ThreadLocalUsage 中的 <code>date</code> 方法，而在 <code>date()</code> 方法中创建了 SimpleDateFormat 对象，因此就创建并销毁了 1000 个 SimpleDateFormat 对象。</p>
<p>所以可以考虑让每一个线程都共享地使用同一个 SimpleDateFormat 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalUsage4</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            executorService.submit(() -&gt; System.out.println(<span class="keyword">new</span> <span class="title class_">ThreadLocalUsage4</span>().date(finalI * <span class="number">10</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">date</span><span class="params">(<span class="type">int</span> seconds)</span>&#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(seconds * <span class="number">1000L</span>);</span><br><span class="line">        <span class="keyword">return</span> sdf.format(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是会发现输出的日期会有重复，产生了线程安全问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> <span class="number">10</span>:<span class="number">44</span>:<span class="number">10</span></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> <span class="number">10</span>:<span class="number">43</span>:<span class="number">20</span></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> <span class="number">10</span>:<span class="number">43</span>:<span class="number">20</span></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> <span class="number">10</span>:<span class="number">46</span>:<span class="number">20</span></span><br><span class="line"><span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> <span class="number">10</span>:<span class="number">46</span>:<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>这是因为所有线程都使用了同一个线程不安全的 SimpleDateFormat 类，导致产生了线程安全问题。</p>
<p>这样就很容易可以想到对共享资源进行加锁的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">date</span><span class="params">(<span class="type">int</span> seconds)</span>&#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(seconds * <span class="number">1000L</span>);</span><br><span class="line">    String format;</span><br><span class="line">    <span class="keyword">synchronized</span> (ThreadLocalUsage5.class) &#123;</span><br><span class="line">        format = sdf.format(date);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> format;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样虽然不会产生线程安全问题，但在高并发场景下让线程一个个排队会使效率很低。</p>
<p>因此，ThreadLocal 就可以解决这种问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalUsage6</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            executorService.submit(() -&gt; System.out.println(<span class="keyword">new</span> <span class="title class_">ThreadLocalUsage6</span>().date(finalI * <span class="number">10</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">date</span><span class="params">(<span class="type">int</span> seconds)</span>&#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(seconds * <span class="number">1000L</span>);</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> ThreadSafeFormat.simpleDateFormat.get();</span><br><span class="line">        <span class="keyword">return</span> sdf.format(date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadSafeFormat</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; simpleDateFormat = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="当前用户信息需要被线程内所有方法共享"><a href="#当前用户信息需要被线程内所有方法共享" class="headerlink" title="当前用户信息需要被线程内所有方法共享"></a>当前用户信息需要被线程内所有方法共享</h3><p>一个比较繁琐的解决方案是把 user 作为参数层层传递，从 service-1() 传到 service-2() 再传到 service-3()…但是这样<br>会导致代码冗余且不易维护。	</p>
<p>因此我们可以在每个线程内都保存全局变量，这样就可以让不同的方法使用，避免了频繁的参数传递。</p>
<p>首先会考虑到使用 static 的全局变量来保存信息，但需要明确的是，每个线程的 user 可能是不同的，其中携带的 user 信息也会不同，使用一个 static 全局变量不满足业务需求。</p>
<p>因此可以考虑使用 map 来存储 user 信息，但在并发环境下需要使用 synchronized 或 ConcurrentHashMap 来保证线程安全，而这会对性能产生影响。</p>
<p>更好的方法是使用 ThreadLocal，它不需要使用 synchronized 和 ConcurrentHashMap、不影响性能、不需要层层传递参数，就可以达到保存当前线程对应的用户信息的目的。</p>
<p>用 ThreadLocal 保存一些业务内容(用户权限信息、从用户系统获取到的用户名、user ID等)。这些信息在同一个线程内相同，但是不同的线程使用的业务内容是不相同的。在线程生命周期内，都通过这个静态 ThreadLocal 实例的 <code>get()</code> 方法取得自己 set 过的那个对象，避免了将这个对象(如 user 对象)作为参数传递的麻烦：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalUsage7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Service1</span>().process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Service1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span>&#123;</span><br><span class="line">        UserContextHolder.holder.set(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;xiaoA&quot;</span>));</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Service2</span>().process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Service2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Service2: &quot;</span> + UserContextHolder.holder.get().name);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Service3</span>().process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Service3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Service3: &quot;</span> + UserContextHolder.holder.get().name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserContextHolder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;User&gt; holder = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要使用 <code>set()</code> 方法。</p>
<br>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>ThreadLocal 的作用</strong></p>
<ol>
<li>让某个需要用到的对象在线程见隔离（每个线程都有自己独立的对象）</li>
<li>在任何方法中都能轻松地获取到该对象</li>
</ol>
<p>跟据共享对象的生成时机不同，需要选择使用 <code>initialValue</code> 或 <code>set</code> 来保存对象：</p>
<ul>
<li><p>在 ThreadLocal 第一次 <code>get</code> 的时候把对象给初始化出来，对象的初始化时机可以由我们控制</p>
</li>
<li><p>如果需要保存到 ThreadLocal 里的对象的生成时机不由我们随意控制，如拦截器生成的用户信息，用<br><code>ThreadLocal.set</code> 直接放到的 ThreadLocal 中去以便后续使用。</p>
</li>
</ul>
<br>

<p><strong>ThreadLocal 带来的好处</strong></p>
<ul>
<li>实现线程安全</li>
<li>不需要加锁，提高执行效率</li>
<li>更高效地利用内存，节省了开销</li>
<li>免去传参的繁琐</li>
</ul>
<br>

<h2 id="ThreadLocal-原理"><a href="#ThreadLocal-原理" class="headerlink" title="ThreadLocal 原理"></a>ThreadLocal 原理</h2><p>在 Thread 类中有这样一个 ThreadLocalMap 类型成员变量 threadLocals：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://s1.ax1x.com/2022/05/19/ObCXJ1.png" alt="ObCXJ1.png"></p>
<p>每一个 Thread 对象都持有一个 ThreadLocalMap 成员变量，这个 Map 存储了 ThreadLocal 和其绑定的对象（KV）。</p>
<br>

<h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><h4 id="T-get"><a href="#T-get" class="headerlink" title="T get()"></a>T get()</h4><p>得到这个线程对应的 value。如果是首次调用则会调用 <code>setInitialValue()</code> 方法来获取值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">  	<span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">  	<span class="comment">// 获取当前线程的ThreadLocalMap</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">  	<span class="comment">// 非首次调用</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">      	<span class="comment">// 以当前ThreadLocal对象作为key在map中获取该key的value（这个value是set的value）</span></span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">      	<span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 如果没有进行过初始化则跳过if，调用 setInitialValue 方法</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>get()</code> 方法是先取出当前线程的 ThreadLocalMap，然后调用 <code>map.getEntry()</code> 方法把本 ThreadLocal 的引用作为参数传入，取出 map 中属于本 ThreadLocal 的 value。<br><strong>注意：</strong>这个 map 以及 map 中的 key 和 value 都是保存在线程中的，而不是保存在 ThreadLocal 中。</p>
<br>

<h4 id="T-setInitialValue"><a href="#T-setInitialValue" class="headerlink" title="T  setInitialValue()"></a>T  setInitialValue()</h4><p>该方法会返回当前线程对应的初始值。采用了懒加载机制，当第一次调用 <code>get()</code> 时才会触发。除非线程先前调用了 <code>set()</code> 方法，在这种情况下不会再调用 <code>initValue()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">  	<span class="comment">// 获取 initialValue </span></span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">  	<span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">  	<span class="comment">// 获取当前线程的ThreadLocalMap</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">  	<span class="comment">// map不为空说明初始化过，直接覆盖</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">      map.set(<span class="built_in">this</span>, value);</span><br><span class="line">      <span class="comment">// 否则创建一个map并设置值</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> TerminatingThreadLocal) &#123;</span><br><span class="line">      TerminatingThreadLocal.register((TerminatingThreadLocal&lt;?&gt;) <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">  	<span class="comment">// 如果不重写此方法则返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">  	<span class="comment">// 调用ThreadlocalMap的构造方法创建threadlocals</span></span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常每个线程最多调用一次该方法，但在调用完 <code>remove()</code> 后能够再次通过 <code>get()</code> 方法调用此方法。</p>
<br>

<h4 id="void-set-T-t"><a href="#void-set-T-t" class="headerlink" title="void set(T t)"></a>void set(T t)</h4><p>为当前线程设置一个新的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 <code>setInitialValue()</code> 方法相似。</p>
<br>

<h4 id="void-remove"><a href="#void-remove" class="headerlink" title="void remove()"></a>void remove()</h4><p>删除对应这个线程的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除线程所存储对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="literal">null</span>)</span><br><span class="line">        m.remove(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>删除的是以当前线程作为 key 对应的 value。</p>
<br>

<h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="built_in">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> threshold; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setThreshold</span><span class="params">(<span class="type">int</span> len)</span> &#123;</span><br><span class="line">            threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ThreadLocalMap 类是每个线程 Thread 类里的变量，里面最重要的是一个键值对数组 <code>Entry[] table</code>，可以认为是一个 map：</p>
<ul>
<li>键：该 ThreadLocal</li>
<li>值：实际需要的成员变量，如 User、SimpleDateFormat 对象等</li>
</ul>
<p>可以用 HashMap 来帮助理解，但它的实现与 HashMap 略有不同，如 HashMap 是使用红黑树来处理 Hash 冲突，而 ThreadLocalMap 是使用线性探测法继续寻找下一个位置。</p>
<p>通过上面的源码可以看出，虽然之前在展示 ThreadLocal 的两大使用场景时分别使用了 <code>set()</code> 和 <code>setInitialValue()</code> 两种不同的方法来赋值，但其实最终都是使用的 <code>map.set()</code>。也就是说最后都会对应到 ThreadLocalMap 的一个 Entry，只是起点和入口不一样。</p>
<br>

<h2 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h2><p>内存泄漏，即已经申请的内存空间无法释放，就会造成内存泄漏，例如线程死循环、资源不关闭等，大量的内存泄漏堆积就会造成内存不够，从而发生内存溢出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">    <span class="built_in">super</span>(k);</span><br><span class="line">    value = v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在源码中可以看到 Entry 的构造方法并不是简单的赋值，还有利用了 <code>super()</code> 进行赋值的 <code>ThreadLocal</code> 对象 k。Entry 继承自 WeakReference 类，即弱引用类。</p>
<blockquote>
<p>弱引用是用来描述非必须的对象的，但它的强度比软引用更弱。</p>
<p>被弱引用关联的对象只能生存到下一次 GC 发生之前，也就是说下一次 GC 就会被回收。</p>
<p>JDK1.2 之后，提供了 WeakReference 来实现弱引用。</p>
</blockquote>
<p>因此，如果没有强引用去引用使用弱引用的构造函数进行赋值的 ThreadLocal k，那么 k 就会在下一次 GC 时被回收。若此时作为 Key 的 k 被 GC 回收，而 value 又是被 Entry 强引用因而无法被回收，那么其对应的 value 就无法被访问到了，只要线程还在运行，value 的内存就不会释放，这样发生了内存泄漏。即存在调用链：</p>
<p>Thread -&gt; ThreadLocalMap -&gt; Entry(Key &#x3D; null) -&gt; Value</p>
<p>单个线程的情况下，线程结束的时候，内存泄漏的 value 会被回收，不会有什么问题。但若使用的线程池则会一直运行下去，这样 value 内存会被一直占用，并且可能会不断增加而导致 OOM。</p>
<p>为了避免内存泄漏问题：</p>
<ul>
<li>使用完 ThreadLocal 后调用其 <code>remove()</code> 方法删除对应的 Entry</li>
</ul>
<p>需要明确的是，内存泄漏与 Key 的弱引用之间没有直接关系。如果 Entry 节点将 ThreadLocal 对象作为一个成员变量而不是采用弱引用的方式，那么 Entry 节点会一直对 Key 和 value 保持着强引用关系。这样，即使 Threadlocal 对象在其它地方都不再使用了该对象也不会被回收。这就会导致 Entry 节点永远不会被回收(只要线程不终结)，而且也不能主动去判断是否能切断 ThreadLocalMap 中 Threadlocal 对象的引用（不知道是否还有其它地方引用到了）。</p>
<p>因为 map 是 Thread 对象的一个成员变量，只要线程不终结 map 也是不会被回收的。如果发生了内存泄露的问题，则可能会一直积累下去，最终导致程序 OOM。而 Key 采用弱引用加之主动的判断过时节点(key 是否为 null)并进行清除处理可以最大限度的减少内存泄露的发生。</p>
<br>

<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="Lock-接口"><a href="#Lock-接口" class="headerlink" title="Lock 接口"></a>Lock 接口</h2><p>锁是一种工具，用于控制对共享资源的访问。</p>
<p>Lock 和 synchronized 是两个最常见的锁，它们都可以达到线程安全的目的，但在使用上和功能上又有较大的不同。Lock 并不是用来替代 synchronized 的，而是在使用 synchronized 不合适或不足以满足要求时用来提供高级功能的。</p>
<p>Lock 接口中最常见的实现类是 ReentrantLock。通常情况下，Lock 只允许一个线程来访问这个共享资源。但有时候一些特殊的实现也可以允许并发访问，如 ReadWriteLock 中的 ReadLock。</p>
<br>

<h3 id="为什么需要-Lock"><a href="#为什么需要-Lock" class="headerlink" title="为什么需要 Lock"></a>为什么需要 Lock</h3><p><strong>synchronized 不够用</strong></p>
<ol>
<li>效率低：锁的释放时机少、试图获得锁是不能设定超时、不能中断一个正在试图获得锁的线程。</li>
<li>不够灵活：加锁和释放锁的时机单一，每个锁仅有单一的条件（某个对象）</li>
<li>无法得知是否成功获得到锁</li>
</ol>
<br>

<h3 id="Lock-的主要方法"><a href="#Lock-的主要方法" class="headerlink" title="Lock 的主要方法"></a>Lock 的主要方法</h3><p>在 Lock 中声明了 4 个获取锁的方法：</p>
<ul>
<li><code>lock()</code></li>
</ul>
<p><code>lock()</code> 就是最普通的获取锁。如果锁已经被其他线程获取则进行等待。</p>
<p>Lock 不会像 synchronized 一样在异常时自动释放锁，因此需要使用 <code>try-catch-finally</code> 块来保证发生异常时锁一定被释放。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockMethod1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 需要加锁的共享资源</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;Start&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但 <code>lock()</code> 方法不能被中断，一旦陷入死锁就会永久等待。</p>
<ul>
<li><code>tryLock()</code></li>
</ul>
<p><code>tryLock()</code> 用来尝试获取锁，如果当前锁没有被其他线程占用则获取成功并返回 true，否则返回 false 代表获取锁失败。该方法会立即返回，即便在拿不到锁时不会一直等待。</p>
<p>相比于引 <code>lock()</code>，我们可以使用此方法根据是否能获取到锁来决定后续程序的行为。</p>
<ul>
<li><code>tryLock(long time, TimeUnit unit)</code></li>
</ul>
<p>相比于不带参数的 <code>tryLock()</code>，带参数可以设置该方法的等待时间，超时就放弃。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockMethod2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LockMethod2</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockMethod2</span>();</span><br><span class="line">        <span class="type">LockMethod2</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockMethod2</span>();</span><br><span class="line">        l1.flag = <span class="number">1</span>;</span><br><span class="line">        l2.flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(l1).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(l2).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (lock1.tryLock(<span class="number">800</span>, TimeUnit.MILLISECONDS))&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;线程1获取到锁1&quot;</span>);</span><br><span class="line">                            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                            <span class="keyword">if</span> (lock2.tryLock(<span class="number">800</span> ,TimeUnit.MILLISECONDS))&#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    System.out.println(<span class="string">&quot;线程1获取到锁2&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;线程1获取到两把锁&quot;</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                    lock2.unlock();</span><br><span class="line">                                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                System.out.println(<span class="string">&quot;线程1未获取到锁2&quot;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">                            lock1.unlock();</span><br><span class="line">                            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程1未获取到锁1&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (lock2.tryLock(<span class="number">3000</span>, TimeUnit.MILLISECONDS))&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;线程2获取到锁2&quot;</span>);</span><br><span class="line">                            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                            <span class="keyword">if</span> (lock1.tryLock(<span class="number">3000</span> ,TimeUnit.MILLISECONDS))&#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    System.out.println(<span class="string">&quot;线程2获取到锁1&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;线程2获取到两把锁&quot;</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                    lock1.unlock();</span><br><span class="line">                                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                System.out.println(<span class="string">&quot;线程2未获取到锁1&quot;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">                            lock2.unlock();</span><br><span class="line">                            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程2未获取到锁2&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">线程<span class="number">2</span>获取到锁<span class="number">2</span></span><br><span class="line">线程<span class="number">1</span>获取到锁<span class="number">1</span></span><br><span class="line">线程<span class="number">1</span>未获取到锁<span class="number">2</span></span><br><span class="line">线程<span class="number">2</span>获取到锁<span class="number">1</span></span><br><span class="line">线程<span class="number">2</span>获取到两把锁</span><br><span class="line">线程<span class="number">1</span>获取到锁<span class="number">1</span></span><br><span class="line">线程<span class="number">1</span>获取到锁<span class="number">2</span></span><br><span class="line">线程<span class="number">1</span>获取到两把锁</span><br></pre></td></tr></table></figure>

<ul>
<li><code>lockInterruptibly()</code></li>
</ul>
<p>相当于将 <code>tryLock(long time, TimeUnit unit)</code> 的超时时间为无限长。在等待锁的过程中可以被中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockMethod3</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">LockMethod3</span> <span class="variable">lockMethod3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockMethod3</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(lockMethod3, <span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(lockMethod3, <span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        thread1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;尝试获取锁&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lockInterruptibly();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取锁&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;睡眠被中断&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;释放锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;等待锁中断&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">thread1尝试获取锁</span><br><span class="line">thread2尝试获取锁</span><br><span class="line">thread1获取锁</span><br><span class="line">thread1睡眠被中断</span><br><span class="line">thread1释放锁</span><br><span class="line">thread2获取锁</span><br><span class="line">thread2释放锁</span><br></pre></td></tr></table></figure>

<br>

<h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OLLRLd"><img data-src="https://s1.ax1x.com/2022/05/20/OLLRLd.png" alt="OLLRLd.png"></a></p>
<h2 id="锁的可见性保证"><a href="#锁的可见性保证" class="headerlink" title="锁的可见性保证"></a>锁的可见性保证</h2><h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><p>JMM 的三个特性:</p>
<ul>
<li>原子性：要做事情要么做完，要么就不做，不存在做一半的情况。</li>
<li>可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</li>
<li>有序性：即程序执行的顺序按照代码的先后顺序执行。</li>
</ul>
<p>如果多线程访问同一个变量，那么这个变量会被线程拷贝到自己的工作内存中进行操作，而不是直接对主内存中的变量本体进行操作，下面这个操作看起来是一个有限循环，但是是无限的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (a == <span class="number">0</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;线程结束！&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;正在修改a的值...&quot;</span>);</span><br><span class="line">        a = <span class="number">1</span>;   <span class="comment">// a的值被修改那么另一个线程将不再循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然在主线程中修改了 a 的值，但是另一个线程并不知道 a 的值发生了改变，所以循环中依然是使用旧值在进行判断，因此，普通变量是不具有可见性的。</p>
<p>要解决这种问题首先想到的是加锁，同一时间只能有一个线程使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Main.class)&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程结束！&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;正在修改a的值...&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (Main.class)&#123;</span><br><span class="line">            a = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用 <code>volatile</code> 关键字来解决，此关键字的第一个作用就是保证变量的可见性。当写一个 <code>volatile</code> 变量时，JMM 会把该线程本地内存中的变量强制刷新到主内存中去，并且这个写会操作会导致其他线程中的 <code>volatile</code> 变量缓存失效。这样，另一个线程修改了这个变量时，当前线程会立即得知，并将工作内存中的变量更新为最新的版本。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="comment">// 添加volatile关键字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (a == <span class="number">0</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;线程结束！&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;正在修改a的值...&quot;</span>);</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现当 a 发生改变时，循环立即结束。</p>
<p>虽然说 <code>volatile</code> 能够保证可见性，但是不能保证原子性。要解决上面的 <code>i++</code> 问题还是只能使用加锁来完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) a++;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务完成！&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待线程执行完成</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么 <code>volatile</code> 不能在改变变量的时候对其他线程可见的情况下保证原子性？</p>
<p>这是因为自增操作被分为多个步骤完成，虽然保证了可见性，但只要运行速度够快，依然会出现两个线程同时写同一个值的问题（如线程 1 刚将 a 的值更新为 100，这时线程 2 也已经执行到更新 a 的值这条指令，因此依然会将 a 的值再更新为一次 100），为了解决这个问题可以使用原子类。</p>
<p>最后一个功能是 <code>volatile</code> 会禁止指令重排。也就是说若操作的是一个 <code>volatile</code> 变量，它将不会出现重排序的情况。</p>
<p>若用 <code>volatile</code> 修饰共享变量，在编译时，会在指令序列中插入<strong>内存屏障</strong>来禁止特定类型的处理器重排序。</p>
<blockquote>
<p>内存屏障（Memory Barrier）又称内存栅栏，是一个 CPU 指令，它的作用有两个：</p>
<ul>
<li>保证特定操作的顺序</li>
<li>保证某些变量的内存可见性（volatile 的内存可见性就是依靠这个实现的）</li>
</ul>
<p>由于编译器和处理器都能执行指令重排的优化，如果在指令间插入一条 Memory Barrier，则会告诉编译器和 CPU，不管什么指令都不能和这条 Memory Barrier 指令重排序。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bOE9cd"><img data-src="https://s1.ax1x.com/2022/03/14/bOE9cd.jpg" alt="bOE9cd.jpg"></a></p>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>指令示例</th>
<th>说明</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>LoadLoad</td>
<td>Load1;LoadLoad;Load2</td>
<td>保证 Load1 的读取操作在 Load2 及后续读取操作之前执行</td>
<td></td>
</tr>
<tr>
<td>StoreStore</td>
<td>Store1;StoreStore;Store2</td>
<td>在 Store2 及其后的写操作执行前，保证 Store1 的写操作已刷新到主内存</td>
<td></td>
</tr>
<tr>
<td>LoadStore</td>
<td>Load1;LoadStore;Store2</td>
<td>在 Store2 及其后的写操作执行前，保证 Load1 的读操作已读取结束</td>
<td></td>
</tr>
<tr>
<td>StoreLoad</td>
<td>Store1;StoreLoad;Load2</td>
<td>保证 Load1 的写操作已刷新到主内存之后，Load2 及其后的读操作才能执行</td>
<td></td>
</tr>
</tbody></table>
</blockquote>
<p>所以 <code>volatile</code> 能够保证之前的指令一定全部执行，之后的指令一定都没有执行，并且前面语句的结果对后面的语句可见。</p>
<p><code>volatile</code> 关键字的三个特性：</p>
<ul>
<li>保证可见性</li>
<li>不保证原子性</li>
<li>防止指令重排</li>
</ul>
<br>

<h3 id="hanpens-before-原则"><a href="#hanpens-before-原则" class="headerlink" title="hanpens-before 原则"></a>hanpens-before 原则</h3><p>JMM 提出了 happens-before（先行发生）原则，定义一些禁止编译优化的场景，来向各位程序员做一些保证，只要按照原则进行编程，那么就能够保持并发编程的正确性。具体如下	：</p>
<ul>
<li><strong>程序次序规则：</strong>一个线程中，按照程序的顺序，前面的操作 happens-before 后续的任何操作。<ul>
<li>同一个线程内，代码的执行结果是有序的。即可能会发生指令重排，但保证代码的执行结果一定是和按照顺序执行得到的一致，程序前面对某一个变量的修改一定对后续操作可见的，不可能会出现前面刚把 a 修改为 1，读取 a 仍是修改前的结果，这也是程序运行最基本的要求。</li>
</ul>
</li>
<li><strong>监视器锁规则：</strong>对一个锁的解锁操作，happens-before 后续对这个锁的加锁操作。<ul>
<li>无论是在单线程环境还是多线程环境，对于同一个锁来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果。比如前一个线程将变量 x 的值修改为了 12 并解锁，之后另一个线程拿到了这把锁，对之前线程的操作是可见的，可以得到 x 是前一个线程修改后的结果 12（所以 synchronized 是有 happens-before 规则的）</li>
</ul>
</li>
<li><strong>volatile 变量规则：</strong>对一个 volatile 变量的写操作 happens-before 后续对这个变量的读操作。<ul>
<li>如果一个线程先去写一个 volatile 变量，然后另一个线程去读这个变量，那么这个写操作的结果一定对读的这个变量的线程可见。</li>
</ul>
</li>
<li><strong>线程启动规则：</strong>主线程 A 启动线程 B，线程 B 中可以看到主线程启动 B 之前的操作。<ul>
<li>在主线程 A 执行过程中启动子线程 B，那么线程 A 在启动子线程 B 之前对共享变量的修改结果对线程 B 可见。</li>
</ul>
</li>
<li><strong>线程加入规则：</strong>如果线程 A 执行操作 <code>join()</code> 线程 B 并成功返回，那么线程 B 中的任意操作 happens-before 线程 A <code>join()</code> 操作成功返回。</li>
<li><strong>传递性规则：</strong>如果 A happens-before B，B happens-before C，那么 A happens-before C。</li>
</ul>
<p>从 happens-before 原则的角度解释下面的程序结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        a = <span class="number">10</span>;</span><br><span class="line">        b = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span>(b) System.out.println(a); </span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义以上出现的操作：</p>
<ul>
<li><strong>A：</strong>将变量 a 的值修改为 10</li>
<li><strong>B：</strong>将变量 b 的值修改为 true</li>
<li><strong>C：</strong>主线程启动了一个新的线程，并在新的线程中获取 b，进行判断，如果为 true 就打印 a</li>
</ul>
<p>由于是同一个线程且 A 是一个赋值操作，那么按照<strong>程序次序规则</strong>：A happens-before B。</p>
<p>在 B 之后马上执行了 C，按照<strong>线程启动规则</strong>：在新的线程启动之前，当前线程之前的所有操作对新的线程是可见的，所以 B happens-before C。</p>
<p>最后根据<strong>传递性规则</strong>，由于 A happens-before B，B happens-before C，所以 A happens-before C，因此在新的线程中会输出 a 修改后的结果 10。</p>
<br>

<h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><p>悲观锁（互斥同步锁）是基于一种悲观的态度类来防止一切数据冲突，它是以一种预防的姿态在修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的。</p>
<p>由于互斥同步锁在阻塞和唤醒方面的性能问题、永久阻塞问题和优先级反转问题，因此诞生了乐观锁。</p>
<p>乐观锁（非互斥同步锁）是对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁（这使得多个任务可以并行的对数据进行操作），只有到数据提交的时候才通过一种机制来验证数据是否存在冲突(一般实现方式是通过加版本号然后进行版本号的对比，即 CAS)，Git 就是典型的乐观锁例子。</p>
<p>悲观锁例子：</p>
<ul>
<li>synchronized</li>
<li>Lock 接口</li>
</ul>
<p>乐观锁例子：</p>
<ul>
<li>原子类</li>
<li>并发容器</li>
</ul>
<br>

<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>悲观锁的原始开销要高于乐观锁，但是特点是一劳永逸，临界区持锁时间就算越来越差，也不会对互斥锁的开销造成影响。虽然乐观锁一开始的开销比悲观锁小，但如果自旋时间很长或不停重试，那么消耗的资源也会越来越多。</p>
<p>悲观锁：适合并发写入多的情况，适用于临界区持锁时间比较长的情况，悲观锁可以避免大量的无用自旋等消耗，典型情况：</p>
<ul>
<li>临界区有 IO 操作</li>
<li>临界区代码复杂或者循环量大</li>
<li>临界区竞争非常激烈</li>
</ul>
<p>乐观锁：适合并发写入少，大部分是读取的场景，不加锁的能让读取性能大幅提高。</p>
<br>

<h2 id="可重入锁和非可重入锁"><a href="#可重入锁和非可重入锁" class="headerlink" title="可重入锁和非可重入锁"></a>可重入锁和非可重入锁</h2><p>可重入锁，<strong>是指一个线程拿到该锁后</strong>，<strong>还可以再次成功获取</strong>，而不会因为该锁已经被持有（尽管是自己所持有）而陷入等待状态（死锁）。<strong>synchronized 也是可重入锁</strong>。</p>
<p>可重入锁可以避免死锁，提高了封装性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChopsticksLock</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">chopsticksNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ChopsticksLock</span> <span class="variable">chopsticksLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChopsticksLock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(chopsticksLock::getOne).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(chopsticksLock::getOne).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(chopsticksLock::getOne).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(chopsticksLock::getOne).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getOne</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            chopsticksNum++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;拿到了第一只筷子&quot;</span>);</span><br><span class="line">            <span class="comment">// if语句块调用了另外的同步方法，需要再次获取锁，而该锁也是当前Chopsticks对象</span></span><br><span class="line">            <span class="keyword">if</span> (chopsticksNum == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 有两只筷子</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始吃饭&quot;</span>);</span><br><span class="line">                <span class="comment">// 吃完放下两只筷子</span></span><br><span class="line">                chopsticksNum = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有两只筷子则去拿一只筷子</span></span><br><span class="line">                getOne();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>四个线程都执行的是<strong>同一个对象</strong> chopsticks 中的方法，这四个同步方法在执行时将会<strong>获取同样的锁</strong>。</p>
<p>当一个线程 A 抢到 CPU 进入 <code>getOne()</code> 时获取锁然后执行代码。如果<strong>线程 A 还未执行完毕</strong>就被另一个线程 B 抢占了 CPU，则当线程 B 进入<code>getOne()</code>时发现锁在线程 A 那里，<strong>于是等待</strong>；线程 A 重新拿到 CPU 继续执行代码，进入<code>getOne()</code>方法获取锁，<strong>发现锁就在自己这里</strong>，<strong>于是继续执行</strong>，<strong>这就是可重入锁</strong>。可重入锁避免了死锁的发生，避免线程因获取不了锁而进入永久等待状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span>拿到了第一只筷子</span><br><span class="line">Thread-<span class="number">0</span>拿到了第一只筷子</span><br><span class="line">Thread-<span class="number">0</span>开始吃饭</span><br><span class="line">Thread-<span class="number">2</span>拿到了第一只筷子</span><br><span class="line">Thread-<span class="number">2</span>拿到了第一只筷子</span><br><span class="line">Thread-<span class="number">2</span>开始吃饭</span><br><span class="line">Thread-<span class="number">3</span>拿到了第一只筷子</span><br><span class="line">Thread-<span class="number">3</span>拿到了第一只筷子</span><br><span class="line">Thread-<span class="number">3</span>开始吃饭</span><br><span class="line">Thread-<span class="number">1</span>拿到了第一只筷子</span><br><span class="line">Thread-<span class="number">1</span>拿到了第一只筷子</span><br><span class="line">Thread-<span class="number">1</span>开始吃饭</span><br></pre></td></tr></table></figure>

<br>

<h3 id="初识源码"><a href="#初识源码" class="headerlink" title="初识源码"></a>初识源码</h3><p>可重入锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">  	<span class="comment">// 获取锁被持有的次数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">  	<span class="comment">// 当前没有持有该锁就使用CAS尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 当前已经持有该锁了</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">      	<span class="comment">// 重入锁</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      	<span class="comment">// 获取锁时先判断，如果当前线程就是已经占有锁的线程，则state++并返回true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">  	<span class="comment">// 获取锁释放后还被持有的次数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  	<span class="comment">// 次数为0才算真正的释放</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非可重入锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">  	<span class="comment">// 首先盘对是否持有该锁，持有返回false，未持久再进行获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">  	<span class="comment">// 释放锁</span></span><br><span class="line">    setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    setState(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="ReetrantLock-方法"><a href="#ReetrantLock-方法" class="headerlink" title="ReetrantLock 方法"></a>ReetrantLock 方法</h3><ul>
<li><code>getHoldCount()</code>：返回锁被持有的次数</li>
<li><code>isHeldByCurrentThread()</code>：返回锁是否被当前线程持有</li>
<li><code>getQueueLength()</code>：返回当前等待这把锁的队列的长度</li>
</ul>
<br>

<h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><p>公平锁：多个线程按照申请顺序去获得锁。线程会直接进入队列中排队，永远都是队列中的第一位才能获得锁。</p>
<p>非公平锁：多个线程去获取锁的时候，会去尝试插队获取锁，如果未获取到则进入等待队列。</p>
<p>默认创建的 <code>ReentrantLock</code> 采用的是非公平锁作为底层锁机制。这是因为非公平锁可以提高效率，它避免了唤醒带来的空档期（唤醒线程需要时间：唤醒、赖床、起床）。</p>
<br>

<h3 id="演示公平与非公平的情况"><a href="#演示公平与非公平的情况" class="headerlink" title="演示公平与非公平的情况"></a>演示公平与非公平的情况</h3><p>在创建 ReentrantLock 时可以传入参数 <code>true</code> 来创建公平锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FairLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">PrintQueue</span> <span class="variable">printQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintQueue</span>();</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Job</span>(printQueue));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            threads[i].start();</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Job</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PrintQueue printQueue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Job</span><span class="params">(PrintQueue printQueue)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.printQueue = printQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: is running&quot;</span>);</span><br><span class="line">        printQueue.printJob(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: is finished&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrintQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">queueLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printJob</span><span class="params">(Object document)</span> &#123;</span><br><span class="line">        queueLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: is printing&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            queueLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queueLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: is printing&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            queueLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用公平锁时，线程会按照排队的顺序依次执行任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span>: is running</span><br><span class="line">Thread-<span class="number">0</span>: is printing</span><br><span class="line">Thread-<span class="number">1</span>: is running</span><br><span class="line">Thread-<span class="number">2</span>: is running</span><br><span class="line">Thread-<span class="number">3</span>: is running</span><br><span class="line">Thread-<span class="number">4</span>: is running</span><br><span class="line">Thread-<span class="number">1</span>: is printing</span><br><span class="line">Thread-<span class="number">2</span>: is printing</span><br><span class="line">Thread-<span class="number">3</span>: is printing</span><br><span class="line">Thread-<span class="number">4</span>: is printing</span><br><span class="line">Thread-<span class="number">0</span>: is printing</span><br><span class="line">Thread-<span class="number">0</span>: is finished</span><br><span class="line">Thread-<span class="number">1</span>: is printing</span><br><span class="line">Thread-<span class="number">1</span>: is finished</span><br><span class="line">Thread-<span class="number">2</span>: is printing</span><br><span class="line">Thread-<span class="number">2</span>: is finished</span><br><span class="line">Thread-<span class="number">3</span>: is printing</span><br><span class="line">Thread-<span class="number">3</span>: is finished</span><br><span class="line">Thread-<span class="number">4</span>: is printing</span><br><span class="line">Thread-<span class="number">4</span>: is finished</span><br></pre></td></tr></table></figure>

<p>而使用非公平锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span>: is running</span><br><span class="line">Thread-<span class="number">0</span>: is printing</span><br><span class="line">Thread-<span class="number">1</span>: is running</span><br><span class="line">Thread-<span class="number">2</span>: is running</span><br><span class="line">Thread-<span class="number">3</span>: is running</span><br><span class="line">Thread-<span class="number">4</span>: is running</span><br><span class="line">Thread-<span class="number">0</span>: is printing</span><br><span class="line">Thread-<span class="number">0</span>: is finished</span><br><span class="line">Thread-<span class="number">1</span>: is printing</span><br><span class="line">Thread-<span class="number">1</span>: is printing</span><br><span class="line">Thread-<span class="number">1</span>: is finished</span><br><span class="line">Thread-<span class="number">2</span>: is printing</span><br><span class="line">Thread-<span class="number">2</span>: is printing</span><br><span class="line">Thread-<span class="number">2</span>: is finished</span><br><span class="line">Thread-<span class="number">3</span>: is printing</span><br><span class="line">Thread-<span class="number">3</span>: is printing</span><br><span class="line">Thread-<span class="number">3</span>: is finished</span><br><span class="line">Thread-<span class="number">4</span>: is printing</span><br><span class="line">Thread-<span class="number">4</span>: is printing</span><br><span class="line">Thread-<span class="number">4</span>: is finished</span><br></pre></td></tr></table></figure>

<p>由于一次任务中需要两次打印才能完成任务，而每个线程在完成第一次打印的时候都会去插队再次获取该锁，而不是像公平锁那样在队列中去排队，因此每个线程都是连续进行了两次打印完成任务。</p>
<p>对于公平锁也有一个特例：<code>tryLock()</code>，它不遵循设定的公平规则。 当有线程执行 <code>tryLock()</code> 时，一旦有线程释放了锁，那么这个正在 <code>tryLock()</code> 的线程就能获取到锁，即使在它之前已经有其他线程在等待队列里。</p>
<br>

<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>公平锁的各线程平等，每个线程在等待一段时间后总会执行。但公平锁更慢，吞吐量更小。非公平锁更快，吞吐量更大，但有可能产生线程饥饿，某些线程在长时间内始终都不能执行。</p>
<br>

<h3 id="初识源码-1"><a href="#初识源码-1" class="headerlink" title="初识源码"></a>初识源码</h3><p>公平锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">      	<span class="comment">// 判断队列中是否有排队，有就排队没有就继续获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非公平锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">      	<span class="comment">// 直接尝试获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="共享锁和排他锁"><a href="#共享锁和排他锁" class="headerlink" title="共享锁和排他锁"></a>共享锁和排他锁</h2><p>共享锁又称读锁，获得共享锁后可以查看但无法修改和删除数据，其他线程此时也可以获取共享锁。排他锁又称为写锁、独占锁、独享锁，获得排他锁后其他线程无法获取到锁。</p>
<p>典型的共享锁和排他锁是读写锁 ReentrantReadWriteLock。</p>
<br>

<h3 id="读写锁的作用"><a href="#读写锁的作用" class="headerlink" title="读写锁的作用"></a>读写锁的作用</h3><p>在没有读写锁之前若使用 ReentrantLock，那么虽然保证了线程安全但也浪费了一定的资源：多个读操作同时<br>进行时并不会存在线程安全问题。</p>
<p>因此使用读写锁可以在读的地方使用读锁，在写的地方使用写锁，灵活控制。如果没有写锁的情况下，读锁是无阻塞的，提高了程序的执行效率。</p>
<br>

<h3 id="读写锁的规则"><a href="#读写锁的规则" class="headerlink" title="读写锁的规则"></a>读写锁的规则</h3><ul>
<li>多个线程只申请读锁则都可以申请到</li>
<li>如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。</li>
<li>如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。</li>
</ul>
<br>

<h3 id="读写锁演示"><a href="#读写锁演示" class="headerlink" title="读写锁演示"></a>读写锁演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">reentrantReadWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">readLock</span> <span class="operator">=</span> reentrantReadWriteLock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">writeLock</span> <span class="operator">=</span> reentrantReadWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">            System.out.println(<span class="string">&quot;read unlock&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">            System.out.println(<span class="string">&quot;write unlock&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(ReadWriteLock::read).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(ReadWriteLock::read).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(ReadWriteLock::write).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(ReadWriteLock::write).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到可以同时上读锁但不能同时上写锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">read</span><br><span class="line">read</span><br><span class="line">read unlock</span><br><span class="line">read unlock</span><br><span class="line">write</span><br><span class="line">write unlock</span><br><span class="line">write</span><br><span class="line">write unlock</span><br></pre></td></tr></table></figure>

<br>

<h3 id="读写锁的插队策略"><a href="#读写锁的插队策略" class="headerlink" title="读写锁的插队策略"></a>读写锁的插队策略</h3><p>为 ReentrantReadWriteLock 类的构造方法传入参数 <code>true/false</code> 就可以设置公平与非公平的锁。</p>
<p>对于公平锁是不允许插队的。而对于非公平锁：</p>
<p>若此时有线程 1 和线程 2 正在同时读取，线程 3 想要写入但无法获取到锁，因此进入等待队列。此时线程 4 进入想读取…</p>
<p>有两种策略：</p>
<ol>
<li>线程 4 插队加入读取</li>
<li>线程 4 进入等待队列排队</li>
</ol>
<p>若使用第 1 种策略确实能够提高整体的效率，但是若此后进入的有线程很多需要读取而它们都插队就会导致饥饿的现象。</p>
<p>因此，ReentrantReadWriteLock 采用的是可以避免饥饿的第 2 种策略。</p>
<br>

<h3 id="初识源码-2"><a href="#初识源码-2" class="headerlink" title="初识源码"></a>初识源码</h3><p>公平锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2274990926593161451L</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">writerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">      	<span class="comment">// 有线程在等待</span></span><br><span class="line">        <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">readerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">      	<span class="comment">// 有线程在等待</span></span><br><span class="line">        <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于公平锁来说只要等待队列中已经有等待的线程了就也会被阻塞加入等待队列。</p>
<p>非公平锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">8159625535654395037L</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">writerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">      	<span class="comment">// 写线程永远都可以尝试插队</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// writers can always barge</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">readerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">      	<span class="comment">// 当等待队列中首位是写锁则读锁需要排队</span></span><br><span class="line">        <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然之前介绍的读写锁插队策略中说明了读锁是不插队的，但这只是当等待队列的头节点为需要获取写锁的时候才不允许读线程插队。若当前等待队列的头节点是需要获取读锁的线程则后来的读线程可以插队。</p>
<br>

<h3 id="锁的升级和降级"><a href="#锁的升级和降级" class="headerlink" title="锁的升级和降级"></a>锁的升级和降级</h3><p>锁降级指的是写锁降级为读锁。当一个线程持有写锁的情况下，虽然其他线程不能加读锁，但该线程自己可以获取读锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoteLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReentrantReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line">        lock.readLock().lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;成功获取读锁&quot;</span>);</span><br><span class="line">        lock.writeLock().unlock();</span><br><span class="line">        System.out.println(<span class="string">&quot;成功释放写锁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时若有其他线程也需要获取读锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoteLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ReentrantReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;成功获取写锁&quot;</span>);</span><br><span class="line">        lock.readLock().lock();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;成功获取读锁&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;尝试获取读锁&quot;</span>);</span><br><span class="line">            lock.readLock().lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;成功获取读锁&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        lock.writeLock().unlock();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;成功释放写锁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main成功获取写锁</span><br><span class="line">main成功获取读锁</span><br><span class="line">Thread-<span class="number">0</span>尝试获取读锁</span><br><span class="line">main成功释放写锁</span><br><span class="line">Thread-<span class="number">0</span>成功获取读锁</span><br></pre></td></tr></table></figure>

<p>可以看到在 main 线程释放写锁后即锁降级后的读锁是可以共享的。</p>
<p>在仅持有读锁的情况下去申请写锁被称为<strong>锁升级</strong>，ReentrantReadWriteLock是不支持的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UpgradeLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReentrantReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">        lock.readLock().lock();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;成功获取读锁&quot;</span>);</span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;成功加写锁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行时会被阻塞在获取写锁的代码处。</p>
<br>

<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ol>
<li>锁降级中读锁的获取是否必要呢？</li>
</ol>
<p>答案是必要的。为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程（记作线程T）获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。如果当前线程获取读锁，即遵循锁降级的步骤，则线程T将会被阻塞，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进行数据更新。</p>
<ol start="2">
<li>为什么不支持锁升级</li>
</ol>
<p>容易造成死锁现象。若有两个读锁同时想要进行锁升级，他们都需要等到对方先释放读锁，从而形成循环等待造成死锁。</p>
<br>

<h2 id="自旋锁和阻塞锁"><a href="#自旋锁和阻塞锁" class="headerlink" title="自旋锁和阻塞锁"></a>自旋锁和阻塞锁</h2><p>由于阻塞或唤醒一个 Java 线程需要操作<strong>系统切换 CPU 状态</strong>来完成，而这种状态转换需要<strong>耗费处理器时间</strong>。如果同步代码块中的内容过于简单，那么状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>
<p>因此在许多场景中同步资源的锁定时间很短，若为了这一小段时间去切换线程，那么线程挂起和恢复现场的花费可能会让系统得不偿失。</p>
<p>如果物理机器有多个处理器能够让两个或以上的线程同时并行执行，那么就可以让后面请求锁的线程<strong>不放弃 CPU 的执行时间</strong>，看看持有锁的线程是否很快就会释放锁。</p>
<p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋。如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p>
<p>阻塞锁与自旋锁相反，阻塞锁若未获取到锁则会直接将线程阻塞，直到被唤醒。</p>
<br>

<h3 id="自旋锁的缺点"><a href="#自旋锁的缺点" class="headerlink" title="自旋锁的缺点"></a>自旋锁的缺点</h3><ul>
<li>如果锁被占用的时间过长，那么自旋锁的线程只会白白地浪费处理器资源。</li>
<li>在自旋的过程中一直都会消耗 CPU，所以虽然自旋锁的起始开销低于阻塞锁，但随着自旋时间的增长开销也是线性增长的。</li>
</ul>
<br>

<h3 id="初识源码-3"><a href="#初识源码-3" class="headerlink" title="初识源码"></a>初识源码</h3><p>在 Java 1.5 版本及以上的并发框架 java.util.concurrent 的 atmoic 包下的类基本都是自旋锁的实现。</p>
<p>AtomicInteger 的实现：自旋锁的实现原理是 CAS</p>
<p>AtomicInteger 中调用 unsafe 进行自增操作的源码中的 do-while 循环就是一个自旋操作，如果修改过程中遇到其他线程竞争导致没修改成功，就在 while 中死循环直至修改成功。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> delta)</span> &#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>自旋锁一般用于多核的服务器，在并发度不是特别高的情况下，比阻塞锁的效率高。</p>
<p>另外，自旋锁适用于临界区比较短小的情况，否则如果临界区很大（线程一旦拿到锁，很久以后才会释放)，那也是不合适的。</p>
<br>

<h2 id="可中断锁"><a href="#可中断锁" class="headerlink" title="可中断锁"></a>可中断锁</h2><p>在 Java 中，synchronized 就是不可中断锁，而 Lock 是可中断锁。因为 <code>tryLock(time)</code> 和 <code>lockInterruptibly</code> 都能响应中断。</p>
<p>如果某一线程 A 正在执行锁中的代码，另一线程 B 正在等待获取该锁，可能由于等待时间过长导致不想线程 B 等待了，此时就可以中断它，这种就是可中断锁。</p>
<br>

<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><h3 id="Java-虚拟机对锁的优化"><a href="#Java-虚拟机对锁的优化" class="headerlink" title="Java 虚拟机对锁的优化"></a>Java 虚拟机对锁的优化</h3><ol>
<li><p>自适应自旋</p>
<p>在 JDK 1.6 中引⼊了⾃适应的⾃旋锁。<strong>⾃适应意味着⾃旋的次数不再固定了，⽽是由前⼀次在同⼀个锁上的⾃旋次数及锁的拥有者的状态来决定。</strong>如最近获得锁成功了，那么下一次就会继续自旋，并且允许自旋的时间更长。</p>
</li>
<li><p>锁消除</p>
<p><strong>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进⾏消除。</strong></p>
<p>锁消除主要是通过逃逸分析来⽀持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可<br>以把它们当成私有数据对待，也就可以将它们的锁进⾏消除。</p>
<p>相对的，对于⼀些看起来没有加锁的代码，其实隐式的加了很多锁。例如下⾯的字符串拼接代码就隐式加了锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">concatString</span><span class="params">(String s1, String s2, String s3)</span> &#123;    </span><br><span class="line">  <span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>String 是⼀个不可变的类，编译器会对 String 的拼接⾃动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">concatString</span><span class="params">(String s1, String s2, String s3)</span> &#123;    </span><br><span class="line">  <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();    </span><br><span class="line">  sb.append(s1);    </span><br><span class="line">  sb.append(s2);    </span><br><span class="line">  sb.append(s3);    </span><br><span class="line">  <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>每个 <code>append()</code> ⽅法中都有⼀个同步块。虚拟机观察变量 <code>sb</code> 很快就会发现它的动态作⽤域被限制在 <code>concatString()</code> ⽅法内部。也就是说 <code>sb</code> 的所有引⽤永远不会逃逸到 <code>concatString()</code> ⽅法之外，其他线程⽆法访问到它，因此可以进⾏消除。</p>
</li>
<li><p>锁粗化</p>
<p>如果⼀系列的连续操作都对同⼀个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。上面示例代码中连续的 <code>append()</code> ⽅法就属于这类情况。如果虚拟机探测到由这样的⼀串零碎的操作都对同⼀个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上面的示例代码就是扩展到第⼀个 <code>append()</code> 操作之前直⾄最后⼀个 <code>append()</code> 操作之后，这样只需要加锁⼀次就可以了。</p>
</li>
</ol>
<br>

<h3 id="编写代码时如何优化锁"><a href="#编写代码时如何优化锁" class="headerlink" title="编写代码时如何优化锁"></a>编写代码时如何优化锁</h3><ol>
<li>缩小同步代码块</li>
<li>尽量不要锁住方法</li>
<li>减少请求锁的次数</li>
<li>避免人为制造热点</li>
<li>锁中尽量不要再包含锁</li>
<li>选择合适的锁类型或合适的工具类</li>
</ol>
<br>

<h1 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在<code>java.util.concurrent.atomic</code>包下，有一系列“Atomic”开头的类，统称为原子类。</p>
<p>原子类的作用和锁类似，是为了保证并发情况下线程安全。不过原子类相比于锁，有一定的优势：</p>
<ul>
<li>粒度更细：原子变量可以把竞争范围缩小到变量级别，这是我们可以获得的最细粒度。通常锁的粒度都要大于原子变量的粒度。</li>
<li>效率更高：通常，除了高度竞争的情况，使用原子类的效率会比使用锁的效率更高。</li>
</ul>
<br>

<h2 id="6-大类原子类"><a href="#6-大类原子类" class="headerlink" title="6 大类原子类"></a>6 大类原子类</h2><p>基本类型原子类</p>
<ul>
<li>AtomicInteger</li>
<li>AtomicLong</li>
<li>AtomicBoolean</li>
</ul>
<p>数组类型原子类</p>
<ul>
<li>AtomicIntegerArray</li>
<li>AtomicLongArray</li>
<li>AtomicReferenceArray</li>
</ul>
<p>引用类型原子类</p>
<ul>
<li>AtomicReference</li>
<li>AtomicStampedReference</li>
<li>AtomicMarkableReference</li>
</ul>
<p>升级类型原子类</p>
<ul>
<li>AtomicIntegerFieldUpdater</li>
<li>AtomicLongFieldUpdater</li>
<li>AtomicReferenceFieldUpdater</li>
</ul>
<p>Adder 累加器</p>
<ul>
<li>LongAdder</li>
<li>DoubleAdder</li>
</ul>
<p>Accumulator 累加器</p>
<ul>
<li>LongAccumulator</li>
<li>DoubleAccumulator</li>
</ul>
<br>

<h2 id="基本类型原子类"><a href="#基本类型原子类" class="headerlink" title="基本类型原子类"></a>基本类型原子类</h2><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>以 AtomicInteger 为例：</p>
<ul>
<li><p><code>int get()</code> ：获取当前值</p>
</li>
<li><p><code>int getAndSet()</code>：获取当前值并设置新的值</p>
</li>
<li><p><code>int getAndIncrement()</code>：获取当前值并自增</p>
</li>
<li><p><code>int getAndDecrement()</code>：获取当前值并自减</p>
</li>
<li><p><code>int getAndAdd(int delta)</code>：获取当前值并加上预期的值</p>
</li>
<li><p><code>compareAndSet(int expect, int update)</code>：如果当前值与 expect 一致，则以原子的方式将该值更新为 update</p>
</li>
</ul>
<p>如 <code>getAndIncrement()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerTest</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">basicCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incrementAtomic</span><span class="params">()</span> &#123;</span><br><span class="line">        atomicInteger.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 可以对该方法加上 synchronized 以保证线程安全</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incrementBasic</span><span class="params">()</span> &#123;</span><br><span class="line">        basicCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">AtomicIntegerTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerTest</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(test);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(test);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;Atomic: &quot;</span> + test.atomicInteger.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;Basic: &quot;</span> + basicCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            incrementAtomic();</span><br><span class="line">            incrementBasic();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Atomic: <span class="number">2000</span></span><br><span class="line">Basic: <span class="number">1998</span></span><br></pre></td></tr></table></figure>

<p>可以发现无论怎样运行原子类的结果始终是 2000，而普通类型的数值每次运行结果都不相同。可以为 <code>incrementBasic()</code> 方法添加 <code>synchronized</code> 关键字来保证线程安全。</p>
<br>

<h2 id="数组类型原子类"><a href="#数组类型原子类" class="headerlink" title="数组类型原子类"></a>数组类型原子类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicArrayTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">AtomicIntegerArray</span> <span class="variable">aia</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(<span class="number">1000</span>);</span><br><span class="line">        Thread[] decreaseThreads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">100</span>];</span><br><span class="line">        Thread[] increaseThreads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="type">DoDecrease</span> <span class="variable">doDecrease</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoDecrease</span>(aia);</span><br><span class="line">        <span class="type">DoIncrease</span> <span class="variable">doIncrease</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoIncrease</span>(aia);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            decreaseThreads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(doDecrease);</span><br><span class="line">            increaseThreads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(doIncrease);</span><br><span class="line">            decreaseThreads[i].start();</span><br><span class="line">            increaseThreads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            decreaseThreads[i].join();</span><br><span class="line">            increaseThreads[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; aia.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aia.get(i) != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Error: &quot;</span> + aia.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoDecrease</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    AtomicIntegerArray aia;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoDecrease</span><span class="params">(AtomicIntegerArray aia)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.aia = aia;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; aia.length(); i++) &#123;</span><br><span class="line">            aia.getAndDecrement(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoIncrease</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    AtomicIntegerArray aia;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoIncrease</span><span class="params">(AtomicIntegerArray aia)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.aia = aia;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; aia.length(); i++) &#123;</span><br><span class="line">            aia.getAndIncrement(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="引用类型原子类"><a href="#引用类型原子类" class="headerlink" title="引用类型原子类"></a>引用类型原子类</h2><p>AtomicReference 类的作用与 AtomicInteger 并没有本质区别，AtomicInteger 可以让一个整数保证原子性，而 AtomicReference 可以让一个对象保证原子性。当然 AtomicReference 的功能明显比 AtomicInteger 强，因为一个对象里可以包含很多属性。它的用法与 AtomicInteger 类似。</p>
<p>实现自旋锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicReferenceTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; sign = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="keyword">while</span> (!sign.compareAndSet(<span class="literal">null</span>, current)) &#123;</span><br><span class="line">            System.out.println(current + <span class="string">&quot;Get lock failed, try again&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sign.compareAndSet(Thread.currentThread(), <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicReferenceTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicReferenceTest</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread1 get lock&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            test.unlock();</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread1 unlock&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread2 get lock&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            test.unlock();</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread2 unlock&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要利用了 <code>compareAndSet(V expect, V update)</code> 方法。</p>
<br>

<h2 id="升级类型原子类"><a href="#升级类型原子类" class="headerlink" title="升级类型原子类"></a>升级类型原子类</h2><p>AtomicIntegerFieldUpdater 可以将普通变量升级为原子类，适用于偶尔需要进行原子操作有并发问题风险的场景。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerFieldUpdaterTest</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Candidate xiaoA;</span><br><span class="line">    <span class="keyword">static</span> Candidate xiaoB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;Candidate&gt; scoreUpdater =</span><br><span class="line">        AtomicIntegerFieldUpdater.newUpdater(Candidate.class, <span class="string">&quot;score&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            xiaoA.score++;</span><br><span class="line">            scoreUpdater.getAndIncrement(xiaoB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Candidate</span> &#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">int</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        xiaoA = <span class="keyword">new</span> <span class="title class_">Candidate</span>();</span><br><span class="line">        xiaoB = <span class="keyword">new</span> <span class="title class_">Candidate</span>();</span><br><span class="line">        <span class="type">AtomicIntegerFieldUpdaterTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerFieldUpdaterTest</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(test);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(test);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;未升级：&quot;</span> + xiaoA.score);</span><br><span class="line">        System.out.println(<span class="string">&quot;已升级：&quot;</span> + xiaoB.score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">未升级：<span class="number">1964</span></span><br><span class="line">已升级：<span class="number">2000</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>使用 AtomicFieldUpdater 修改的变量需要有可见范围</li>
<li>它不支持 static 修饰的变量</li>
<li>需要为变量添加 volatile 关键字</li>
</ul>
<br>

<h2 id="累加器"><a href="#累加器" class="headerlink" title="累加器"></a>累加器</h2><h3 id="Adder-累加器"><a href="#Adder-累加器" class="headerlink" title="Adder 累加器"></a>Adder 累加器</h3><p>在 JDK 8 之后，新增了 <code>DoubleAdder</code> 和 <code>LongAdder</code> ，在高并发情况下，<code>LongAder</code> 的性能比 <code>AtomicLong</code> 的性能更好，主要体现在自增上。</p>
<p>使用 AtomicLong 累加：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicLongTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicLong</span> <span class="variable">atomicLong</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">16</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    atomicLong.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executorService.isTerminated()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Use time: &quot;</span> + (System.currentTimeMillis() - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        System.out.println(atomicLong.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Use time: 6797ms</span><br><span class="line"><span class="number">100000000</span></span><br></pre></td></tr></table></figure>

<p>使用 LongAdder 累加：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongAdderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LongAdder</span> <span class="variable">longAdder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">16</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    longAdder.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executorService.isTerminated()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Use time: &quot;</span> + (System.currentTimeMillis() - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        System.out.println(longAdder.longValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Use time: 188ms</span><br><span class="line"><span class="number">100000000</span></span><br></pre></td></tr></table></figure>

<p>可以看到消耗的时间明显大量减少。</p>
<br>

<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>竞争激烈的时候，LongAdder 把不同线程对应到不同的 Cell 上进行修改，降低了冲突的概率，是多段锁的理念，提高了并发性。</p>
<p>这里演示多线程情况下 AtomicLong 的性能，有 16个线程对同一个 AtomicLong 累加。由于竞争很激烈，每一次加法都要 flush 和 refresh，导致很耗费资源。</p>
<p>LongAdder 内部的实现原理和 AtomicLong 是有不同的。AtomicLong 的实现原理是每一次加法都需要同步，所以在高并发时会导致冲突较多，也就降低了效率。而 LongAdder 的每个线程会有自己的一个计数器，仅用来在自己线程内计数，这样就不会和其他线程的计数器干扰。</p>
<p>如在线程 1 的计数器数值 value’ 为 1 时，可能线程 2 的计数器 value’’的数值已经是3了。它们之间并不存在竞争关系，所以在加和的过程中不需要同步机制，因此就不需要进行 flush 和 refresh。</p>
<p>在 LongAdder 中引入了分段累加的概念，内部有一个 base 变量和一个 Cell[] 数组共同参与计数：</p>
<ul>
<li>base 变量：竞争不激烈，直接累加到该变量上</li>
<li>Cell[] 数组：竞争激烈，各个线程分散累加到自己的槽 Cell[i] 中</li>
</ul>
<p><img data-src="https://s2.loli.net/2022/03/25/usjpfJ9Id5OUHlK.png"></p>
<br>

<h4 id="sum-源码分析"><a href="#sum-源码分析" class="headerlink" title="sum() 源码分析"></a>sum() 源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> base;</span><br><span class="line">  	<span class="comment">// 当 Cell 数组为空时直接返回 base</span></span><br><span class="line">  	<span class="comment">// 当 Cell 数组不为空就遍历 Cell 数组求和并加上 base 并返回</span></span><br><span class="line">    <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现 <code>sum()</code> 方法是没有加锁的，因此在没有并发更新的情况下调用会返回一个准确的结果，但在计算总和时发生的并发更新可能不会被计算。</p>
<br>

<h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h4><p>在低争用下，AtomicLong 和 LongAdder 这两个类具有相似的特征。但是在竞净激烈的情况下，LongAdder 的预期吞吐量要高得多，但要消耗更多的空间。</p>
<p>因此 LongAdder 适合的场景是统计求和计数的场景，而且 LongAdder 基本只提供了 add 方法，而 AtomicLong 还具有 cas 方法。</p>
<br>

<h3 id="Accumulator-累加器"><a href="#Accumulator-累加器" class="headerlink" title="Accumulator 累加器"></a>Accumulator 累加器</h3><p>Accumulator 与 Adder 非常相似，Accumulator 就是一个更加通用的 Adder。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongAccumulatorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LongAccumulator</span> <span class="variable">longAccumulator1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAccumulator</span>(Long::sum, <span class="number">0</span>);</span><br><span class="line">        <span class="type">LongAccumulator</span> <span class="variable">longAccumulator2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAccumulator</span>(Long::max, <span class="number">0</span>);</span><br><span class="line">        <span class="type">LongAccumulator</span> <span class="variable">longAccumulator3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAccumulator</span>((x, y) -&gt; x * y, <span class="number">1</span>);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line">        IntStream</span><br><span class="line">                .range(<span class="number">0</span>, <span class="number">101</span>)</span><br><span class="line">                .forEach(i -&gt; executorService.submit(() -&gt; longAccumulator1.accumulate(i)));</span><br><span class="line">        IntStream</span><br><span class="line">                .range(<span class="number">0</span>, <span class="number">101</span>)</span><br><span class="line">                .forEach(i -&gt; executorService.submit(() -&gt; longAccumulator2.accumulate(i)));</span><br><span class="line">        IntStream</span><br><span class="line">                .range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">                .forEach(i -&gt; executorService.submit(() -&gt; longAccumulator3.accumulate(i)));</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executorService.isTerminated()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sum: &quot;</span> + longAccumulator1.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;Max: &quot;</span> + longAccumulator2.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;Product: &quot;</span> + longAccumulator3.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sum: <span class="number">5050</span></span><br><span class="line">Max: <span class="number">100</span></span><br><span class="line">Product: <span class="number">362880</span></span><br></pre></td></tr></table></figure>

<br>

<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>CAS（Compare And Swap）是一种无锁算法，它并不会为对象加锁，而是在执行的时候，判断当前数据的值是否与预期的值相同。如果是就正常进行替换，如果不是就替换失败。</p>
<p>如有 2 个线程都需要修改变量 <code>i = 10</code> 的值。线程 1 要将其修改为 20，线程 2 要将其修改为 30。如果它们都使用 CAS 算法，那么就不会加锁访问 <code>i</code>，而是直接尝试修改 <code>i</code> 的值。但在修改时需要确认 <code>i</code> 是不是 10，如果是则表示其他线程还没对其进行修改，如果不是则说明其他线程已经将其修改，此时不能完成修改任务，修改失败。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/OjaKns"><img data-src="https://s1.ax1x.com/2022/05/21/OjaKns.md.png" alt="OjaKns.md.png"></a></p>
<p>CAS 有三个操作数：内存值 V、预期值 A、要修改的值 B。当且仅当预期值 A 和内存值 V 相同时才将内存值修改为 B，否则放弃修改，最后返回现在的 V 值。</p>
<p>在 CPU 中，CAS 操作使用的是 <code>cmpxchg</code> 指令，能够从最底层硬件层面得到效率的提升。</p>
<br>

<h2 id="CAS-等价代码"><a href="#CAS-等价代码" class="headerlink" title="CAS 等价代码"></a>CAS 等价代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CAS</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">compareAndSwap</span><span class="params">(<span class="type">int</span> expected, <span class="type">int</span> newValue)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">        <span class="keyword">if</span> (oldValue == expected) &#123;</span><br><span class="line">            value = newValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">CAS</span> <span class="variable">cas</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CAS</span>();</span><br><span class="line">        cas.value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; cas.compareAndSwap(<span class="number">0</span>, <span class="number">1</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; cas.compareAndSwap(<span class="number">0</span>, <span class="number">2</span>)).start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        System.out.println(cas.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会发现 value 只会被修改为 1。</p>
<br>

<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>乐观锁</li>
<li>并发容器</li>
<li>原子类</li>
</ul>
<br>

<h3 id="CAS-实现原子操作"><a href="#CAS-实现原子操作" class="headerlink" title="CAS 实现原子操作"></a>CAS 实现原子操作</h3><p>以 AtomicInteger 为例：</p>
<p>在该类中有静态代码块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来封装提供原子性操作的方法，AtomicInteger 实现原子操作主要是通过 unsafe 来实现。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line"><span class="comment">// value 属性在 AtomicInteger 对象内部的偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 value 的偏移量</span></span><br><span class="line">    valueOffset = unsafe.objectFieldOffset</span><br><span class="line">      (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AtomicIntege r内部真正的整数值，被 volatile 关键字修饰以保证在多线程的环境下内存可见性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br></pre></td></tr></table></figure>

<p>分析 <code>getAndAdd()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中调用了 unsafe 中的 <code>getAndAddInt()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> delta)</span> &#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中使用了 do-while 循环，判断条件就为进行 CAS 操作的 <code>compareAndSwapInt()</code> 方法的返回值，该方法实际上是基于自旋 + CAS 算法实现的原子性操作。</p>
<p>这里的 <code>compareAndSwapInt()</code> 方法是一个 unsafe 中的本地方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object o, <span class="type">long</span> offset,</span></span><br><span class="line"><span class="params">                                              <span class="type">int</span> expected,</span></span><br><span class="line"><span class="params">                                              <span class="type">int</span> x)</span>;</span><br></pre></td></tr></table></figure>

<p>unsafe 是 CAS 的核心类。Java 无法直接访问底层操作系统而是通过本地(native)方法来访问。不过尽管如此，JVM还是开了一个后门，JDK 中有一个类 unsafe 提供了硬件级别的原子操作。valueOffset 表示的是变量值在内存中的偏移地址，这是因为 Unsafe 就是根据内存偏移地址获取数据的原值的，这样就能通过 unsafe 来实现 CAS 了。</p>
<br>

<h2 id="CAS-的缺点"><a href="#CAS-的缺点" class="headerlink" title="CAS 的缺点"></a>CAS 的缺点</h2><h3 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h3><p>ABA 问题是指在 CAS 操作时，其他线程将变量值 A 改为了 B，然后又被改回了 A。等到本线程使用期望值 A 与当前变量进行比较时，发现变量 A 没有变，于是 CAS 就将 A 值进行了交换操作，但是实际上该值已经被其他线程改变过。</p>
<p><img data-src="https://s2.loli.net/2022/03/25/hnHQdtLoxcOpUjE.png"></p>
<p>解决方案：</p>
<p>可以沿用 MySQL 中版本号的方法： 在变量前面加上版本号，每次变量更新的时候变量的版本号都 +1，即 A -&gt; B -&gt; A 就变成了1A -&gt; 2B -&gt; 3A。只要变量被某一线程修改过，变量对应的版本号就会发生递增变化，从而解决了 ABA 问题。</p>
<p>同时 JUC 也提供了AtomicStampedReference&lt;E&gt; 来实现带版本号的引用类型，只需要每次操作都记录版本号且版本号不重复，就可以解决 ABA 问题。</p>
<br>

<h4 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h4><p>自旋 CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给 CPU 带来非常大的执行开销 。在 Java 中有很多的并发框架都使用了自旋 CAS 来获取相应的锁，会一直循环直到获取到相应的锁后，然后执行相应的操作。</p>
<br>

<h3 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h3><p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但从 JDK 1.5 开始，提供了 AtomicReference 类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行 CAS 操作。所以可以使用锁或者利用 AtomicReference 类把多个共享变量合并成一个共享变量来操作。</p>
<br>

<h1 id="final-关键字与不变性"><a href="#final-关键字与不变性" class="headerlink" title="final 关键字与不变性"></a>final 关键字与不变性</h1><h2 id="不变性-Immutable"><a href="#不变性-Immutable" class="headerlink" title="不变性(Immutable)"></a>不变性(Immutable)</h2><p>如果对象在被创建后状态就不能被修改，那么它就是不可变的。</p>
<p>例如有一个对象 Person:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;xiaoA&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时其他类无法修改 Person 类，即 Person 类具有不变性。但如果 Person 类中还有一条属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">gender</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>这个属性未被 final 关键字所修饰，因此就可以被修改，那么此时的 Person 类就不具有不变性了。</p>
<p><strong>具有不变性的对象一定是线程安全的</strong>，我们不需要对其采取任何额外的安全措施也可以保证线程安全。</p>
<br>

<h2 id="final-的作用"><a href="#final-的作用" class="headerlink" title="final 的作用"></a>final 的作用</h2><p>在早期的 Java 版本中，会将 final 方法转为内嵌调用。现在的 final 可以防止类被继承、防止方法被重写、防止变量被修改，并且 final 天生是线程安全的，不需要额外的同步开销。</p>
<br>

<h2 id="final-的三种用法"><a href="#final-的三种用法" class="headerlink" title="final 的三种用法"></a>final 的三种用法</h2><h3 id="final-修饰变量"><a href="#final-修饰变量" class="headerlink" title="final 修饰变量"></a>final 修饰变量</h3><p>被 final 修饰的变量的值不能被修改。如果变量是对象，那么对象的引用不能变，但是对象自身的内容依然可以变化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时 person 的引用指向不能变但 Person 内的非 final 属性可以变：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//	person = new Person();</span></span><br><span class="line">person.gender = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>final 修饰变量的赋值时机：</p>
<p>属性被声明为 final 后该变量只能被赋值一次。且一旦被赋值，final 的变量就不能再被改变。规定赋值时机是因为如果在初始化时不赋值而在之后进行赋值，那么这个 final 修饰的变量就是从 null 改变为所赋的值，这样就违反了 final 的原则了。</p>
<p>final 修饰的三种变量：</p>
<ul>
<li><p>final instance variable （类中的 final 属性）</p>
<p>在声明变量时等号右边赋值、在构造方法中赋值、在类的初始代码块中赋值（不能不赋值）</p>
</li>
<li><p>final static variable （类中的 static final 属性）</p>
<p>在声明变量时等号右边赋值、在静态初始代码块中赋值（不能是非静态）</p>
</li>
<li><p>final local variable （方法中的 final 变量）</p>
<p>并不规定赋值时机，只要求在使用前赋值</p>
</li>
</ul>
<br>

<h3 id="final-修饰方法"><a href="#final-修饰方法" class="headerlink" title="final 修饰方法"></a>final 修饰方法</h3><ul>
<li>不允许修饰构造方法</li>
<li>不可被重写</li>
</ul>
<br>

<h3 id="final-修饰类"><a href="#final-修饰类" class="headerlink" title="final 修饰类"></a>final 修饰类</h3><p>类被 final 关键字修饰后就不可被继承了，例如 String 类就是被 final 修饰的。</p>
<br>

<h2 id="不变性与-final-的关系"><a href="#不变性与-final-的关系" class="headerlink" title="不变性与 final 的关系"></a>不变性与 final 的关系</h2><p>不变性并不意味着简单地用 final 修饰。对于基本数据类型，确实被 final 修饰后就具有了不变性。但对于对象类型，需要该对象保证自身被创建后状态永远不会变才具有不变性。</p>
<p>要利用 final 实现不变性：</p>
<ul>
<li>对象被创建后其状态就不能修改</li>
<li>所有属性都是 final 修饰的</li>
<li>对象创建过程中没有发生逸出</li>
</ul>
<br>

<h3 id="栈封闭"><a href="#栈封闭" class="headerlink" title="栈封闭"></a>栈封闭</h3><p>在方法里新建的局部变量，实际上是存储在每个线程私有的栈空间，而每个栈的占空间是不能被其他线程所访问到的，所以不会有线程安全问题。这就是著名的”栈封闭”技术，是”线程封闭”技术的一种。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackConfinement</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//类共享变量，被两个线程共享</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inThread</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//方法内局部变量，多个线程之间不共享</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">neverGoOut</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            neverGoOut++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;栈内保护的数字是线程安全的： &quot;</span>+neverGoOut);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        inThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">StackConfinement</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StackConfinement</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(r.index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">栈内保护的数字是线程安全的：<span class="number">10000</span></span><br><span class="line">栈内保护的数字是线程安全的：<span class="number">10000</span></span><br><span class="line"><span class="number">16760</span></span><br></pre></td></tr></table></figure>

<br>

<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;test2&quot;</span>;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> b + <span class="number">2</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">e</span> <span class="operator">=</span> d + <span class="number">2</span>;</span><br><span class="line">  System.out.println(a == c);</span><br><span class="line">  System.out.println(a == e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先看到 <code>==</code> 而非 <code>equals</code>，因此比较的是地址。由于 b 被 final 关键字所修饰，因此被创建在常量池中，当 c 被赋值时发现常量池中已经创建了 <code>test2</code>，就直接指向与 a 相同的地址。而 e 在创建时由于 d 未被 final 所修饰，因此在运行时才会在堆中新建对象，因而导致与 a 的地址不同。</p>
<p>因此结果为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<br>

<h1 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>过时的并发容器 Vector 和 Hashtable 为了实现线程安全而在方法上都加上了 synchronized，这样就导致它们的性能不高，对于现在的高并发场景它们并不够用，因此被淘汰了。Collections 工具类也提供了如 <code>synchronizedList</code> 等工具来让线程不安全的集合变为线程安全，虽然它使用同步代码块的方式比直接对整个方法加锁更高效，但仍不能满足当前的高并发场景。现在的并发容器主要有： </p>
<ul>
<li><strong>ConcurrentHashMap</strong>：线程安全的 HashMap</li>
<li><strong>CopyOnWriteArrayList</strong>：线程安全的 List</li>
<li><strong>BlockingQueue</strong>：接口，表示阻塞队列，非常适合作为数据共享的通道</li>
<li>ConcurrentLinkedQueue：高效的非阻塞并发队列，使用链表实现。可以看作是一个线程安全的 LinkedList。</li>
<li>ConcurrentSkipListMap：是一个 Map，使用跳表的数据结构进行快速查找</li>
</ul>
<br>

<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><img data-src="https://s1.imagehub.cc/images/2022/03/09/e1fe9925bc315c6034a8da4d73e1dc1349540923d94a.png"></p>
<p>HashMap 线程不安全的原因：</p>
<ul>
<li>多个线程同时 put 碰撞导致数据丢失：多个线程计算出同一个 Hash 值就会导致只有一个数据能够 put 进</li>
<li>多个线程同时 put 扩容导致数据丢失</li>
<li>死循环造成的 CPU 100%：JDK 1.7 前的问题</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapCPU100</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>, <span class="number">1.5f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 会落到同一个块，导致扩容</span></span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        map.put(<span class="number">7</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            map.put(<span class="number">15</span>, <span class="string">&quot;D&quot;</span>);</span><br><span class="line">            System.out.println(map);</span><br><span class="line">        &#125;, <span class="string">&quot;Thread1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            map.put(<span class="number">1</span>, <span class="string">&quot;E&quot;</span>);</span><br><span class="line">            System.out.println(map);</span><br><span class="line">        &#125;, <span class="string">&quot;Thread2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当进行多线程调试时会导致 OOM。</p>
<p>造成这种问题的核心原因就是在多个线程进行扩容时会造成环形链表，导致死循环而 CPU 100%。</p>
<br>

<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h4 id="HashMap-结构"><a href="#HashMap-结构" class="headerlink" title="HashMap 结构"></a>HashMap 结构</h4><p>在 JDK 1.7 中的 HashMap</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/XppRc4"><img data-src="https://s1.ax1x.com/2022/05/23/XppRc4.png" alt="XppRc4.png"></a></p>
<p><code>HashMap(int initialCapacity, float loadFactor)</code></p>
<p>HashMap 底层实现还是数组，只是数组的每一项都是一条链。其中参数 initialCapacity 就代表了该数组的长度。Hash 值相同的元素被存在链表中。</p>
<p>而 JDK 1.8 中的 HashMap 除了有链表结构，还在链表长度达到一定阈值时会自动升级为红黑树的结构来优化查找效率：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Xp9orj"><img data-src="https://s1.ax1x.com/2022/05/23/Xp9orj.png" alt="Xp9orj.png"></a></p>
<br>

<h4 id="HashMap-关于并发的特点"><a href="#HashMap-关于并发的特点" class="headerlink" title="HashMap 关于并发的特点"></a>HashMap 关于并发的特点</h4><ol>
<li>非线程安全</li>
<li>迭代时不允许修改内容</li>
<li>只读是并发安全的</li>
<li>若一定要将 HashMap 用在开发环境，可以用 <code>Collections.synchronizedMap(new HashMap())</code></li>
</ol>
<br>

<h3 id="ConcurrentHashMap-1"><a href="#ConcurrentHashMap-1" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><h4 id="ConcurrentHashMap-结构"><a href="#ConcurrentHashMap-结构" class="headerlink" title="ConcurrentHashMap 结构"></a>ConcurrentHashMap 结构</h4><p>在 JDK 1.7 中 ConcurrentHashMap 的结构：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/XpCcy4"><img data-src="https://s1.ax1x.com/2022/05/23/XpCcy4.png" alt="XpCcy4.png"></a></p>
<p>最外层是多个 Segment，每个 Segment 的底层数据结构与 HashMap 类似，仍是数组和链表组成的拉链法。每个 Segment 独立上 ReentrantLock，因此它们之间互不影响，提高了并发效率。ConcurrentHashMap 默认有 16 个 Segment，所以最多可以支持 16 个线程并发写（操作分别分布在不同的 Segment 上）。这个默认值可以在初始化的时候设置为其他值，但一旦初始化后就不可以扩容。</p>
<p>在 JDK 1.8 中 ConcurrentHashMap 的结构：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/XpPFmj"><img data-src="https://s1.ax1x.com/2022/05/23/XpPFmj.png" alt="XpPFmj.png"></a></p>
<p>结构与 JDK 1.8 中的 HashMap 十分类似，但不再采用分段锁，而是采用无锁算法CAS。其中的 <code>put()</code> 操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">  	<span class="comment">// 如果键值为空则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(); </span><br><span class="line">  	<span class="comment">// 计算键的hash值，用于确定在哈希表中的位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());    </span><br><span class="line">  	<span class="comment">// 用来记录链表长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">      	<span class="comment">// 如果数组（哈希表）为空则进行初始化，然后再进入下一轮循环</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();    </span><br><span class="line">      	<span class="comment">// 如果哈希值对应的map位置为空则CAS插入结点作为头结（这里会将f设置当前哈希表位置上的头结点）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;  </span><br><span class="line">          	<span class="comment">// CAS操作，利用Unsafe类</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))  </span><br><span class="line">              	<span class="comment">// 如果CAS成功就break结束put方法，失败就继续下一轮循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">         	<span class="comment">// 如果头结点哈希值为-1是因为正在扩容</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) </span><br><span class="line">          	<span class="comment">// 帮助进行迁移后再下一次循环</span></span><br><span class="line">            tab = helpTransfer(tab, f); </span><br><span class="line">      	<span class="comment">// 除了上面的if、else if特殊情况之外的正常情况</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">          	<span class="comment">// 将头结点作为锁加锁，防止同一时间其他线程也在操作哈希表中这个位置上的链表或红黑树</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;   </span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                  	<span class="comment">// 头结点的哈希值大于等于0说明是链表，下面就是针对链表的操作</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;    </span><br><span class="line">                        ...实现细节略</span><br><span class="line">                      <span class="comment">// 红黑树，下面就是针对红黑树的操作</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;   </span><br><span class="line">                      	<span class="comment">// 在ConcurrentHashMap并不是直接存储的TreeNode，而是TreeBin</span></span><br><span class="line">                        ...实现细节略</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">// 根据链表长度决定是否要进化为红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">              	<span class="comment">// 链表长度是否超过阈值</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                  	<span class="comment">// 若满足进化红黑树条件则进化。如果当前哈希表的长度小于64，会优先考虑对哈希表进行扩容</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">              	<span class="comment">// 返回值</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总体流程：</p>
<ul>
<li>判断 KV 是否为空</li>
<li>计算 Hash 值</li>
<li>根据对应位置结点的类型来赋值，或者 helpTransfer、增长链表、给红黑树添加节点</li>
<li>检查满足阈值就进化为红黑树</li>
<li>返回 oldValue</li>
</ul>
<p><code>get()</code> 操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">  	<span class="comment">// 计算哈希值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());   </span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">      	<span class="comment">// 如果头结点就是get的就直接返回值</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 负数：正在扩容、红黑树，</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">      	<span class="comment">// 不是头节点和红黑树或扩容则在链表中查找</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 未找到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总体流程：</p>
<ul>
<li>计算 Hash 值</li>
<li>找到对应的位置：<ul>
<li>直接取值</li>
<li>红黑树中取值</li>
<li>遍历列表取值</li>
</ul>
</li>
<li>返回结果或空</li>
</ul>
<p>综上，ConcurrentHashMap 的 <code>put()</code> 操作实际上是对哈希表上的所有头结点元素分别加锁，理论上来说哈希表的长度很大程度上决定了 ConcurrentHashMap 在同一时间能够处理的线程数量，这也是为什么 <code>treeifyBin()</code> 会优先考虑为哈希表进行扩容的原因。显然，这种加锁方式比 JDK 1.7 的分段锁机制性能更好。</p>
<p><img data-src="https://s2.loli.net/2022/03/25/9a4rnUBTj6ZQJwW.png" alt="image-20220325181747104"></p>
<br>

<h4 id="1-8-较-1-7-的升级"><a href="#1-8-较-1-7-的升级" class="headerlink" title="1.8 较 1.7 的升级"></a>1.8 较 1.7 的升级</h4><ul>
<li>数据结构升级，提高了并发度</li>
<li>当遇到 Hash 碰撞时，会先采取拉链法，达到一定长度后升级为红黑树来提高查找效率</li>
<li>保证并发安全的原理由分段锁升级为了 CAS + synchronized</li>
</ul>
<p>链表长度超过 8 才转为红黑树：</p>
<p>首先在数据量少、链表长度短时查询效率两者差距不大。但红黑树结构所占用的空间是链表的两倍，因此为了节省空间则没有在一开始就使用红黑树结构。在正常情况下想要 Hash 碰撞达到 8 次的概率是十分低的，若真发生这种情况，转为红黑树可以保证在这种极端情况下也能保证查询效率。</p>
<br>

<h4 id="组合操作问题"><a href="#组合操作问题" class="headerlink" title="组合操作问题"></a>组合操作问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptionsConcurrentHashMap</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, Integer&gt; scores = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        scores.put(<span class="string">&quot;xiaoA&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                scores.put(<span class="string">&quot;xiaoA&quot;</span>, scores.get(<span class="string">&quot;xiaoA&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                scores.put(<span class="string">&quot;xiaoA&quot;</span>, scores.get(<span class="string">&quot;xiaoA&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(scores);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现输出的并不会是 2000 且多次运行输出的结果不会相同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;xiaoA=<span class="number">1144</span>&#125;</span><br></pre></td></tr></table></figure>

<p>这并不能说明 ConcurrentHashMap 不是线程安全的，只是因为 ConcurrentHashMap 保证了单个操作如 <code>put()</code>、<code>get()</code> 等在多线程环境下的线程安全，而不能保证上面这张组合操作的线程安全问题。</p>
<p>为了解决这种情况下的线程安全问题，可以为组合操作上锁加上 synchronized，但这样就与 HashMap 加锁无异。ConcurrentHashMap 提供了线程安全的 <code>replace()</code> 方法就可以解决这种问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> scores.replace(<span class="string">&quot;xiaoA&quot;</span>, scores.get(<span class="string">&quot;xiaoA&quot;</span>), scores.get(<span class="string">&quot;xiaoA&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p><code>while(true)</code> 是为了保证本次 +1 操作一定成功。</p>
<p><code>replace()</code> 方法类似于 CAS，通过比较当前需要修改的值是否与传入的 oldValue 来选择是否修改，以此保证线程安全。ConcurrentHashMap 中还有类似的组合操作如：<code>putIfAbsent()</code>。</p>
<br>

<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>与 ConcurrentHashMap 相同，CopyOnWriteArrayList 也是为了代替 Vector 和 synchronizedList，它们的锁的粒度太大，并发效率比较低，而且在迭代时无法编辑。</p>
<p>CopyOnWrite 并发容器还包括 CopyOnWriteArraySet，用来代替同步 Set。</p>
<br>

<h3 id="读写规则"><a href="#读写规则" class="headerlink" title="读写规则"></a>读写规则</h3><p>CopyOnWriteArrayList 适用场景：</p>
<ul>
<li>读操作需要尽可能快，写操作即使慢一点也没关系。如白名单、黑名单、每日更新、监听器等。</li>
</ul>
<p>CopyOnWriteArrayList 读写规则：</p>
<ul>
<li><strong>读取完全不需要加锁，写入也不会阻塞读取操作。只有写入和写入之间需要同步互斥等待。</strong></li>
</ul>
<p>当 100 个线程同时向 ArrayList 中添加元素时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyOnWriteArrayListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;5&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            System.out.println(list);</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">&quot;2&quot;</span>)) &#123;</span><br><span class="line">                list.remove(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">&quot;3&quot;</span>)) &#123;</span><br><span class="line">                list.add(<span class="string">&quot;3 found&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.util.ConcurrentModificationException</span><br><span class="line">	at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:<span class="number">911</span>)</span><br><span class="line">	at java.util.ArrayList$Itr.next(ArrayList.java:<span class="number">861</span>)</span><br><span class="line">	at copyonwrite.CopyOnWriteArrayListTest.main(CopyOnWriteArrayListTest.java:<span class="number">18</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到 ArrayList 是不支持在迭代时进行修改的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    cursor = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在进行迭代时首先会判断 modCount 是否与 expectedModCount 相等，若不等说明在迭代时被修改过，就抛出异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 expectedModCount 是迭代器在初始化时就被确定好的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br></pre></td></tr></table></figure>

<p>所以普通的 ArrayList 是不支持在迭代时修改的。</p>
<p>使用 CopyOnWriteArrayList：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyOnWriteArrayListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		    CopyOnWriteArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">      	list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;5&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            System.out.println(list);</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">&quot;2&quot;</span>)) &#123;</span><br><span class="line">                list.remove(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">&quot;3&quot;</span>)) &#123;</span><br><span class="line">                list.add(<span class="string">&quot;3 found&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="number">2</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="number">3</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span> found]</span><br><span class="line"><span class="number">4</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span> found]</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>可以发现当我们在迭代的过程中虽然删除了 5 并添加了 “3 found” 但它们并没有被迭代输出。也就是说迭代过程中的修改对于迭代来说是不可见的。</p>
<br>

<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>CopyOnWrite 在进行写操作（add、set、remove 等）时会把原数组拷贝一份出来，然后在新数组进行写操作，操作完后，再将原数组引用指向到新数组。这样就不会造成 ConcurrentModificationException 的异常，因为它是读写分离的。</p>
<p>CopyOnWriteArrayList 写操作加了锁，不然多线程进行写操作时会复制多个副本；读操作没有加锁，所以可以实现并发读，但是可能读到旧的数据，比如正在执行读操作时，同时有多个写操作在进行，遇到这种场景时，就会读到旧数据。</p>
<br>

<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>数据一致性问题：CopyOnWrite 容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果希望写入的数据能马上读到就不应该使用 CopyOnWrite 容器。</li>
<li>内存占用问题：因为 CopyOnWrite 的写是复制机制，所以在进行写操作时内存里会同时驻扎两个对象的内存。</li>
</ul>
<br>

<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8673264195747942595L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The lock protecting all mutators */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">transient</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The array, accessed only via getArray/setArray. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line">  </span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>首先 CopyOnWriteArrayList 使用了 ReentrantLock 来作为锁，使用了一个 <code>Object[] array</code> 来保存元素。</p>
<p>其中的 <code>add()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">  	<span class="comment">// 上锁操作，保证同一时间只有一个线程进行添加操作</span></span><br><span class="line">    lock.lock();   </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">// 获取当前存储元素的数组</span></span><br><span class="line">        Object[] elements = getArray();  </span><br><span class="line">      	<span class="comment">// 获取当前数组长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">      	<span class="comment">// 利用 Arrays.copyOf 复制一份长度+1的数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>); </span><br><span class="line">      	<span class="comment">// 将传入add方法的参数添加到复制的数组的末尾</span></span><br><span class="line">        newElements[len] = e;   </span><br><span class="line">      	<span class="comment">// 将元素数组设定为复制出来的数组，更换引用</span></span><br><span class="line">        setArray(newElements);   </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>remove(int)</code>删除元素同样是复制原数组到一个长度减 1 的新数组里，然后对新数组进行操作，最后再把新数组赋给原数组。这个操作也上了锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> get(elements, index);</span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> len - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> <span class="title class_">Object</span>[len - <span class="number">1</span>];</span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关数组修改的操作都上了锁，也就说写操作是互斥访问的。</p>
<p>有关读操作的代码都是直接进行了访问，没有上锁，也就是说在写的同时可以读：</p>
<p><code>get()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> E <span class="title function_">get</span><span class="params">(Object[] a, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (E) a[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此，<code>CopyOnWriteArrayList</code> 是牺牲了空间来换取读写速度</strong>。</p>
<br>

<h2 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h2><p>使用队列可以在线程间传递数据（生产者消费者模式、银行转账），并且可以将考虑锁等线程安全问题转移到队列上。</p>
<br>

<h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p>阻塞队列：</p>
<ul>
<li>当队列是空的时，从队列中获取元素的操作将会被阻塞，试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其他的线程往空的队列插入新的元素；</li>
<li>当队列是满的时，往队列里添加元素的操作会被阻塞。试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞，直到其他的线程使队列重新变得空闲起来，如从队列中移除一个或者多个元素，或者完全清空队列。</li>
</ul>
<p>通常阻塞队列的一端是给生产者存数据，另一端是给消费者取数据的。阻塞队列是线程安全的，因此生产者消费者都可以是多线程的。</p>
<p>阻塞功能：</p>
<ul>
<li><code>take()</code>：获取并移除队列的头节点。若执行 take 时队列中没有数据则阻塞至队列中有数据。</li>
<li><code>put()</code>：插入元素。若队列已满则阻塞至队列中有空间。</li>
</ul>
<p>同时阻塞队列也可以自定义容量，若将容量设置为 <code>Integer.Max_VALUE</code> 则表示该阻塞队列无界。这在线程池部分被大量使用。</p>
<br>

<h3 id="BlockingQueue-主要方法"><a href="#BlockingQueue-主要方法" class="headerlink" title="BlockingQueue 主要方法"></a>BlockingQueue 主要方法</h3><ul>
<li><p>阻塞：</p>
<ul>
<li><p><code>void put(E e)</code></p>
<p>将指定元素插入此队列中，如果没有可用空间，则等待。</p>
</li>
<li><p><code>E take()</code></p>
<p>获取并移除此队列头部元素，如果没有可用元素，则等待。</p>
</li>
</ul>
<p>	</p>
</li>
<li><p>抛出异常：</p>
<ul>
<li><p><code>boolean add(E e)</code></p>
<p>顺序添加一个元素（到达上限后，再添加则会抛出异常）。</p>
</li>
<li><p><code>E remove()</code></p>
<p>获得第一个元素并移除（如果队列没有元素时，则抛出异常）。</p>
</li>
<li><p><code>E element()</code></p>
<p>获得第一个元素但不移除（如果队列没有元素时，则抛异常）。</p>
</li>
</ul>
</li>
<li><p>返回特殊值：（<strong>建议使用以下方法</strong>）</p>
<ul>
<li><p><code>boolean offer(E e)</code></p>
<p>顺序添加一个元素（到达上限后，再添加则会返回false）。</p>
</li>
<li><p><code>E poll()</code></p>
<p>获得第一个元素并移除（如果队列没有元素时，则返回null）。</p>
</li>
<li><p><code>E peek()</code></p>
<p>获得第一个元素但不移除（如果队列没有元素时，则返回null）。</p>
</li>
</ul>
</li>
</ul>
<br>

<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>ArrayBlockingQueue 是数组结构实现的有界队列，需要手动添加上限。同时还可以指定是否需要保证公平，如果保证公平那么等待了最长时间的线程会被优先处理，不过这会同时带来定的性能损耗。</p>
<p>利用 ArrayBlockingQueue 实现生产者消费者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayBlockingQueueTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayBlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.put(i);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;生产了第&quot;</span> + i + <span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; ,<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.take();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;消费了第&quot;</span> + i + <span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; ,<span class="string">&quot;消费者&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        producerThread.start();</span><br><span class="line">        consumerThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码分析，构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.items = <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">  	<span class="comment">// 底层采用锁机制保证线程安全性，可以选择使用公平锁或非公平锁</span></span><br><span class="line">    lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(fair);   </span><br><span class="line">  	<span class="comment">// 创建了两个Condition（都属于lock），用于入队和出队的线程阻塞控制</span></span><br><span class="line">    notEmpty = lock.newCondition();   </span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>put</code>和<code>offer</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;   </span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">// 如果队列已满则返回false</span></span><br><span class="line">        <span class="keyword">if</span> (count == items.length)   </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      	<span class="comment">// 队列还没满则入队返回true</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            enqueue(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">  	<span class="comment">// 检查put的是否为空</span></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">  	<span class="comment">// 上锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">  	<span class="comment">// 使用了可中断</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">// 若队列还没满则跳过while，否则等待</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">      	<span class="comment">// 入队</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      	<span class="comment">// 解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="literal">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">  	<span class="comment">// 出队操作会调用notFull的signal方法唤醒被挂起处于等待状态的线程</span></span><br><span class="line">    notFull.signal();    </span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出队操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">  	<span class="comment">// 上锁</span></span><br><span class="line">    lock.lock();   </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">// 如果队列不为空则出队，否则返回null</span></span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="literal">null</span> : dequeue();   </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">  	<span class="comment">// 可以响应中断进行加锁</span></span><br><span class="line">    lock.lockInterruptibly();  </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">          	<span class="comment">// 与入队相反，等到队列中有元素之后才可以出队，在入队时会唤醒此线程</span></span><br><span class="line">            notEmpty.await();    </span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(E x)</span> &#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">  	<span class="comment">// 对notEmpty的signal唤醒操作</span></span><br><span class="line">    notEmpty.signal();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>LinkedBlockingQueue 是由链表结构实现的无界队列，默认上限 <code>Integer.MAX_VALUE</code>。</p>
<p>其中的 take 和 put 操作分别对应着不同的两把锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br></pre></td></tr></table></figure>

<p>这样可以保证 take 和 put 操作互不干扰。</p>
<p>其中 <code>put()</code>：方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">  	<span class="comment">// 首先判断添加的是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line">  	<span class="comment">// 获取put锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">  	<span class="comment">// 可中断</span></span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">// 若队列已满则阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 还没满则入队</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">      	<span class="comment">// 队列节点数+1</span></span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">      	<span class="comment">// 如果入队完容量还没满则唤醒一个线程</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>PriorityBlockingQueue 是一个支持优先级的阻塞队列，元素的获取顺序按优先级决定而不是先进先出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">  	<span class="comment">// 可以指定初始容量（可扩容）和优先级比较规则，这里使用升序</span></span><br><span class="line">    PriorityBlockingQueue&lt;Integer&gt; queue =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PriorityBlockingQueue</span>&lt;&gt;(<span class="number">10</span>, Integer::compare); </span><br><span class="line">    queue.add(<span class="number">3</span>);</span><br><span class="line">    queue.add(<span class="number">1</span>);</span><br><span class="line">    queue.add(<span class="number">2</span>);</span><br><span class="line">  	<span class="comment">// 保存顺序并不会按照优先级排列，所以可以看到结果并不是排序后的结果</span></span><br><span class="line">    System.out.println(queue);    </span><br><span class="line">  	<span class="comment">// 但出队顺序一定是按照优先级进行的</span></span><br><span class="line">    System.out.println(queue.poll());   </span><br><span class="line">    System.out.println(queue.poll());</span><br><span class="line">    System.out.println(queue.poll());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>SynchronousQueue 容量为 0，也就是说正常情况下出队必须和入队操作成对出现。它所做的就是直接传递，因此效率很高。</p>
<p>在 SynchronousQueue 内部有一个抽象类 Transferer，它定义了一个 transfer 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Transferer</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以是put也可以是take操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 如果不是空，即作为生产者，那么表示会将传入参数元素e交给消费者</span></span><br><span class="line"><span class="comment">     *          如果为空，即作为消费者，那么表示会从生产者那里得到一个元素e并返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> 是否可以超时</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> 超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 不为空就是从生产者那里返回的，为空表示要么被中断要么超时。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> E <span class="title function_">transfer</span><span class="params">(E e, <span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上它是直接以生产者消费者模式进行的，由于不需要依靠任何容器结构来暂时存放数据，所以我们可以直接通过 transfer 方法来对生产者和消费者之间的数据进行传递。</p>
<p>比如一个线程 put 一个新的元素进入，这时如果没有其他线程调用 take 方法获取元素，那么会持续被阻塞，直到有线程取出元素，而 transfer 正是需要等生产者消费者双方都到齐了才能进行交接工作，单独只有其中一方都需要进行等待。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">  	<span class="comment">// 使用transfer方法进行数据传递</span></span><br><span class="line">    <span class="keyword">if</span> (transferer.transfer(e, <span class="literal">false</span>, <span class="number">0</span>) == <span class="literal">null</span>) &#123;  </span><br><span class="line">      	<span class="comment">// 为空表示要么被中断要么超时</span></span><br><span class="line">        Thread.interrupted();    </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它在公平和非公平模式下，有两个实现，公平模式下的 SynchronousQueue 的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TransferQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Transferer</span>&lt;E&gt; &#123;</span><br><span class="line">     <span class="comment">//头结点（头结点仅作为头结点，后续节点才是真正等待的线程节点）</span></span><br><span class="line">     <span class="keyword">transient</span> <span class="keyword">volatile</span> QNode head;</span><br><span class="line">     <span class="comment">//尾结点</span></span><br><span class="line">     <span class="keyword">transient</span> <span class="keyword">volatile</span> QNode tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 节点有生产者和消费者角色之分 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">QNode</span> &#123;</span><br><span class="line">      	<span class="comment">// 后继节点</span></span><br><span class="line">        <span class="keyword">volatile</span> QNode next;          </span><br><span class="line">      	<span class="comment">// 存储的元素</span></span><br><span class="line">        <span class="keyword">volatile</span> Object item;         </span><br><span class="line">      	<span class="comment">// 处于等待的线程，和之前的AQS一样的思路，每个线程等待的时候都会被封装为节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread waiter; </span><br><span class="line">      	<span class="comment">// 是生产者节点还是消费者节点</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> isData;         </span><br></pre></td></tr></table></figure>

<p>公平模式下，Transferer 的实现是 TransferQueue，是以先进先出的规则的进行的，内部有一个 QNode 类来保存等待的线程。</p>
<p><code>transfer()</code> 方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">transfer</span><span class="params">(E e, <span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span> &#123;</span><br><span class="line">  	<span class="comment">// 没有加锁，会多个线程之间竞争</span></span><br><span class="line">    <span class="type">QNode</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  	<span class="comment">//e为空表示消费者，不为空表示生产者</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isData</span> <span class="operator">=</span> (e != <span class="literal">null</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">QNode</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="type">QNode</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">      	<span class="comment">// 头结点尾结点任意为空（在构造的时候就不为空了）</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span> || h == <span class="literal">null</span>)</span><br><span class="line">          	<span class="comment">// 自旋</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">      	<span class="comment">// 头结点等于尾结点表示队列为空或尾结点角色和当前节点一样，这两种情况都需要入队</span></span><br><span class="line">        <span class="keyword">if</span> (h == t || t.isData == isData) &#123;</span><br><span class="line">            <span class="type">QNode</span> <span class="variable">tn</span> <span class="operator">=</span> t.next;</span><br><span class="line">          	<span class="comment">// 如果这段时间内t被其他线程修改了就进下一轮循环</span></span><br><span class="line">            <span class="keyword">if</span> (t != tail)                  </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">          	<span class="comment">// 继续校验是否为队尾，如果tn不为null则其他线程改了队尾，进下一轮循环</span></span><br><span class="line">            <span class="keyword">if</span> (tn != <span class="literal">null</span>) &#123;</span><br><span class="line">              	<span class="comment">// CAS将新的队尾节点设置为tn</span></span><br><span class="line">                advanceTail(t, tn);					</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">// 超时返回null</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>)        </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="literal">null</span>)</span><br><span class="line">              	<span class="comment">// 构造当前结点，准备加入等待队列</span></span><br><span class="line">                s = <span class="keyword">new</span> <span class="title class_">QNode</span>(e, isData);</span><br><span class="line">          	<span class="comment">// CAS添加当前节点为尾结点的下一个，如果失败则其他线程又抢先了，进下一轮循环</span></span><br><span class="line">            <span class="keyword">if</span> (!t.casNext(<span class="literal">null</span>, s))        </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">          	 <span class="comment">// 新的队尾元素修改为s</span></span><br><span class="line">            advanceTail(t, s);</span><br><span class="line">          	<span class="comment">// 开始等待s所对应的消费者或是生产者进行交接，比如s现在是生产者，那么它就需要等到一个消费者的到来才会继续（这个方法会先进行自旋等待匹配，如果自旋一定次数后还是没有匹配成功，那么就挂起）</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> awaitFulfill(s, e, timed, nanos); </span><br><span class="line">          	<span class="comment">// 如果返回s本身说明等待状态下被取消</span></span><br><span class="line">            <span class="keyword">if</span> (x == s) &#123;                   </span><br><span class="line">                clean(t, s);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">						<span class="comment">// 如果s操作完成之后没有离开队列则将其手动丢弃</span></span><br><span class="line">            <span class="keyword">if</span> (!s.isOffList()) &#123; </span><br><span class="line">              	 <span class="comment">// 将s设定为新的首节点(注意头节点仅作为头结点，并非处于等待的线程节点)</span></span><br><span class="line">                advanceHead(t, s);</span><br><span class="line">              	<span class="comment">// 删除s内的其他信息</span></span><br><span class="line">                <span class="keyword">if</span> (x != <span class="literal">null</span>)              </span><br><span class="line">                    s.item = s;</span><br><span class="line">                s.waiter = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">// 如果当前是消费者，直接返回从生产者拿来的元素x</span></span><br><span class="line">            <span class="keyword">return</span> (x != <span class="literal">null</span>) ? (E)x : e;   </span><br><span class="line">					 <span class="comment">// 与队列中结点类型匹配</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	<span class="comment">// 获取头结点的下一个接口，准备进行交接工作</span></span><br><span class="line">            <span class="type">QNode</span> <span class="variable">m</span> <span class="operator">=</span> h.next;               </span><br><span class="line">            <span class="keyword">if</span> (t != tail || m == <span class="literal">null</span> || h != head)</span><br><span class="line">              	<span class="comment">// 判断其他线程是否先修改，如果修改过那么开下一轮</span></span><br><span class="line">                <span class="keyword">continue</span>;                   </span><br><span class="line"></span><br><span class="line">            <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> m.item;</span><br><span class="line">          	<span class="comment">// 判断节点类型，如果是相同的操作，则下一轮</span></span><br><span class="line">            <span class="keyword">if</span> (isData == (x != <span class="literal">null</span>) ||</span><br><span class="line">                <span class="comment">// 或当前操作被取消</span></span><br><span class="line">                x == m ||</span><br><span class="line">                <span class="comment">// 都不是最后再进行CAS替换m中的元素，成功表示交接成功，失败就下一轮</span></span><br><span class="line">                !m.casItem(x, e)) &#123;         </span><br><span class="line">                advanceHead(h, m);          <span class="comment">// dequeue and retry</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">						<span class="comment">// 成功交接，新的头结点改为m</span></span><br><span class="line">            advanceHead(h, m);</span><br><span class="line">          	<span class="comment">// m中的等待交接的线程继续，交接完成</span></span><br><span class="line">            LockSupport.unpark(m.waiter);   </span><br><span class="line">            <span class="keyword">return</span> (x != <span class="literal">null</span>) ? (E)x : e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于非公平模式下的 SynchronousQueue，则是采用的栈结构来存储等待节点，但是思路也是与这里的一致，需要等待并进行匹配操作。</p>
<br>

<h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>DelayQueue 能够实现延迟获取元素，同样支持优先级。</p>
<p>DelayQueue 能实现延时出队，也就是说当一个元素插入后若没有超过一定时间，那么是无法让此元素出队的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayQueue</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Delayed</span>&gt; <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">BlockingQueue</span>&lt;E&gt; &#123;</span><br></pre></td></tr></table></figure>

<p>可以看到此类只接受 Delayed 的实现类作为元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承了Comparable，它支持优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Delayed</span> <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Delayed&gt; &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取剩余等待时间，正数表示还需要进行等待，0或负数表示等待结束</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">getDelay</span><span class="params">(TimeUnit unit)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">implements</span> <span class="title class_">Delayed</span> &#123;</span><br><span class="line">  	<span class="comment">//延迟时间，这里以毫秒为单位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> time;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> priority;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> startTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Test</span><span class="params">(<span class="type">long</span> time, <span class="type">int</span> priority, String data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.time = TimeUnit.SECONDS.toMillis(time);</span><br><span class="line">        <span class="built_in">this</span>.priority = priority;</span><br><span class="line">        <span class="built_in">this</span>.startTime = System.currentTimeMillis(); </span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getDelay</span><span class="params">(TimeUnit unit)</span> &#123;</span><br><span class="line">      	<span class="comment">// 计算剩余时间 = 设定时间 - 已度过时间(= 当前时间 - 开始时间)</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">leftTime</span> <span class="operator">=</span> time - (System.currentTimeMillis() - startTime); </span><br><span class="line">      	<span class="comment">// 单位由队列指定（默认是纳秒单位）</span></span><br><span class="line">        <span class="keyword">return</span> unit.convert(leftTime, TimeUnit.MILLISECONDS);  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Delayed o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Test)</span><br><span class="line">          	<span class="comment">// 优先级越小越优先</span></span><br><span class="line">            <span class="keyword">return</span> priority - ((Test) o).priority;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在主方法中使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    DelayQueue&lt;Test&gt; queue = <span class="keyword">new</span> <span class="title class_">DelayQueue</span>&lt;&gt;();</span><br><span class="line">  	<span class="comment">// 1秒钟延时</span></span><br><span class="line">    queue.add(<span class="keyword">new</span> <span class="title class_">Test</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;2号&quot;</span>)); </span><br><span class="line">  	<span class="comment">// 1秒钟延时，优先级最高</span></span><br><span class="line">    queue.add(<span class="keyword">new</span> <span class="title class_">Test</span>(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;1号&quot;</span>));   </span><br><span class="line">		<span class="comment">// 出队顺序是依照优先级来的，即使一个元素已经可以出队了，依然需要等待优先级更高的元素到期</span></span><br><span class="line">    System.out.println(queue.take());    </span><br><span class="line">    System.out.println(queue.take());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DelayQueue 的 <code>add()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">// 向内部维护的一个优先级队列添加元素，并不是DelayQueue本身存储元素</span></span><br><span class="line">        q.offer(e);   </span><br><span class="line">      	<span class="comment">// 如果入队后队首就是当前元素，那么直接进行一次唤醒操作（可能之前就有其他线程在等待）</span></span><br><span class="line">        <span class="keyword">if</span> (q.peek() == e) &#123;   </span><br><span class="line">            leader = <span class="literal">null</span>;</span><br><span class="line">            available.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    offer(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>take()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          	<span class="comment">// 获取队首元素</span></span><br><span class="line">            <span class="type">E</span> <span class="variable">first</span> <span class="operator">=</span> q.peek(); </span><br><span class="line">          	<span class="comment">// 如果为空表示队列为空，等待元素进入</span></span><br><span class="line">            <span class="keyword">if</span> (first == <span class="literal">null</span>)     </span><br><span class="line">                available.await();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              	<span class="comment">// 获取延迟，传入的时间单位是纳秒</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> first.getDelay(NANOSECONDS);    </span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                  	<span class="comment">// 如果获取到延迟时间小于0，说明可以直接出队返回</span></span><br><span class="line">                    <span class="keyword">return</span> q.poll();     </span><br><span class="line">                first = <span class="literal">null</span>;</span><br><span class="line">              	<span class="comment">// 用leader来减少不必要的等待时间，如果不是null那说明有线程在等待，为null说明没有线程等待</span></span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="literal">null</span>)   </span><br><span class="line">                  	<span class="comment">// 如果其他线程已经在等元素了，那么当前线程直接进永久等待状态</span></span><br><span class="line">                    available.await();   </span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">Thread</span> <span class="variable">thisThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                  	<span class="comment">// 没有线程等待就将leader设定为当前线程</span></span><br><span class="line">                    leader = thisThread;    </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                      	<span class="comment">// 获取到的延迟大于0，那么就需要等待延迟时间，再开始下一次获取</span></span><br><span class="line">                        available.awaitNanos(delay);     </span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="literal">null</span> &amp;&amp; q.peek() != <span class="literal">null</span>)</span><br><span class="line">          	<span class="comment">// 当前take结束之后唤醒一个其他永久等待状态下的线程</span></span><br><span class="line">            available.signal();   </span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="选择合适的队列"><a href="#选择合适的队列" class="headerlink" title="选择合适的队列"></a>选择合适的队列</h3><p>需要考虑：</p>
<ul>
<li>边界</li>
<li>空间</li>
<li>吞吐量</li>
</ul>
<br>

<h1 id="并发流程控制"><a href="#并发流程控制" class="headerlink" title="并发流程控制"></a>并发流程控制</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>线程默认是由线程调度器执行的，若要指定<strong>线程的执行顺序</strong>就需要使用控制并发流程的工具类，它能帮助我们让线程之间合作。让线程之间相互配合，来满足业务逻辑。</p>
<table>
<thead>
<tr>
<th>类</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Semaphore</td>
<td>信号量，可以通过“许可证”的数量来保证线程之间的配合。</td>
<td>线程只有在拿到”许可证“后才能继续运行。相较于其他同步器，更加灵活。</td>
</tr>
<tr>
<td>CyclicBarrier</td>
<td>线程会等待，直到足够多线程达到了事先规定的数目。一旦达到出发条件就可以进行下一步的动作。</td>
<td>适用于线程之间互相等待处理结果就绪的场景。</td>
</tr>
<tr>
<td>Phaser</td>
<td>与 CyclicBarrier 类似，但计数可变。</td>
<td>Java 7 加入</td>
</tr>
<tr>
<td>CountDownLatch</td>
<td>与 Cyclic 类似，数量递减到 0 时触发动作。</td>
<td>不可重复使用</td>
</tr>
<tr>
<td>Exchanger</td>
<td>让两个线程在合适时交换对象</td>
<td>适用于当两个线程工作在同一个类的不同实例上的场景，用于数据交换。</td>
</tr>
<tr>
<td>Condition</td>
<td>可以控制线程的”等待“和“唤醒”</td>
<td>Object.wait() 的升级版</td>
</tr>
</tbody></table>
<br>

<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>CountDownLatch 即倒数门闩。在构造 CountDownLatch 时需要传入一个整数 n，在这个整数倒数到 0 之前，主线程需要等待在门口，而这个倒数过程则是由各个执行线程驱动的，每个线程执行完一个任务倒数一次。</p>
<p>CountDownLatch 的作用就是等待其他的线程都执行完任务，必要时可以对各个任务的执行结果进行汇总，然后主线程才继续往下执行。</p>
<br>

<h3 id="主要方法-1"><a href="#主要方法-1" class="headerlink" title="主要方法"></a>主要方法</h3><ul>
<li><p><code>CountDownLatch(int count)</code>：唯一的构造方法，参数 count 为需要倒数的数值。</p>
</li>
<li><p><code>await()</code>：调用此方法的线程会被挂起，等待到 count 值为 0 才继续执行。</p>
</li>
<li><p><code>countDown()</code>：将 count 值减 1 ，直到为 0 时等待的线程才会被唤醒。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/XkVF4U"><img data-src="https://s1.ax1x.com/2022/05/25/XkVF4U.png" alt="XkVF4U.png"></a></p>
<br>

<h3 id="典型用法"><a href="#典型用法" class="headerlink" title="典型用法"></a>典型用法</h3><p>一个线程需要等待五个线程都完成了各种的任务后才算完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">no</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;No.&quot;</span> + no + <span class="string">&quot; Completed&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Wait for check...&quot;</span>);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;Completed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Wait <span class="keyword">for</span> check...</span><br><span class="line">No<span class="number">.5</span> Completed</span><br><span class="line">No<span class="number">.2</span> Completed</span><br><span class="line">No<span class="number">.4</span> Completed</span><br><span class="line">No<span class="number">.3</span> Completed</span><br><span class="line">No<span class="number">.1</span> Completed</span><br><span class="line">Completed</span><br></pre></td></tr></table></figure>

<p>还可以让多个线程等待某一个线程的信号后同时执行（服务器压测）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">no</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;wait for count down latch&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                    System.out.println(<span class="string">&quot;No.&quot;</span> + no + <span class="string">&quot; doing...&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Begin&quot;</span>);</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">wait <span class="keyword">for</span> count down latch</span><br><span class="line">wait <span class="keyword">for</span> count down latch</span><br><span class="line">wait <span class="keyword">for</span> count down latch</span><br><span class="line">wait <span class="keyword">for</span> count down latch</span><br><span class="line">wait <span class="keyword">for</span> count down latch</span><br><span class="line">Begin</span><br><span class="line">No<span class="number">.1</span> doing...</span><br><span class="line">No<span class="number">.2</span> doing...</span><br><span class="line">No<span class="number">.3</span> doing...</span><br><span class="line">No<span class="number">.4</span> doing...</span><br><span class="line">No<span class="number">.5</span> doing...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还可以将这两种用法结合起来，模拟跑步比赛中五人比赛需要等待一个裁判的发令，裁判需要等待五人到达终点后宣布比赛结束的场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">end</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">no</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;No.&quot;</span> + no + <span class="string">&quot; 准备完毕&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    begin.await();</span><br><span class="line">                    System.out.println(<span class="string">&quot;No.&quot;</span> + no + <span class="string">&quot; 开始跑步...&quot;</span>);</span><br><span class="line">                    Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;No.&quot;</span> + no + <span class="string">&quot; 到达终点&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    end.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;比赛开始...&quot;</span>);</span><br><span class="line">        begin.countDown();</span><br><span class="line"></span><br><span class="line">        end.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;比赛结束...&quot;</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">No<span class="number">.1</span> 准备完毕</span><br><span class="line">No<span class="number">.3</span> 准备完毕</span><br><span class="line">No<span class="number">.2</span> 准备完毕</span><br><span class="line">No<span class="number">.4</span> 准备完毕</span><br><span class="line">No<span class="number">.5</span> 准备完毕</span><br><span class="line">比赛开始...</span><br><span class="line">No<span class="number">.1</span> 开始跑步...</span><br><span class="line">No<span class="number">.3</span> 开始跑步...</span><br><span class="line">No<span class="number">.2</span> 开始跑步...</span><br><span class="line">No<span class="number">.4</span> 开始跑步...</span><br><span class="line">No<span class="number">.5</span> 开始跑步...</span><br><span class="line">No<span class="number">.3</span> 到达终点</span><br><span class="line">No<span class="number">.4</span> 到达终点</span><br><span class="line">No<span class="number">.5</span> 到达终点</span><br><span class="line">No<span class="number">.2</span> 到达终点</span><br><span class="line">No<span class="number">.1</span> 到达终点</span><br><span class="line">比赛结束...</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>一等多和多等一不是 CountDownLatch 的唯一用法，还可以实现多等多、一等一。</li>
<li>CountDownLatch 是不可重用的，如果需要重新计数可以考虑使用 CyclicBarrier 或创建新的 CountDownLatch 实例。</li>
</ul>
<br>

<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore 可以用来限制或管理数量有限的资源的使用情况。</p>
<p>类似于许可证，获取到许可证才可以挖矿挖煤。</p>
<p>信号量的作用是维护一个许可证的计数，线程获取许可证并使信号量剩余的许可证数量减 1，线程释放一个许可证则信号量许可证数量加 1。当信号量所拥有的许可证数量为 0 时，下一个获取许可证的线程就需要等待，直到有另外的线程释放许可证。</p>
<br>

<h3 id="主要方法-2"><a href="#主要方法-2" class="headerlink" title="主要方法"></a>主要方法</h3><ul>
<li><code>Semaphore(int permits, boolean fair)</code>：permits 为许可证数量，fair 为是否公平。若设置为 true，那么 Semaphore 会将之前等待的线程放入 FIFO 队列中，以便于在释放许可证时首先分发给等待时间最长的线程。</li>
<li><code>acquire()</code>：获取许可证。</li>
<li><code>acquire(int permits)</code>：获取指定数量的许可证。</li>
<li><code>acquireUninterruptibly()</code>：无中断地获取许可证。</li>
<li><code>tryAcquire()</code>：尝试获取许可证，不会阻塞。</li>
<li><code>tryAcquire(timeout)</code>：尝试获取许可证，在等待 timeout 时长后则不再等待。</li>
<li><code>release()</code>：释放许可证。</li>
</ul>
<br>

<h3 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h3><ul>
<li>初始化 Semaphore 并指定许可证数量</li>
<li>在需要被执行的代码前加 <code>acquire()</code> 或 <code>acquireUninterruptibly()</code> 方法</li>
<li>任务执行结束后调用 <code>release()</code> 方法释放许可证</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">50</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get semaphore&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; release semaphore&quot;</span>);</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现我们初始化了 3 个许可证那么线程总是三个三个地获取到许可证：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> get semaphore</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> get semaphore</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> get semaphore</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> release semaphore</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> release semaphore</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> release semaphore</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> get semaphore</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> get semaphore</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span> get semaphore</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> release semaphore</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> release semaphore</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span> release semaphore</span><br></pre></td></tr></table></figure>

<p>除了这样正常使用 Semaphore，还可以一次性获取或释放多个许可证。</p>
<p>比如 TaskA 会调用很消耗资源的 method1()，而 TaskB 调用的是不太消耗资源的 method2()。假设一共有 5 个许可<br>证。那么就可以要求 TaskA 一次性获取 5 个许可证才能执行，而 TaskB 只需要获取到 1 个许可证就能执行。这样就避免了 A 和 B 同时运行的情况，我们可以根据自己的需求合理分配资源。</p>
<p><strong>注意：</strong></p>
<ul>
<li>获取和释放的许可证数量必须一致，否则会导致许可证不够而 OOM。	</li>
<li>在初始化 Semaphore 时最好设置公平为 true。</li>
<li>Semaphore 除了可以控制临界区最多同时可以有多少个线程访问外，还可以实现条件等待。如线程 1 需要在线程 2 完成后才能执行，那么就可以使 线程 1 acquire() 而线程 2 完成后再 release()。相当于轻量级的 CountDownLatch。</li>
</ul>
<br>

<h2 id="Condition-接口"><a href="#Condition-接口" class="headerlink" title="Condition 接口"></a>Condition 接口</h2><p>Condition 又称为条件对象，Condition 接口是为了与 Lock 配合实现等待&#x2F;通知模式, 可以将 Condition 等待通知和 Lock 的关系与 Object 的等待通知和 synchronized 的关系类比;</p>
<ul>
<li>synchronized 是通过锁对象即 Object 的 wait() 和 notify() 实现等待通知</li>
<li>Lock 则可以通过 Condition 的 await() 和 signal() 实现等待通知</li>
</ul>
<p>当线程 1 需要等待某个条件时就执行 condition.await() 方法，一旦执行了 await() 方法线程就会进入阻塞状态。当另一个线程 2 执行完对应的条件后会去执行 condition.signal() 方法，这时 JVM 就会从被阻塞的线程中找到等待该 condition 的线程，当线程 1 收到可执行信号时它的线程状态就会变成 Runnable 可执行状态。</p>
<br>

<h3 id="主要方法-3"><a href="#主要方法-3" class="headerlink" title="主要方法"></a>主要方法</h3><ul>
<li><p><code>await()</code> ：让线程进入等待，如果其他线程调用同一 Condition 对象的 notify&#x2F;notifyAll，那么等待的线程可能被唤醒。</p>
</li>
<li><p><code>signal()</code> ：唤醒等待的线程</p>
</li>
<li><p><code>signalAll()</code> ：唤醒所有线程</p>
</li>
</ul>
<p><code>signal()</code> 是公平的，只会唤醒等待时间最长的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConditionTest</span> <span class="variable">conditionTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConditionTest</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conditionTest.method1();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conditionTest.method2();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;No condition, begin awaiting&quot;</span>);</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;With condition, end awaiting&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Complete condition, begin signaling&quot;</span>);</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 method2() 还未执行完时，线程 1 没有 Condition 因此 await()。当线程 2 执行完后会 signal() 正在等待这个 Condition 的线程，此时线程 1 拥有 Condition 因此可以执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">No condition, begin awaiting</span><br><span class="line">Complete condition, begin signaling</span><br><span class="line">With condition, end awaiting</span><br></pre></td></tr></table></figure>

<p>还可以使用 Condition 实现生产者消费者模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> condition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionTest2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">queueSize</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(queueSize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">noFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            comsume();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费操作</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">comsume</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;队列空，等待数据&quot;</span>);</span><br><span class="line">                        notEmpty.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                    noFull.signalAll();</span><br><span class="line">                    System.out.println(<span class="string">&quot;从队列里取走了一个数据，队列还剩余空间&quot;</span>+(queueSize-queue.size())+<span class="string">&quot;个元素&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产者</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            produce();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生产操作</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.size()==queueSize)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;队列满，等待消费&quot;</span>);</span><br><span class="line">                        noFull.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.offer(<span class="number">1</span>);</span><br><span class="line">                    notEmpty.signalAll();</span><br><span class="line">                    System.out.println(<span class="string">&quot;给队列生成了一个数据，队列有&quot;</span>+queue.size()+<span class="string">&quot;个元素&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>();</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>();</span><br><span class="line">        consumer.start();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li><code>await()</code> 方法会自动释放持有的 Lock</li>
<li>调用 <code>await()</code> 时必须持有锁</li>
</ul>
<br>

<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>CyclicBarrier 与 CountDownLatch 类似，都可以阻塞一组线程。</p>
<p>当有大量线程相互配合，分别计算不同任务，并且需要最后统一汇总时，可以使用 CyclicBarrier 。CycliBarrier 可以构造一个集结点，当某一个线程执行完毕它就会到集合点等待，直到所有线程都到了集结点，那么该栅栏就被撤销，所有线程统一出发，继续执行剩下的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span>, () -&gt; System.out.println(<span class="string">&quot;这一车已满，出发&quot;</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">People</span>(barrier)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        CyclicBarrier barrier;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">People</span><span class="params">(CyclicBarrier barrier)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.barrier = barrier;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 正前往集合点&quot;</span>);</span><br><span class="line">                Thread.sleep((<span class="type">long</span>) (Math.random()*<span class="number">10000</span>));</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 已到达集合点，准备出发&quot;</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span> 正前往集合点</span><br><span class="line">Thread-<span class="number">2</span> 正前往集合点</span><br><span class="line">Thread-<span class="number">3</span> 正前往集合点</span><br><span class="line">Thread-<span class="number">1</span> 正前往集合点</span><br><span class="line">Thread-<span class="number">4</span> 正前往集合点</span><br><span class="line">Thread-<span class="number">0</span> 已到达集合点，准备出发</span><br><span class="line">Thread-<span class="number">2</span> 已到达集合点，准备出发</span><br><span class="line">Thread-<span class="number">3</span> 已到达集合点，准备出发</span><br><span class="line">Thread-<span class="number">4</span> 已到达集合点，准备出发</span><br><span class="line">Thread-<span class="number">1</span> 已到达集合点，准备出发</span><br><span class="line">这一车已满，出发</span><br></pre></td></tr></table></figure>

<br>

<h3 id="CyclicBarrier-和-CountDownLatch-的区别"><a href="#CyclicBarrier-和-CountDownLatch-的区别" class="headerlink" title="CyclicBarrier 和 CountDownLatch 的区别"></a>CyclicBarrier 和 CountDownLatch 的区别</h3><ul>
<li>作用不同：CyclicBarrier 要等固定数量的线程都到达了栅栏位置才能继续执行，而 CountDownLatch 只需等待数字到 0。也就是说 CountDownLatch 用于事件而 CycliBarrier 是用于线程的。</li>
<li>可重用性不同：CyclicBarrier 可以重复使用，CountDownLatch 在倒数到 0 并触发门闩打开后就不能再次使用了，除非新建新的实例。</li>
</ul>
<br>

<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>AQS 全称是 AbstractQueuedSynchronizer，中文译为抽象队列式同步器。</p>
<p>在之前学习的如 ReentantLock 和 Semaphore 就十分类似，它们都像是一个闸门，每次都只允许一定数量的线程通过，ReentrantLock 只允许一个而 Semaphore 可以允许规定数量的线程通过。同时当线程到达时，ReentrantLock 通过<code>lock()</code> 方法、Semaphore 通过 <code>acquire()</code> 方法让线程获取资源。</p>
<p>只是因为这个抽象类对于 JUC 并发包非常重要， JUC 包中的 ReentrantLock、Semaphore、ReentrantReadWriteLock、CountDownLatch 等等几乎所有的类都是基于 AQS 实现的。</p>
<p>比如在 Semaphore 内部有一个 Sync 类，它继承自 AQS：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Semaphore</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3222578661600680210L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1192457210091910933L</span>;</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>CountDownLatch 也是如此：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatch</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">4982264981922014374L</span>;</span><br><span class="line">      </span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AQS 就是一个用于构建锁、同步器、协作工具类的工具类（框架）。AQS 帮助实现了：</p>
<ul>
<li>同步状态的原子性管理</li>
<li>线程的阻塞与唤醒</li>
<li>队列的管理</li>
</ul>
<p>因此，AQS 将这些功能实现后，其他类只需要关心具体的业务逻辑而不需要每个类都单独实现这些功能了。AQS 的实现类有：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/XELtXD"><img data-src="https://s1.ax1x.com/2022/05/26/XELtXD.png" alt="XELtXD.png"></a></p>
<br>

<h2 id="AQS-内部原理"><a href="#AQS-内部原理" class="headerlink" title="AQS 内部原理"></a>AQS 内部原理</h2><p>AQS 最核心的三大部分：</p>
<ul>
<li>state 状态</li>
<li>控制线程抢锁和配合的 FIFO 队列</li>
<li>期望协作工具类去实现的获取&#x2F;释放等重要方法</li>
</ul>
<h3 id="state-状态"><a href="#state-状态" class="headerlink" title="state 状态"></a>state 状态</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br></pre></td></tr></table></figure>

<p>这里的 state 的具体含义，会根据具体实现类的不同而不同。比如在 Semaphore 里它表示”剩余的许可证的数量“，而在 CountDownLatch 里，它表示”还需要倒数的数量”。</p>
<p>state 是 volatile 修饰的，会被并发地修改，因此所有修改 state 的方法都需要保证线程安全，如 <code>getState</code>、<code>setState</code> 以及 <code>compareAndSetState</code> 操作来读取和更新这个状态。这些方法都依赖于 Atomic 包的支持：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 ReentrantLock 中，state 用来表示锁的占有情况，包括可重入计数，当 state 的值为 0 时标识该 Lock 不被任何线程所占有。</p>
<br>

<h3 id="FIFO-队列"><a href="#FIFO-队列" class="headerlink" title="FIFO 队列"></a>FIFO 队列</h3><p>这个队列用来存放等待的线程。AQS 像是个排队管理器，当多个线程争用同一把锁时，必须有排队机制将没能获取到锁的线程串在一起。当锁释放时，锁管理器就会挑选一个合适的线程来占有这个刚刚释放的锁。</p>
<p>AQS 会维护一个等待的线程队列，把线程都放到这个队列里，且这个队列是双向链表的形式：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/XEjFkd"><img data-src="https://s1.ax1x.com/2022/05/26/XEjFkd.png" alt="XEjFkd.png"></a></p>
<p>其中 head 是持有锁的线程，其余 node 即为等待队列中的其他线程。</p>
<br>

<h3 id="获取-x2F-释放的方法"><a href="#获取-x2F-释放的方法" class="headerlink" title="获取&#x2F;释放的方法"></a>获取&#x2F;释放的方法</h3><p>这里的获取和释放方法是利用 AQS 的协作工具类中最重要的方法，是由协作类实现的，并且含义各不相同。</p>
<ul>
<li><p>获取方法</p>
<p>获取操作依赖 state 变量，经常会阻塞(如获取不到锁时)，在 Semaphore 中获取就是 <code>acquire()</code> 方法，作用是获取一个许可证，能否获取到取决于 state 的值。而在 CountDownLatch 中获取是 <code>await()</code> 方法，作用是等待直到倒数结束。</p>
</li>
<li><p>释放方法</p>
<p>释放操作不会阻塞，在 Semaphore 中，释放就是 <code>release()</code> 方法，作用是释放一个许可证。在 CountDownLatch 中，释放是 <code>countDown()</code> 方法，作用是倒数1个数。</p>
</li>
</ul>
<br>

<h2 id="AQS-应用实例"><a href="#AQS-应用实例" class="headerlink" title="AQS 应用实例"></a>AQS 应用实例</h2><h3 id="AQS-源码"><a href="#AQS-源码" class="headerlink" title="AQS 源码"></a>AQS 源码</h3><p>CLH 队列：链表结构。在头尾结点中需要特别指出的是头结点是一个空对象结点，无任何意义，即傀儡结点。每一个 Node 结点都维护了一个指向前驱的指针和指向后驱的指针，结点与结点之间相互关联构成链表。入队在尾，出队在头，出队后需要激活该出队结点的后继结点，若后继结点为空或后继结点 waitStatus&gt;0，则从队尾向前遍历取 waitStatus&lt;0 的触发阻塞唤醒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个处于等待状态的线程都可以是一个节点，且每个节点有多种状态的</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="comment">// 每个节点都可以被分为独占模式节点或是共享模式节点，分别适用于独占锁和共享锁</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待状态</span></span><br><span class="line">        <span class="comment">// 表示已失效，可能是由于超时或中断，此节点被取消。</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 此节点后面的节点被挂起(进入等待状态)</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 在条件队列中的节点</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 传播，一般用于共享锁</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// 等待值状态</span></span><br><span class="line">    	<span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line">    	<span class="comment">// 指针</span></span><br><span class="line">    	<span class="keyword">volatile</span> Node prev;</span><br><span class="line">    	<span class="keyword">volatile</span> Node next;</span><br><span class="line">    	<span class="comment">// 每一个线程都可以被封装进一个节点进入等待队列</span></span><br><span class="line">    	<span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    </span><br><span class="line">   		<span class="comment">// 在等待队列中表示模式，条件队列中表示下一个节点的指针</span></span><br><span class="line">    	Node nextWaiter;</span><br><span class="line">    </span><br><span class="line">    	<span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;</span><br><span class="line">        	<span class="type">return</span> <span class="variable">nextWaiter</span> <span class="operator">=</span>= SHARED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        Node() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, Node mode) &#123;</span><br><span class="line">            <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">            <span class="built_in">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, <span class="type">int</span> waitStatus) &#123;</span><br><span class="line">            <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">            <span class="built_in">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>刚开始的 <code>head</code>和<code>tail</code>都是 null，<code>status</code>为默认值 0：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br></pre></td></tr></table></figure>

<p>双向链表的初始化是在实际使用时才开始：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用UnSafe类进行操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line"><span class="comment">// 记录类中属性的在内存中的偏移地址，方便Unsafe类直接操作内存进行赋值等（直接修改对应地址的内存)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> stateOffset;	<span class="comment">// 对应AQS类中的state成员字段</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> headOffset;	<span class="comment">// 对应AQS类中的head头结点成员字段</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> tailOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> waitStatusOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> nextOffset;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态代码块,在类加载时自动获取偏移地址</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stateOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;state&quot;</span>));</span><br><span class="line">        headOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;head&quot;</span>));</span><br><span class="line">        tailOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;tail&quot;</span>));</span><br><span class="line">        waitStatusOffset = unsafe.objectFieldOffset</span><br><span class="line">            (Node.class.getDeclaredField(<span class="string">&quot;waitStatus&quot;</span>));</span><br><span class="line">        nextOffset = unsafe.objectFieldOffset</span><br><span class="line">            (Node.class.getDeclaredField(<span class="string">&quot;next&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过CAS操作来修改头结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetHead</span><span class="params">(Node update)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用Unsafe类的compareAndSwap0bject方法，通过CAS算法比较对象并替换</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="built_in">this</span>, headOffset, <span class="literal">null</span>, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetTail</span><span class="params">(Node expect, Node update)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="built_in">this</span>, tailOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetWaitStatus</span><span class="params">(Node node, <span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(node, waitStatusOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetNext</span><span class="params">(Node node, Node expect, Node update)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(node, nextOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现由于 AQS 要使用到 CAS 算法，因此使用了 Unsafe 工具类。所有对 AQS 类中成员字段的修改都有对应的 CAS 操作封装。</p>
<p>AQS 提供了一些可重写的方法（根据不同的锁类型和机制，可以自由定制规则，并且为独占式和非独占式锁都提供了对应的方法），以及一些已经写好的模板方法（模板方法会调用这些可重写的方法），使用此类只需要将可重写的方法进行重写，并调用提供的模板方法，从而实现锁功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 独占式获取同步状态，查看同步状态是否和参数一致</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 独占式释放同步状态</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享式获取同步状态,返回值大于0表示成功,否则失败</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享式释放同步状态</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否在独占模式下被当前线程占用（锁是否被当前线程持有）</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些需要重写的方法是默认抛出 <code>UnsupportedOperationException</code>，也就是说根据不同的锁类型需要去实现对应的方法。</p>
<br>

<h3 id="CountDownLatch-1"><a href="#CountDownLatch-1" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><ol>
<li><strong>构造方法</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CountDownLatch</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">  	<span class="comment">// 倒数的数 &gt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">  	<span class="comment">// 构造 Sync实例，传入 count</span></span><br><span class="line">    <span class="built_in">this</span>.sync = <span class="keyword">new</span> <span class="title class_">Sync</span>(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 CountDownLatch 构造方法中只对传入的参数进行了判断，更多的交给了 Sync 的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sync(<span class="type">int</span> count) &#123;</span><br><span class="line">  	<span class="comment">// 将 state 设置为 count</span></span><br><span class="line">    setState(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Sync 继承了 AQS，将 AQS 中的 state 赋值为 count，即在 CountDownLatch 中 state 表示倒数的数。</p>
<br>

<ol start="2">
<li><strong>getCount</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CountDownLatch 的 <code>getCount()</code> 方法也调用了 Sync 中的 <code>getState()</code> 方法来返回当前的 state：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<ol start="3">
<li><strong>await</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CountDownLatch 中的 <code>await()</code> 方法调用了 Sync 中的 <code>acquireSharedInterruptibly()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">  	<span class="comment">// 中断判断</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">  	<span class="comment">// 判断是否需要等待</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">      	<span class="comment">// 进入等待队列</span></span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先调用 CountDownLatch 中重写的  <code>tryAcquireShared()</code> 方法来判断当前状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">  	<span class="comment">// 若当前state为0则返回1，表示当前没有倒数。若当前state不为0则返回-1，表示当前正在倒数</span></span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若返回了 1 则不用进入等待队列，若返回 -1 则调用 AQS 中的 <code>doAcquireSharedInterruptibly()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">  	<span class="comment">// 将当前线程包装成node结点</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">              	<span class="comment">// 当节点位于队首时，再次尝试获取锁</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">              	<span class="comment">// 若尝试成功</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                  	<span class="comment">// 新的头结点设置为当前结点</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                  	<span class="comment">// 没有失败</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">// 再次尝试获取锁失败</span></span><br><span class="line">            <span class="comment">// 将当前节点的前驱节点等待状态设置为SIGNAL，如果失败则开启下一轮循环直到成功</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                <span class="comment">// 让线程进入等待队列</span></span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先将线程包装成结点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 首先尝试使用CAS入队，如果这个时候其他线程也在入队(就是不止一个线程在同一时间争抢这把锁)就进入enq()</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// CAS快速入队失败时调用</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">  	<span class="comment">// 自旋形式入队</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">      	<span class="comment">//说明头结点和尾结点还没初始化</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">          	<span class="comment">// 初始化头节点和尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">              	<span class="comment">// 只有CAS成功的情况下，才算入队成功，如果CAS失败，那说明其他线程同一时间也在入队，并且手速还比当前线程快，刚好走到CAS操作的时候，其他线程就先入队了，那么这个时候node.prev就不是我们预期的节点了，而是另一个线程新入队的节点,所以得进下一次循环再来一次CAS，这种形式就是自旋</span></span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在再次获取失败时使用 <code>parkAndCheckInterrupt()</code> 方法将线程加入等待队列并阻塞：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">  	<span class="comment">// 调用park方法</span></span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LockSupport 中的 <code>park()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">(Object blocker)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">  	<span class="comment">// 调用unsafe中的park</span></span><br><span class="line">    UNSAFE.park(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    setBlocker(t, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<ol start="4">
<li><strong>countDown</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CountDownLatch 中的 <code>countDown()</code> 方法调用了 Sync 中的 <code>releaseShared()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">  	<span class="comment">// 尝试释放</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">      	<span class="comment">// 当tryReleaseShared返回true时唤醒等待队列中的线程</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>releaseShared()</code> 方法中首先调用了 CountDownLatch 实现的 <code>tryReleaseShared()</code> 方法来进行倒数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">  	<span class="comment">// CAS</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      	<span class="comment">// 获取当前state，即倒数的数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">      	<span class="comment">// 如果state为0则表示倒数结束</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">          	<span class="comment">// 返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      	<span class="comment">// 如果倒数不为0，先计算下一个倒数的数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c-<span class="number">1</span>;</span><br><span class="line">      	<span class="comment">// CAS操作来倒数</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">          	<span class="comment">// 当CAS成功且下一个倒数的数为0时返回true，表示倒数完成，唤醒其他等待的线程</span></span><br><span class="line">            <span class="type">return</span> <span class="variable">nextc</span> <span class="operator">=</span>= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在倒数完成后 <code>tryReleaseShared()</code> 方法返回了 true，让 <code>releaseShared()</code> 方法调用了 <code>doReleaseShared()</code> 方法来唤醒等待线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      	<span class="comment">// 获取头结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;    </span><br><span class="line">      	<span class="comment">// 如果头结点不为空且头结点不是尾结点，说明等待队列中存在节点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">          	<span class="comment">// 获取头结点的等待状态</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;    </span><br><span class="line">          	<span class="comment">// 如果头节点等待状态是SIGNAL，就CAS将头结点的状态设定为初始值</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;    </span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                  	<span class="comment">// 失败就下一轮循环</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">              	<span class="comment">// 当锁被释放，都会唤醒头结点的后继节点，doAcquireShared循环继续，如果成功，那么根据setHeadAndPropagate，又会继续调用当前方法，不断地传播下去，让后面的线程一个一个地获取到共享锁，直到不能再继续获取为止</span></span><br><span class="line">                unparkSuccessor(h);    </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     <span class="comment">// 如果等待状态是默认值0，那么说明后继节点已经被唤醒，直接将状态设定为PROPAGATE，它代表在后续获取资源的时候，够向后面传播</span></span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))   </span><br><span class="line">              	<span class="comment">// //失败就下一轮循环</span></span><br><span class="line">                <span class="keyword">continue</span>;                </span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 如果头结点发生了变化则继续循环，否则break退出</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<ol start="5">
<li><strong>总结</strong></li>
</ol>
<p>调用 CountDownLatch 的 <code>await()</code> 方法时会尝试获取共享锁。但刚开始是获取不到该锁的，于是线程被阻塞。共享锁可获取到的条件就是锁计数器的值为 0。而锁计数器的初始值为 count，每当一个线程调用该 CountDownLatch 对象的 <code>countDown()</code> 方法时，才将锁计数器值减 1。当有 count 个线程调用 <code>countDown()</code> 后锁计数器才为 0，而前面提到的等待获取共享锁的线程才能继续运行。</p>
<br>

<h3 id="Semaphore-1"><a href="#Semaphore-1" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>在 Semaphore 中 state 代表许可证剩余的数量。其中最重要的 <code>acquire()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了 Sync 的 <code>acquireSharedInterruptibly()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">  	<span class="comment">// 中断判断</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">  	<span class="comment">// 判断是否需要等待</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 CountDownLatch 相似，都调用了各自实现的 <code>acquireSharedInterruptibly()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非公平实现</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">nonfairTryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      	<span class="comment">// 获取state，即剩余的许可证</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">      	<span class="comment">// 计算当前许可证数若被获取后的数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">      	<span class="comment">// 如果被获取后许可证数量小于0则返回，此时返回的为负数</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            <span class="comment">// 或当CAS操作进行设置新的许可证数成功时，返回当前剩余许可证数，此时返回的为非负数且获取成功</span></span><br><span class="line">           	<span class="comment">// 若CAS操作失败则再次循环</span></span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">          <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公平实现</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>acquireSharedInterruptibly()</code> 方法根据  <code>tryAcquireShared()</code> 方法返回的数值为负数或非负数来决定是否将当前线程阻塞并加入等待队列，若为负数则调用 <code>doAcquireSharedInterruptibly()</code> 方法，此时获取许可证失败，这里与 CountDownLatch 中类似。<code>tryAcquireShared</code> 公平实现同理。</p>
<p><code>release()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样调用 Sync 中的 <code>releaseShared()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JEP 270添加的新注解，它会保护被注解的方法，通过添加一些额外的空间，防止在多线程运行的时候出现栈溢出</span></span><br><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 Semaphore 实现的 <code>tryReleaseShared()</code> 方法释放许可证：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      	<span class="comment">// 获取当前state，即许可证的数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> getState();</span><br><span class="line">      	<span class="comment">// 计算释放完许可证后许可证的数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + releases;</span><br><span class="line">      	<span class="comment">// 释放完总数量小于当前许可证数量则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">      	<span class="comment">// CAS操作释放许可证，成功返回true，失败进入下一轮循环</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>tryReleaseShared()</code> 方法返回 true 则表示释放成功，<code>releaseShared()</code> 方法会再调用 <code>doReleaseShared()</code> 方法来唤醒等待队列中的线程，与 CountDownLatch 中相同。</p>
<br>

<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>在 ReentrantLock 中 state 代表当前持有该锁的次数。其中最重要的 <code>lock()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 Sync 中的 <code>lock()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>而此方法为抽象方法，ReentrantLock 中的实现分为公平与非公平，以公平为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了 AQS 中的 <code>acquire()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">  	<span class="comment">// 首先尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先调用 ReentrantLock 实现的 <code>tryAcquire()</code> 方法尝试获取锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">      	<span class="comment">// 获取当前线程</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">      	<span class="comment">// 获取当前state，即锁被重入的次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">      	<span class="comment">// 若为0则表示没有线程持有该锁</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">          	<span class="comment">// 判断等待队列是否为空，即判断是否需要排队</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                <span class="comment">// 若不需要排队则CAS获取锁</span></span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">              	<span class="comment">// 若获取成功则将该锁的所有者设置为当前线程</span></span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">              	<span class="comment">// 返回true，加锁成功</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 若c不为0则表示该锁已经被持有，若持有者是当前线程</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">          	<span class="comment">// 计算锁在这次被获取后被重入的次数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">          	<span class="comment">// 溢出则抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">          	<span class="comment">// 直接获取到锁，将重入次数设置为新值</span></span><br><span class="line">            setState(nextc);</span><br><span class="line">          	<span class="comment">// 返回true，加锁成功</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出只有当该锁未被持有或该锁的持有者时当前获取该锁的线程时才能获取到锁。获取成功后返回 true 会直接跳出 <code>acquire()</code> 方法。</p>
<p>当获取失败返回 false 时会调用 <code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</code> 方法，首先调用 <code>addWaiter()</code> 将当前线程包装为结点传入调用 <code>acquireQueued()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法与 CountDownLatch 中的 <code>doAcquireSharedInterruptibly()</code> 方法类似。然后向当前线程发送中断信号：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selfInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 <code>unlock()</code> 方法也类似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 Sync 中的 <code>release()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">  	<span class="comment">// 尝试释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先调用 <code>tryRelease()</code> 方法尝试释放锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">  	<span class="comment">// 计算释放锁后锁被重入的次数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">  	<span class="comment">// 若当前线程不是该锁的持有者则抛出异常，即只有该锁的持有者才可以释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  	<span class="comment">// 若释放该锁后，该锁被重入的次数为0</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">      	<span class="comment">// 将free设置为true</span></span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">      	<span class="comment">// 将该锁的持有者设置为null</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 直接将state设置为新值</span></span><br><span class="line">    setState(c);</span><br><span class="line">  	<span class="comment">// 返回free的值</span></span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若在本次释放后锁仍被某线程持有，那么在 <code>release()</code> 方法中会跳过后面的语句返回 false。若在本次释放后该锁被重入的次数为 0，即没有线程持有该锁了，则调用 <code>unparkSuccessor()</code>方法唤醒等待队列中的线程。</p>
<p>非公平锁类似。</p>
<br>

<h2 id="利用-AQS-实现-Latch"><a href="#利用-AQS-实现-Latch" class="headerlink" title="利用 AQS 实现 Latch"></a>利用 AQS 实现 Latch</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AqsLatch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">Sync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.acquireShared(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.releaseShared(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            setState(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">AqsLatch</span> <span class="variable">aqsLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AqsLatch</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Try to acquire&quot;</span>);</span><br><span class="line">                aqsLatch.await();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Acquired&quot;</span>);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        aqsLatch.signal();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Try to acquire&quot;</span>);</span><br><span class="line">                aqsLatch.await();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Acquired&quot;</span>);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="Future-与-Callable"><a href="#Future-与-Callable" class="headerlink" title="Future 与 Callable"></a>Future 与 Callable</h1><h2 id="Runnable-的缺陷"><a href="#Runnable-的缺陷" class="headerlink" title="Runnable 的缺陷"></a>Runnable 的缺陷</h2><h4 id="不能拿到任务的返回结果"><a href="#不能拿到任务的返回结果" class="headerlink" title="不能拿到任务的返回结果"></a>不能拿到任务的返回结果</h4><p>Runnable 不能拿到任务的返回结果，虽然可以利用其他的一些办法，比如在 Runnable 方法中写入日志文件或者修改某个共享的对象的办法，来达到保存线程执行结果的目的，但这种解决问题的行为效率不高。</p>
<p>实际上，在很多情况下执行一个子线程时，我们都希望能得到执行的任务的结果，也就是说，我们是需要得到返回值的，比如请求网络、查询数据库等。可是 Runnable 不能返回一个返回值，这是它第一个非常严重的缺陷。</p>
<br>

<h4 id="不能抛出-checked-Exception"><a href="#不能抛出-checked-Exception" class="headerlink" title="不能抛出 checked Exception"></a>不能抛出 checked Exception</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunThrowsException</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">normalMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，普通方法 normalMethod 的方法签名中有 throws Exception，并且在方法内也 抛出了异常。而 Runnable 对象重写的 run 方法却无法在方法签名上声明 throws 一个异常，只能使用 try catch 包裹。</p>
<br>

<h4 id="为什么有这样的缺陷"><a href="#为什么有这样的缺陷" class="headerlink" title="为什么有这样的缺陷"></a>为什么有这样的缺陷</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码可以看到 Runnable 是一个接口且里面只有一个方法 <code>public abstract void run()</code>。这个方法已经规定了 <code>run()</code> 方法的返回类型是 void，而且这个方法没有声明抛出任何异常。所以当实现并重写这个方法时，我们既不能改返回值类型，也不能更改对于异常抛出的描述，在实现方法时语法规定是不允许对这些内容进行修改的。</p>
<br>

<h4 id="为什么设计成这样"><a href="#为什么设计成这样" class="headerlink" title="为什么设计成这样"></a>为什么设计成这样</h4><p>就算 <code>run()</code> 方法可以返回返回值或可以抛出异常，我们也没有办法在外层捕获并处理。这是因为调用 <code>run()</code> 方法的类（如 Thread 类和线程池）是 Java 直接提供的，而不是我们编写的。所以就算它能有返回值也很难把这个返回值利用到，要想弥补 Runnable 的这两个缺陷，可以使用 Callable。</p>
<br>

<h3 id="Callable-接口"><a href="#Callable-接口" class="headerlink" title="Callable 接口"></a>Callable 接口</h3><p>Callable 是一个类似于 Runnable 的接口，实现 Callable 接口的类和实现 Runnable 接口的类都是可以被其他线程执行的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在 <code>call()</code> 方法中已经声明了 throws Exception，还有泛型的返回值。实现 Callable 接口中的 <code>call()</code> 方法就可以利用 call 方法的返回值来获得子线程的执行结果。</p>
<br>

<h3 id="Callable-和-Runnable-的不同之处"><a href="#Callable-和-Runnable-的不同之处" class="headerlink" title="Callable 和 Runnable 的不同之处"></a>Callable 和 Runnable 的不同之处</h3><ol>
<li>执行方法不同，两个都是函数式接口，但 Callable 规定的执行方法是 <code>call()</code>，而 Runnable 规定的执行方法是 <code>run()</code>；</li>
<li>Callable 的任务执行后有返回值，而 Runnable 的任务执行后是没有返回值的；</li>
<li><code>call()</code> 方法可抛出异常，而 <code>run()</code> 方法不能抛出受检查异常；</li>
<li>与 Callable 配合的有一个 Future 类，通过 Future 可以了解任务执行情况，或者取消任务的执行，还可获取任务执行的结果，这些功能都是 Runnable 做不到的，Callable 的功能要比 Runnable 强大。</li>
</ol>
<br>

<h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>Future 类是一种异步任务监视器，可以让提交者监视任务的执行，同时可以取消任务的执行，也可以获取任务返回结果。</p>
<p>比如在做一定的任务运算的时候，需要等待比较长时间，如加密、压缩等。如果一直在等程序执行完成是不明智的，这时可以将这个比较耗时的任务交给子线程执行，然后通过 Future 类监控线程执行，获取返回的结果。这样就提高了工作效率，这是一种异步的思想。</p>
<p>可以用 <code>Future.get()</code> 来获取 Callable 接口返回的执行结果，还可以通过 <code>Future.isDone()</code> 来判断任务是否已经执行完毕，以及取消这个任务，限时获取任务的结果等。在 <code>call()</code> 未执行完毕之前，调用 <code>get()</code> 的线程（假定此时是主线程)会被阻塞，直到 <code>call()</code> 方法返回了结果后，此时 <code>Future.get()</code>才会得到该结果，然后主线程才会切换到 runnable 状态。</p>
<p>所以 Future 是一个存储器，它存储了 <code>call()</code> 这个任务的结果，而这个任务的执行时间是无法提前确定的，因为这完全取决于 <code>clal()</code>方法执行的情况。</p>
<br>

<h3 id="Future-的主要方法"><a href="#Future-的主要方法" class="headerlink" title="Future 的主要方法"></a>Future 的主要方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line"></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutExceptio</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>cancel(boolean mayInterruptIfRunning)</code>：取消任务的执行<br> 执行这个方法时，会有三种情况，</p>
<ol>
<li><strong>任务还没开始执行</strong>，调用了这个方法，这种情况比较好理解，这个任务会被正常取消，然后返回true</li>
<li>假如任务<strong>已经执行完成或者是已经执行过一次取消任务</strong>的方法，这种情况如果再调用这个方法，是会取消失败的，返回 false。因为任务无论是已完成还是已经被取消过了，都不能再被取消了</li>
<li><strong>任务正在执行</strong>，这种情况就会根据我们传入的 <code>mayInterruptIfRunning</code> 参数进行分情况调用，如果这个值为 true，执行任务的线程就会收到一个中断的信号，然后执行中断任务的逻辑，然后返回。如果这种值为 false，任务就不会被取消，继续执行，同时会返回 false，表示不执行取消任务操作</li>
</ol>
</li>
<li><p><code>isCancelled()</code>：获取是否取消了任务<br> 这个方法用于判断任务是否被取消了，比较简单</p>
</li>
<li><p><code>isDone()</code>：任务是否执行完成<br> 这个方法如果返回 true，则表示执行完成了，返回 false，表示还没执行完成。这里有一种特殊情况需要特别注意，就是如果执行任务的过程发生了 Exception，这种情况还是会被当成执行完成的，因为抛出 Exception 的任务，在”Future“也是不会执行的，所以都当成执行完成返回 true</p>
</li>
<li><p><code>get()</code>和<code>get(long timeout, TimeUnit unit)</code>：获取任务执行的返回值</p>
<p><code>get</code>方法最主要的作用就是获取任务返回的结果，<code>get</code>方法可能会发生以下 5 种情况：</p>
<ol>
<li><strong>任务执行完成</strong>，直接返回任务执行结果</li>
<li><strong>任务尚未完成</strong>，这种情况有可能是任务本身业务比较复杂，需要花比较长时间，也有可能是放在线程池里，而线程池堆积了不少任务，所以需要线程等待。这种情况调用 get 方法，都会把当前的线程阻塞，直到任务完成再把结果返回。</li>
<li><strong>执行任务过程抛出了异常</strong>，这种情况调用 get 会返回<code>ExecutionException</code>，不管实际的异常类型是什么</li>
<li><strong>任务被取消</strong>，这种情况调用 get 方法会抛出<code>CancellationException</code></li>
<li><strong>任务超时执行</strong>，这种情况是针对 <code>get(long timeout, TimeUnit unit)</code> 这个方法来说的，设置了 <code>timeout </code>超时时长，如果超过了设定的值，就会抛出 <code>TimeoutException</code></li>
</ol>
</li>
</ul>
<h3 id="方法示例"><a href="#方法示例" class="headerlink" title="方法示例"></a>方法示例</h3><h4 id="线程池的-submit-方法返回-Future-对象"><a href="#线程池的-submit-方法返回-Future-对象" class="headerlink" title="线程池的 submit() 方法返回 Future 对象"></a>线程池的 <code>submit()</code> 方法返回 Future 对象</h4><p>首先需要给线程池提交任务，提交时线程池会立刻返回给一个空的 Future 容器。当线程的任务一旦执行完毕也就是当可以获取结果时，线程池便会把该结果填入到之前的空 Future 中去（而不是创建一个新的 Future)。此时便可以从该 Future 中获得任务执行的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OneFuture</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        Future&lt;Integer&gt; future =executorService.submit(() -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt();</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>批量接受结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ManyFuture</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        ArrayList&lt;Future&lt;Integer&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            Future&lt;Integer&gt; future = executorService.submit(() -&gt; &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt();</span><br><span class="line">            &#125;);</span><br><span class="line">            futures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">        futures.forEach(f -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(f.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>任务执行过程抛出异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        Future&lt;Integer&gt; future = executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Callable Throw Exception&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          	System.out.println(future.isDone());</span><br><span class="line">            future.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;InterruptedException&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;ExecutionException&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">ExecutionException</span><br><span class="line">java.util.concurrent.ExecutionException: java.lang.IllegalStateException: Callable Throw Exception</span><br><span class="line">	at java.util.concurrent.FutureTask.report(FutureTask.java:<span class="number">122</span>)</span><br><span class="line">	at java.util.concurrent.FutureTask.get(FutureTask.java:<span class="number">192</span>)</span><br><span class="line">	at future.GetException.main(GetException.java:<span class="number">19</span>)</span><br><span class="line">Caused by: java.lang.IllegalStateException: Callable Throw Exception</span><br><span class="line">	at future.GetException.lambda$main$<span class="number">0</span>(GetException.java:<span class="number">12</span>)</span><br><span class="line">	at java.util.concurrent.FutureTask.run(FutureTask.java:<span class="number">266</span>)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">750</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到无论抛出的是什么异常，<code>get()</code> 方法总是会抛出 ExecutionException。并且虽然 Callable 的 <code>call()</code> 方法中是直接抛出异常的，但调用了 <code>submit()</code> 方法且 <code>isDone()</code> 方法已经返回 true 了但并没有直接抛出异常，而是等到调用 <code>get()</code> 方法时才会抛出异常。</p>
<br>

<p>超时与取消：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetTimeout</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Ad</span> <span class="variable">DEFAULT_AD</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ad</span>(<span class="string">&quot;default Ad&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Ad</span> &#123;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Ad</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printAd</span><span class="params">()</span> &#123;</span><br><span class="line">        Future&lt;Ad&gt; future = executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Sleep Interrupted&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Ad</span>(<span class="string">&quot;Sleep Interrupted Default Ad&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Ad</span>(<span class="string">&quot;Normal Ad&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        Ad ad;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ad = future.get(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            ad = <span class="keyword">new</span> <span class="title class_">Ad</span>(<span class="string">&quot;ExecutionException Default Ad&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            ad = <span class="keyword">new</span> <span class="title class_">Ad</span>(<span class="string">&quot;InterruptedException Default Ad&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            ad = <span class="keyword">new</span> <span class="title class_">Ad</span>(<span class="string">&quot;Timeout Default Ad&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Timeout&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Cancel Result: &quot;</span> + future.cancel(<span class="literal">false</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        System.out.println(ad);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GetTimeout</span> <span class="variable">getTimeout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetTimeout</span>();</span><br><span class="line">        getTimeout.printAd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若超时时间为 5 秒，则任务可以成功完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ad = future.get(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Normal Ad</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>若超时时间为 1 秒，则任务不能成功完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ad = future.get(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Timeout</span></span><br><span class="line"><span class="comment">Cancel Result: true</span></span><br><span class="line"><span class="comment">Timeout Default Ad</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>若在取消任务的方法中传入 true，则任务可以响应中断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Cancel Result: &quot;</span> + future.cancel(<span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Timeout</span></span><br><span class="line"><span class="comment">Cancel Result: true</span></span><br><span class="line"><span class="comment">Sleep Interrupted</span></span><br><span class="line"><span class="comment">Timeout Default Ad</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>Future.cancel(true)</code> 适用于：</p>
<ul>
<li>任务能够处理 interrupt</li>
</ul>
<p><code>Future.cancel(false)</code> 仅用于避免启动尚未启动的任务，适用于：</p>
<ul>
<li>未能处理 interrupt 的任务</li>
<li>不清楚任务是否支持取消</li>
<li>需要等待已经开始的任务执行完成</li>
</ul>
<br>

<h4 id="FutureTask-创建-Future"><a href="#FutureTask-创建-Future" class="headerlink" title="FutureTask 创建 Future"></a>FutureTask 创建 Future</h4><p>FutureTask 实现了 RunnableFuture 接口，而 RunnableFuture 接口又分别实现了 Runnable 和 Future 接口，所以可以推断出 FutureTask 具有这两种接口的特性：</p>
<ul>
<li>有 Runnable 特性，所以可以用在 ExecutorService 中配合线程池使用</li>
<li>有 Future 特性，所以可以从中获取到执行结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Calculating...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">101</span>; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//        new Thread(task).start();</span></span><br><span class="line">        executorService.submit(task);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(task.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>当 for 循环批量获取 future 的结果时，容易发生一部分线程很慢的情况，get 方法调用时应使用 timeout 限制</li>
<li>Future 的生命周期不能后退。生命周期只能前进，不能后退。就和线程池的生命周期一样，一旦完全完成了任务，它就永久停在了已完成的状态，不能重头再来</li>
</ul>
<br>

<h1 id="打造高性能缓存"><a href="#打造高性能缓存" class="headerlink" title="打造高性能缓存"></a>打造高性能缓存</h1><p>首先可以想到使用 Map 来制作缓存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapCache</span> &#123;</span><br><span class="line">  	<span class="comment">// 添加 final 增强安全性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, Integer&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">compute</span><span class="params">(String userId)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> cache.get(userId);</span><br><span class="line">        <span class="comment">// 先检查缓存</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 缓存中没有，则计算并缓存</span></span><br><span class="line">            result = doCompute(userId);</span><br><span class="line">            cache.put(userId, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer <span class="title function_">doCompute</span><span class="params">(String userId)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">HashMapCache</span> <span class="variable">hashMapCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMapCache</span>();</span><br><span class="line">        System.out.println(hashMapCache.compute(<span class="string">&quot;1&quot;</span>));</span><br><span class="line">        System.out.println(hashMapCache.compute(<span class="string">&quot;1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当第一次计算完毕后，第二次再次查询时则直接从 HashMap 缓存中获取，因此耗时很短。</p>
<p>但 HashMap 并不是并发安全的，多个线程每一次调用 <code>compute()</code> 方法很可能造成数据不一致的问题，因此可以使用 synchronized 修饰该方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Integer <span class="title function_">compute</span><span class="params">(String userId)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> cache.get(userId);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">        result = doCompute(userId);</span><br><span class="line">        cache.put(userId, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这样的性能差，每次只能让一个线程执行，而我们使用缓存正是因为访问量大，需要多线程并行。而且使用 synchronized 的代码复用性差。</p>
<p>首先解决代码复用性差的问题：使用装饰者模式重构代码，假设 ExpensiveFunction 类是耗时计算的实现类，实现了 Computable 接口，但其本身不具备缓存功能，也不需要考虑缓存的事。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Computable</span> &lt;A, V&gt; &#123;</span><br><span class="line">    V <span class="title function_">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExpensiveFunction</span> <span class="keyword">implements</span> <span class="title class_">Computable</span>&lt;String, Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">compute</span><span class="params">(String arg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapCache2</span>&lt;A, V&gt; <span class="keyword">implements</span> <span class="title class_">Computable</span>&lt;A, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, V&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMapCache2</span><span class="params">(Computable&lt;A, V&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">result</span> <span class="operator">=</span> cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Calculating...&quot;</span>);</span><br><span class="line">            result = c.compute(arg);</span><br><span class="line">            cache.put(arg, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        HashMapCache2&lt;String, Integer&gt; expensiveComputer = <span class="keyword">new</span> <span class="title class_">HashMapCache2</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ExpensiveFunction</span>());</span><br><span class="line">        System.out.println(expensiveComputer.compute(<span class="string">&quot;123&quot;</span>));</span><br><span class="line">        System.out.println(expensiveComputer.compute(<span class="string">&quot;123&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，当需要使用缓存功能时只需要创建一个实现 Computable 接口的类即可。</p>
<p>然后解决 synchronized 性能差的问题：考虑使用线程安全的 ConcurrentHashMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, V&gt; cache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>但这样又会导致新的问题：在计算完成前，另一个要求计算相同值的请求到来则会再次计算该值。这与我们使用缓存来避免多次计算的初衷背道而驰。</p>
<p>可以使用 Future 和 Callable 来避免重复计算问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, Future&lt;V&gt;&gt; cache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Future&lt;V&gt; future = cache.get(arg);</span><br><span class="line">    <span class="keyword">if</span> (future == <span class="literal">null</span>) &#123;</span><br><span class="line">        Callable&lt;V&gt; callable = () -&gt; c.compute(arg);</span><br><span class="line">        FutureTask&lt;V&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">        future = futureTask;</span><br><span class="line">        cache.put(arg, futureTask);</span><br><span class="line">        System.out.println(<span class="string">&quot;Calculating...&quot;</span>);</span><br><span class="line">        futureTask.run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> future.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样后面的线程就能知道已经在计算的线程计算的是否是与自己需要计算的相同而选择自己需不需要计算了。但有小概率会发生两个计算相同值的线程同时查找缓存都发现为 null 并各自创建一个任务去计算相同的值的情况。</p>
<p>可以使用原子组合操作弥补漏洞：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Future&lt;V&gt; future = cache.get(arg);</span><br><span class="line">    <span class="keyword">if</span> (future == <span class="literal">null</span>) &#123;</span><br><span class="line">        Callable&lt;V&gt; callable = () -&gt; c.compute(arg);</span><br><span class="line">        FutureTask&lt;V&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">        future = cache.putIfAbsent(arg, futureTask);</span><br><span class="line">        <span class="keyword">if</span> (future == <span class="literal">null</span>) &#123;</span><br><span class="line">            future = futureTask;</span><br><span class="line">            System.out.println(<span class="string">&quot;Calculating...&quot;</span>);</span><br><span class="line">            futureTask.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> future.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后考虑计算抛出异常的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionFunction</span> <span class="keyword">implements</span> <span class="title class_">Computable</span>&lt;String, Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">compute</span><span class="params">(String arg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">random</span> <span class="operator">=</span> Math.random();</span><br><span class="line">        <span class="keyword">if</span> (random &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;ExceptionFunction&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMapCache4&lt;String, Integer&gt; expensiveComputer = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMapCache4</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ExceptionFunction</span>());</span><br></pre></td></tr></table></figure>

<p>我们需要对不同的异常进行不同的处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Future&lt;V&gt; future = cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (future == <span class="literal">null</span>) &#123;</span><br><span class="line">            Callable&lt;V&gt; callable = () -&gt; c.compute(arg);</span><br><span class="line">            FutureTask&lt;V&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">            future = cache.putIfAbsent(arg, futureTask);</span><br><span class="line">            <span class="keyword">if</span> (future == <span class="literal">null</span>) &#123;</span><br><span class="line">                future = futureTask;</span><br><span class="line">                System.out.println(<span class="string">&quot;Calculating...&quot;</span>);</span><br><span class="line">                futureTask.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> future.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Retry...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Cancelled&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但当计算出错时缓存就被污染了，之后的每次查缓存都是错误的值，因此需要清理缓存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> future.get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    cache.remove(arg);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    cache.remove(arg);</span><br><span class="line">    System.out.println(<span class="string">&quot;Retry...&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">    cache.remove(arg);</span><br><span class="line">    System.out.println(<span class="string">&quot;Cancelled&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时还需要考虑缓存过期功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">compute</span><span class="params">(A arg, <span class="type">long</span> expire)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (expire &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        executor.schedule(() -&gt; &#123;</span><br><span class="line">            expire(arg);</span><br><span class="line">        &#125;, expire, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> compute(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">expire</span><span class="params">(A arg)</span> &#123;</span><br><span class="line">    Future&lt;V&gt; future = cache.get(arg);</span><br><span class="line">    <span class="keyword">if</span> (future != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!future.isDone())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Cancelling...&quot;</span>);</span><br><span class="line">            future.cancel(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Expire, clean cache&quot;</span>);</span><br><span class="line">        cache.remove(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将缓存过期时间添加随机性来避免缓存雪崩：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">computeRandomExpire</span><span class="params">(A arg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">randomExpire</span> <span class="operator">=</span> (<span class="type">long</span>) (Math.random() * <span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">return</span> compute(arg, randomExpire);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用线程池测试缓存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> ConcurrentHashMapCache5&lt;String, Integer&gt; computer = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMapCache5</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ExpensiveFunction</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(computer.compute(<span class="string">&quot;123&quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="keyword">while</span>(!executorService.isTerminated()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(System.currentTimeMillis() - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 CountDownLatch 进行压测：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> ConcurrentHashMapCache5&lt;String, Integer&gt; computer = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMapCache5</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ExpensiveFunction</span>());</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1000</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Begin wait&quot;</span>);</span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; End wait&quot;</span>);</span><br><span class="line">                    System.out.println(computer.compute(<span class="string">&quot;123&quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 ThreadLocal 确认时间的统一性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> ConcurrentHashMapCache5&lt;String, Integer&gt; computer = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMapCache5</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ExpensiveFunction</span>());</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadSafeFormat</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; simpleDateFormat = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1000</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Begin wait&quot;</span>);</span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                    System.out.println(ThreadSafeFormat.simpleDateFormat.get().format(System.currentTimeMillis()));</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; End wait&quot;</span>);</span><br><span class="line">                    System.out.println(computer.compute(<span class="string">&quot;123&quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>end</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>Buy me a coffee</div>
  <button onclick="document.querySelector('.post-reward').classList.toggle('active');">
    Donate
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="Ssssv11 WeChat Pay">
        <span>WeChat Pay</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/JavaSE/" rel="tag"><i class="fa fa-tag"></i> JavaSE</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/05/12/MySQL%E4%BC%98%E5%8C%96/" rel="prev" title="MySQL优化">
                  <i class="fa fa-chevron-left"></i> MySQL优化
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/07/06/%E7%AE%97%E6%B3%95/" rel="next" title="算法">
                  算法 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ssssv</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script size="90" alpha="0.6" zIndex="-1" src="/js/ribbon/ribbon.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/local-search.js"></script>






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'none'
      },
      options: {
        renderActions: {
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>



</body>
</html>

<script src="/js/cursor/fireworks.js"></script>

