<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="baidu-site-verification" content="code-jbS6cVmQ2r">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.lug.ustc.edu.cn/css?family=JetBrains+Mono:300,300italic,400,400italic,700,700italic%7CetBrains+Mono:300,300italic,400,400italic,700,700italic%7CFira+Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ssssv11.github.io","root":"/","images":"/images","scheme":"Pisces","version":"8.2.2","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="JVM的底层原理解析及知识点整理">
<meta property="og:type" content="article">
<meta property="og:title" content="探究JVM">
<meta property="og:url" content="https://ssssv11.github.io/2022/04/29/%E6%8E%A2%E7%A9%B6JVM/index.html">
<meta property="og:site_name" content="Ssssv">
<meta property="og:description" content="JVM的底层原理解析及知识点整理">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s1.imagehub.cc/images/2022/03/12/jvm.webp">
<meta property="og:image" content="https://s1.imagehub.cc/images/2022/03/12/14359229-ef6fa4ec504acc2f.webp">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/12/b78Z1U.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/12/b7wjVU.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/12/b7rqW4.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/12/b7Lmxs.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/12/b74Bad.png">
<meta property="og:image" content="https://s1.imagehub.cc/images/2022/03/12/image-20210730200638388.md.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/12/bHCPpV.png">
<meta property="og:image" content="https://s1.imagehub.cc/images/2022/03/12/imagertd.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/13/bbJGmF.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/13/bbhbE4.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/13/bbaWsx.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/13/bbfuSP.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/13/bbqsKA.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/13/bqpDxK.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/13/bqSYtI.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/13/bqSL36.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/13/bqmlGD.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/13/bqmZrR.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/13/bqYAzt.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/13/bqUKoD.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/13/bqUwFg.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/13/bqUsln.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/13/bqU4fJ.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/13/bqtuX6.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/13/bqtwB8.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/13/bqtdnf.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/13/bqNDr6.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/13/bqdEb6.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/13/bqwNex.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/13/bqyjtx.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/13/bq6du4.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/13/bq6b28.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/03/13/bqWbnO.jpg">
<meta property="article:published_time" content="2022-04-29T13:39:43.365Z">
<meta property="article:modified_time" content="2022-04-29T13:39:47.051Z">
<meta property="article:author" content="Ssssv11">
<meta property="article:tag" content="Java JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s1.imagehub.cc/images/2022/03/12/jvm.webp">


<link rel="canonical" href="https://ssssv11.github.io/2022/04/29/%E6%8E%A2%E7%A9%B6JVM/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>
<title>探究JVM | Ssssv</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Ssssv</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">25</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">42</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%9D%E8%AF%86JVM"><span class="nav-number">1.</span> <span class="nav-text">初识JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">JVM概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%8F%8A%E5%8E%9F%E7%90%86"><span class="nav-number">1.1.1.</span> <span class="nav-text">JVM跨平台及原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-number">1.1.2.</span> <span class="nav-text">JVM的位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.3.</span> <span class="nav-text">JVM体系结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.1.4.</span> <span class="nav-text">JVM的生命周期</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.</span> <span class="nav-text">类加载子系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="nav-number">2.1.</span> <span class="nav-text">类加载子系统概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8"><span class="nav-number">2.2.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%89%AE%E6%BC%94%E7%9A%84%E8%A7%92%E8%89%B2"><span class="nav-number">2.3.</span> <span class="nav-text">类加载器扮演的角色</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">2.4.</span> <span class="nav-text">类加载的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%EF%BC%88Loading%EF%BC%89"><span class="nav-number">2.4.1.</span> <span class="nav-text">加载（Loading）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%EF%BC%88Linking%EF%BC%89"><span class="nav-number">2.4.2.</span> <span class="nav-text">链接（Linking）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81%EF%BC%88Verification%EF%BC%89"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">验证（Verification）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%86%E5%A4%87%EF%BC%88Preparation%EF%BC%89"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">准备（Preparation）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90%EF%BC%88Resolution%EF%BC%89"><span class="nav-number">2.4.2.3.</span> <span class="nav-text">解析（Resolution）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.4.3.</span> <span class="nav-text">初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="nav-number">2.5.</span> <span class="nav-text">类加载的时机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">2.6.</span> <span class="nav-text">类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7"><span class="nav-number">2.6.1.</span> <span class="nav-text">类的唯一性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">2.6.2.</span> <span class="nav-text">类加载器的分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">2.7.</span> <span class="nav-text">类加载的常用方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="nav-number">2.8.</span> <span class="nav-text">双亲委派机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">2.8.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B"><span class="nav-number">2.8.2.</span> <span class="nav-text">流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">2.8.3.</span> <span class="nav-text">双亲委派机制的作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6"><span class="nav-number">2.9.</span> <span class="nav-text">沙箱安全机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="nav-number">2.9.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC"><span class="nav-number">2.9.2.</span> <span class="nav-text">历史版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E6%88%90%E6%B2%99%E7%AE%B1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6"><span class="nav-number">2.9.3.</span> <span class="nav-text">组成沙箱的基本组件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="nav-number">3.</span> <span class="nav-text">运行时数据区</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0"><span class="nav-number">3.1.</span> <span class="nav-text">运行时数据区概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E7%BB%93%E6%9E%84"><span class="nav-number">3.2.</span> <span class="nav-text">运行时数据区结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88PC%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89"><span class="nav-number">3.2.1.</span> <span class="nav-text">程序计数器（PC寄存器）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8-1"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E5%BE%81"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">特征</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">3.2.1.4.</span> <span class="nav-text">常见问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="nav-number">3.2.2.</span> <span class="nav-text">虚拟机栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88%E5%B8%A7"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">栈帧</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%EF%BC%88Local-Variables%EF%BC%89"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">局部变量表（Local Variables）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%EF%BC%88Operand-Stack%EF%BC%89"><span class="nav-number">3.2.2.3.</span> <span class="nav-text">操作数栈（Operand Stack）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88%E9%A1%B6%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF"><span class="nav-number">3.2.2.4.</span> <span class="nav-text">栈顶缓存技术</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%EF%BC%88Dynamic-Linking%EF%BC%89"><span class="nav-number">3.2.2.5.</span> <span class="nav-text">动态链接（Dynamic Linking）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%EF%BC%9A%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%88%86%E6%B4%BE"><span class="nav-number">3.2.2.6.</span> <span class="nav-text">方法的调用：解析与分派</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80%EF%BC%88Return-Address%EF%BC%89"><span class="nav-number">3.2.2.7.</span> <span class="nav-text">方法返回地址（Return Address）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%84%E4%BB%B6%E4%BF%A1%E6%81%AF"><span class="nav-number">3.2.2.8.</span> <span class="nav-text">附件信息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%EF%BC%88Heap%EF%BC%89"><span class="nav-number">3.2.3.</span> <span class="nav-text">堆（Heap）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%E7%9A%84%E5%88%86%E4%BB%A3"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">堆的分代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8DTLAB"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">为对象分配TLAB</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A9%E7%94%A8JProfile%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90OOM%E5%8E%9F%E5%9B%A0"><span class="nav-number">3.2.3.3.</span> <span class="nav-text">利用JProfile工具分析OOM原因</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%EF%BC%88Native-Method-Stack%EF%BC%89"><span class="nav-number">3.2.4.</span> <span class="nav-text">本地方法栈（Native Method Stack）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3%EF%BC%88Native-Method-Interface%EF%BC%89"><span class="nav-number">3.2.4.1.</span> <span class="nav-text">本地方法接口（Native Method Interface）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%88Method-Area%EF%BC%89"><span class="nav-number">3.2.5.</span> <span class="nav-text">方法区（Method Area）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5-4"><span class="nav-number">3.2.5.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E6%9B%B4"><span class="nav-number">3.2.5.2.</span> <span class="nav-text">变更</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-number">3.2.5.3.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%88Runtime-Constant-Pool%EF%BC%89"><span class="nav-number">3.2.5.4.</span> <span class="nav-text">运行时常量池（Runtime Constant Pool）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">3.2.5.5.</span> <span class="nav-text">方法区的垃圾回收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95"><span class="nav-number">3.2.5.6.</span> <span class="nav-text">面试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">3.3.</span> <span class="nav-text">对象的实例化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">3.3.1.</span> <span class="nav-text">创建对象的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="nav-number">3.3.2.</span> <span class="nav-text">创建对象的步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%AF%B9%E5%BA%94%E7%9A%84%E7%B1%BB%E6%98%AF%E5%90%A6%E5%B7%B2%E5%8A%A0%E8%BD%BD%E3%80%81%E9%93%BE%E6%8E%A5%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">1. 判断对象对应的类是否已加载、链接、初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="nav-number">3.3.2.2.</span> <span class="nav-text">2. 为对象分配内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%A4%84%E7%90%86%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">3.3.2.3.</span> <span class="nav-text">3. 处理并发安全问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%86%E9%85%8D%E5%88%B0%E7%9A%84%E7%A9%BA%E9%97%B4"><span class="nav-number">3.3.2.4.</span> <span class="nav-text">4. 初始化分配到的空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="nav-number">3.3.2.5.</span> <span class="nav-text">5. 设置对象的对象头</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E6%89%A7%E8%A1%8Cinit%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">3.3.2.6.</span> <span class="nav-text">6. 执行init方法进行初始化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">3.3.3.</span> <span class="nav-text">对象的内存布局</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">对象头</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E6%95%B0%E6%8D%AE"><span class="nav-number">3.3.3.2.</span> <span class="nav-text">实例数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A1%AB%E5%85%85"><span class="nav-number">3.3.3.3.</span> <span class="nav-text">填充</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="nav-number">3.3.4.</span> <span class="nav-text">对象的访问定位</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">3.3.4.1.</span> <span class="nav-text">对象访问的方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%EF%BC%88HotShot%E9%87%87%E7%94%A8%EF%BC%89"><span class="nav-number">3.3.4.2.</span> <span class="nav-text">直接访问（HotShot采用）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%EF%BC%88Direct-Memory%EF%BC%89"><span class="nav-number">3.3.5.</span> <span class="nav-text">直接内存（Direct Memory）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="nav-number">4.</span> <span class="nav-text">执行引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="nav-number">4.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="nav-number">4.2.</span> <span class="nav-text">工作过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">4.3.</span> <span class="nav-text">Java代码编译执行过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%BA%E5%99%A8%E7%A0%81%E3%80%81%E6%8C%87%E4%BB%A4%E3%80%81%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80"><span class="nav-number">4.4.</span> <span class="nav-text">机器码、指令、汇编语言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%BA%E5%99%A8%E7%A0%81"><span class="nav-number">4.4.1.</span> <span class="nav-text">机器码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4"><span class="nav-number">4.4.2.</span> <span class="nav-text">指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="nav-number">4.4.2.1.</span> <span class="nav-text">指令集</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80"><span class="nav-number">4.4.3.</span> <span class="nav-text">汇编语言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80"><span class="nav-number">4.4.4.</span> <span class="nav-text">高级语言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81"><span class="nav-number">4.4.5.</span> <span class="nav-text">字节码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C%E3%80%81C-%E6%BA%90%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">4.4.6.</span> <span class="nav-text">C、C++源程序执行过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="nav-number">4.5.</span> <span class="nav-text">解释器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%B0%E7%8A%B6"><span class="nav-number">4.5.1.</span> <span class="nav-text">现状</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-number">4.6.</span> <span class="nav-text">编译器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JIT%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-number">4.6.1.</span> <span class="nav-text">JIT编译器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E5%88%86%E7%B1%BB"><span class="nav-number">4.6.2.</span> <span class="nav-text">Java代码的执行分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E4%BA%86JIT%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="nav-number">4.6.3.</span> <span class="nav-text">有了JIT为什么还需要解释器?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HotSpot-JVM%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="nav-number">4.6.4.</span> <span class="nav-text">HotSpot JVM执行方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B"><span class="nav-number">4.6.4.1.</span> <span class="nav-text">案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E8%A7%A3%E9%87%8A"><span class="nav-number">4.6.4.2.</span> <span class="nav-text">概念解释</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%83%AD%E7%82%B9%E6%8E%A2%E6%B5%8B%E6%8A%80%E6%9C%AF"><span class="nav-number">4.6.4.3.</span> <span class="nav-text">热点探测技术</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%88GC%EF%BC%89"><span class="nav-number">5.</span> <span class="nav-text">垃圾回收机制（GC）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-4"><span class="nav-number">5.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE"><span class="nav-number">5.1.1.</span> <span class="nav-text">什么是垃圾</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9B%9E%E6%94%B6%E5%9E%83%E5%9C%BE"><span class="nav-number">5.1.2.</span> <span class="nav-text">为什么要回收垃圾</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">5.1.3.</span> <span class="nav-text">Java垃圾回收机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GC%E7%AE%97%E6%B3%95"><span class="nav-number">5.2.</span> <span class="nav-text">GC算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="nav-number">5.2.1.</span> <span class="nav-text">引用计数法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5-5"><span class="nav-number">5.2.1.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">5.2.1.2.</span> <span class="nav-text">优缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-number">5.2.2.</span> <span class="nav-text">复制算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5-6"><span class="nav-number">5.2.2.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-1"><span class="nav-number">5.2.2.2.</span> <span class="nav-text">优缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4"><span class="nav-number">5.2.3.</span> <span class="nav-text">标记清除</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5-7"><span class="nav-number">5.2.3.1.</span> <span class="nav-text">概念</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E5%8E%8B%E7%BC%A9"><span class="nav-number">5.2.4.</span> <span class="nav-text">标记压缩</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5-8"><span class="nav-number">5.2.4.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E"><span class="nav-number">5.2.4.2.</span> <span class="nav-text">指针碰撞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-2"><span class="nav-number">5.2.4.3.</span> <span class="nav-text">优缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94"><span class="nav-number">5.2.5.</span> <span class="nav-text">对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-number">5.2.6.</span> <span class="nav-text">分代收集算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JMM"><span class="nav-number">5.3.</span> <span class="nav-text">JMM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5-9"><span class="nav-number">5.3.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5JMM"><span class="nav-number">5.3.2.</span> <span class="nav-text">为什么要引入JMM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84"><span class="nav-number">5.3.3.</span> <span class="nav-text">结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E5%86%85%E5%AD%98%E5%92%8C%E6%9C%AC%E5%9C%B0%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">5.3.3.1.</span> <span class="nav-text">主内存和本地内存结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">5.3.4.</span> <span class="nav-text">三大特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%88Atomicity%EF%BC%89"><span class="nav-number">5.3.4.1.</span> <span class="nav-text">原子性（Atomicity）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">5.3.4.2.</span> <span class="nav-text">可见性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7%EF%BC%9A"><span class="nav-number">5.3.4.3.</span> <span class="nav-text">有序性：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JMM%E7%9A%84%E5%86%85%E5%AD%98%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92"><span class="nav-number">5.3.5.</span> <span class="nav-text">JMM的内存间的交互</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JMM%E4%BF%9D%E8%AF%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="nav-number">5.3.6.</span> <span class="nav-text">JMM保证多线程环境下的线程同步问题</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ssssv11"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">Ssssv11</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTE=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Ssssv11"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ssssv11.github.io/2022/04/29/%E6%8E%A2%E7%A9%B6JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="Ssssv11">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ssssv">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          探究JVM
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-04-29 21:39:43 / Modified: 21:39:47" itemprop="dateCreated datePublished" datetime="2022-04-29T21:39:43+08:00">2022-04-29</time>
    </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <center>JVM的底层原理解析及知识点整理</center>

<span id="more"></span>

<h1 id="初识JVM"><a href="#初识JVM" class="headerlink" title="初识JVM"></a><strong>初识JVM</strong></h1><hr>
<h2 id="JVM概述"><a href="#JVM概述" class="headerlink" title="JVM概述"></a><strong>JVM概述</strong></h2><ul>
<li>JVM 是 java虚拟机，是用来执行java字节码(二进制的形式)的虚拟计算机。</li>
<li>JVM是运行在操作系统之上的，与硬件没有任何关系。</li>
</ul>
<br/>

<h3 id="JVM跨平台及原理"><a href="#JVM跨平台及原理" class="headerlink" title="JVM跨平台及原理"></a><strong>JVM跨平台及原理</strong></h3><p>Java程序之所以能够实现跨平台，本质就是因为它是运行在虚拟机之上的，而不同平台只需要安装对应平台的Java虚拟机即可运行（在JRE中包含），所有的Java程序都采用统一的标准，在任何平台编译出来的字节码文件(.class)也是同样的，最后实际上是将编译后的字节码交给JVM处理执行。</p>
<img src="https://s1.imagehub.cc/images/2022/03/12/jvm.webp" alt="jvm.webp" style="zoom: 50%;" />

<p>也正是得益于这种统一规范，除了Java以外，还有多种JVM语言，比如Kotlin、Groovy等，它们的语法虽然和Java不一样，但是最终编译得到的字节码文件，和Java是同样的规范，同样可以交给JVM处理。</p>
<p>所以，JVM是我们需要去关注的一个部分，通过了解Java的底层运作机制，我们的技术会得到质的提升。</p>
<br/>

<h3 id="JVM的位置"><a href="#JVM的位置" class="headerlink" title="JVM的位置"></a><strong>JVM的位置</strong></h3><img src="https://s1.imagehub.cc/images/2022/03/12/14359229-ef6fa4ec504acc2f.webp" alt="14359229-ef6fa4ec504acc2f.webp" style="zoom:50%;" />

<p>JVM位于操作系统上层，但是位于应用程序下层，与硬件没有直接的交互。</p>
<br/>

<h3 id="JVM体系结构"><a href="#JVM体系结构" class="headerlink" title="JVM体系结构"></a><strong>JVM体系结构</strong></h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/b78Z1U"><img src="https://s1.ax1x.com/2022/03/12/b78Z1U.png" alt="b78Z1U.png"></a></p>
<p>如上图所示，JVM分为三个主要子系统：</p>
<ul>
<li><strong>类加载器子系统(Class Loader Subsystem)</strong><ul>
<li>加载(Loading)</li>
<li>链接(Linking)</li>
<li>初始化(Initialization)</li>
</ul>
</li>
<li><strong>运行时数据区(Runtime Data Area)</strong><ul>
<li>方法区(Method Area)</li>
<li>堆区(Heap Area)</li>
<li>栈区(Stack Area)</li>
<li>程序寄存器(PC Registers)</li>
<li>本地方法栈(Native Method Stack)</li>
</ul>
</li>
<li><strong>执行引擎(Execution Engine)</strong><ul>
<li>解释器(Interpreter)</li>
<li>JIT编译器</li>
<li>垃圾回收器</li>
</ul>
</li>
</ul>
<p>入口是编译好的字节码文件（编译器前端）–&gt; 经过类加载子系统（将我们的字节码加载到内存当中，生成一个class对象，中间经过三步：加载—&gt;链接—&gt;初始化）</p>
<p>在内存中，多个对象共享内存的是方法区和堆区（多个线程共享区）。Java虚拟机栈，本地方法栈，程序寄存器每一个线程独有一份。</p>
<br/>

<h3 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a><strong>JVM的生命周期</strong></h3><ul>
<li><p>虚拟机的启动</p>
<ul>
<li>Java虚拟机的启动是通过引导类加载器bootstrap class loader创建一个初始类initail calss来完成的，这个类是由虚拟机的具体实现指定的。</li>
</ul>
</li>
<li><p>虚拟机的执行：</p>
<ul>
<li><p>一个运行着的java虚拟机有着清晰的任务，执行java程序。</p>
</li>
<li><p>程序开始执行虚拟机就运行，程序结束虚拟机就结束运行。</p>
</li>
<li><p>执行一个java程序的时候，真真正正的在执行的是一个java虚拟机进程。</p>
</li>
</ul>
</li>
<li><p>虚拟机的停止：以下几种情况会退出虚拟机：</p>
<ul>
<li><p>程序正常执行结束。</p>
</li>
<li><p>程序在运行过程中遇到错误或者异常而终止执行。</p>
</li>
<li><p>由于操作系统发故障而导致虚拟机进程终止运行。</p>
</li>
<li><p>某一个线程调用了Runtime类或者system类的exit方法，或者调用runtime类的halt方法，并且java安全管理器允许执行安全退出的方法。</p>
</li>
</ul>
</li>
</ul>
<br/>

<h1 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a><strong>类加载子系统</strong></h1><hr>
<h2 id="类加载子系统概述"><a href="#类加载子系统概述" class="headerlink" title="类加载子系统概述"></a><strong>类加载子系统概述</strong></h2><blockquote>
<p>代码编译的结果从本地机器指令码转化为字节码，是存储格式发展的一小步，但却是编程语言发展的一大步</p>
<p>—— 《深入理解Java虚拟机》周志明·著</p>
</blockquote>
<p> Java虚拟机将描述类的数据从class字节码文件加载到内存，并且对数据进行校验，转化，解析，初始化的工作，最终形成在内存中可以直接使用的数据类型。 这个过程叫做虚拟机的类加载机制。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/b7wjVU"><img src="https://s1.ax1x.com/2022/03/12/b7wjVU.png" alt="b7wjVU.png"></a></p>
<br/>

<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h2><ul>
<li>类加载子系统负责从文件系统或者网络中加载Class文件（Class文件在开头有特定标识）。</li>
<li>类加载器(Class Loader)只负责class文件的加载，至于是否可以运行由执行引擎（Execution Engine）决定。</li>
<li>加载的类信息存放于一块成为方法区的内存空间。除了类信息之外，方法区还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）。</li>
</ul>
<br/>

<h2 id="类加载器扮演的角色"><a href="#类加载器扮演的角色" class="headerlink" title="类加载器扮演的角色"></a><strong>类加载器扮演的角色</strong></h2><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/b7rqW4"><img src="https://s1.ax1x.com/2022/03/12/b7rqW4.png" alt="b7rqW4.png"></a></p>
<ul>
<li><p>Car.class存放于本地硬盘中，在运行的时候，JVM将Car.class文件加载到JVM中，被称为DNA元数据模板</p>
<p>存放在JVM的方法区中，之后根据元数据模板实例化出相应的对象。</p>
</li>
<li><p>在 <code>.class</code> -&gt; <code>JVM</code> -&gt; <code>元数据模板</code> -&gt; <code>实例对象</code> 这个过程中，类加载器扮演者快递员的角色。</p>
</li>
<li><p>car1、car2、car3的名字存放在栈中，真正的数据存放在各个实例所存放的栈中存放的地址对应的堆中，栈只是引用地址。</p>
</li>
</ul>
<br/>



<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a><strong>类加载的过程</strong></h2><p>类的生命周期：</p>
<p><img src="https://s1.ax1x.com/2022/03/12/b7Lmxs.png" alt="b7Lmxs.png"></p>
<p>为支持运行时绑定，解析过程在某些情况下可在初始化之后再开始，除解析过程外的其他加载过程必须按照如图顺序开始。</p>
<p>类加载的过程主要分为三个阶段：<strong>加载，链接，初始化</strong>。 而链接阶段又可以细分为<strong>验证，准备，解析</strong>三个子阶段。</p>
<br/>

<h3 id="加载（Loading）"><a href="#加载（Loading）" class="headerlink" title="加载（Loading）"></a><strong>加载（Loading）</strong></h3><p>加载过程需要完成以下三个事情:</p>
<ul>
<li>通过一个类的<strong>全限定名</strong>获取定义此类的<strong>二进制字节流</strong>；</li>
<li>将这个字节流所代表的的<strong>静态存储结构</strong>转化为方法区的<strong>运行时数据结构</strong>；</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种**数据的访问入口 **</li>
</ul>
<blockquote>
<p>在第一步<strong>通过一个类的全限定名</strong>获取字节流的时候，并没有规范一定是从字节码文件获取，更没有规定是从本地文件中获取。因此，虚拟机的实现者就可以在加载阶段就构建出一个相当开放的舞台。</p>
<ul>
<li><p>从ZIP压缩文件中读取，最终成为日后JAR包，WAR包的基础</p>
</li>
<li><p>从网络中获取，这种情况最典型的就是Web Applet。</p>
</li>
<li><p>运行时生成，从而为后来的动态代理技术奠定了理论基础。</p>
</li>
<li><p>从其他文件中生成，典型的应用就是Web中的JSP技术。由JSP文件编译生成字节码文件。</p>
</li>
<li><p>从数据库获取，例如中间件服务器，可以选择把程序安装到数据库中完成程序代码在集群中的分发。</p>
<p>……</p>
</li>
</ul>
</blockquote>
<p>加载结束之后，外部的二进制字节流就会以JVM所设定的格式存在于方法区中了。 之后会在堆中实例化一个java.lang.class类型的对象， 这个对象作为程序访问方法区中的类型数据的入口。</p>
<br/>

<h3 id="链接（Linking）"><a href="#链接（Linking）" class="headerlink" title="链接（Linking）"></a><strong>链接（Linking）</strong></h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/b74Bad"><img src="https://s1.ax1x.com/2022/03/12/b74Bad.png" alt="b74Bad.png"></a></p>
<h4 id="验证（Verification）"><a href="#验证（Verification）" class="headerlink" title="验证（Verification）"></a><strong>验证（Verification）</strong></h4><p><strong>目的:</strong></p>
<p><strong>在于确保Class文件的字节流中所包含的信息符合当前JVM规范要求，保证被加载类的正确性，不会危害虚拟机自身安全</strong>。</p>
<p><strong>主要包括四种验证</strong></p>
<ol>
<li><p>文件格式验证</p>
<p>是否符合Class文件的规范，以及能够被当前版本的虚拟机处理。</p>
</li>
<li><p>元数据验证</p>
<p>对字节码描述的信息进行语义分析，以保证其描述符合java语言规范的要求。</p>
</li>
<li><p>字节码验证</p>
<p>保证代码是符合逻辑的，对代码的流程进行判断，保证不会出现危害虚拟机安全的情况。</p>
</li>
<li><p>符号引用验证</p>
<p>验证符号引用是否合法，判断该类中是否存在缺少后者被禁止访问它依赖的某些外部类，字段，方法等资源。主要用于解析阶段的前置任务。</p>
</li>
</ol>
<h4 id="准备（Preparation）"><a href="#准备（Preparation）" class="headerlink" title="准备（Preparation）"></a><strong>准备（Preparation）</strong></h4><p><strong>为类静态变量（static）分配内存并且设置初始值</strong>。</p>
<p>这里不包含用<code>final</code>修饰的static，因为<code>final</code>在编译的时候就会分配，准备阶段会显式初始化；不会为实例变量分配初始化，类变量会分配在方法去中，而实例变量是会随着对象一起分配到Java堆中。</p>
<h4 id="解析（Resolution）"><a href="#解析（Resolution）" class="headerlink" title="解析（Resolution）"></a><strong>解析（Resolution）</strong></h4><p><strong>将常量池内的符号引用转换为直接引用的过程</strong>。</p>
<ul>
<li>符号引用就是用一组符号来描述所引用的目标。</li>
<li>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li>
</ul>
<p>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。</p>
<br/>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><strong>初始化</strong></h3><p>类加载的最后阶段，执行类构造器方法<code>&lt;clInit&gt;()</code>的过程。</p>
<p>编译器会按照<strong>语句在源文件中出现的顺序</strong>依次自动收集类中所有<strong>静态类变量的赋值动作</strong>和<strong>静态代码块</strong>中的语句合并产生<code>&lt;clInit&gt;()</code>方法。如果类中没有静态语句和静态代码块则可以不生成<code>&lt;clInit&gt;()</code> 方法。</p>
<p>并且 <code>&lt;clinit&gt;()</code> 不需要显式调用父类的初始化方法 <code>&lt;clinit&gt;()</code>。JVM会保证在子类的 <code>&lt;clinit&gt;()</code> 方法执行之前，父类的 <code>&lt;clinit&gt;()</code> 方法已经执行完毕。（接口不需要调用父接口的初始化方法，只有使用到父接口中的静态变量时才需要调用）</p>
<p>如果 <code>&lt;clinit&gt;()</code> 方法中触发了对象的初始化，也就是 <code>&lt;init&gt;()</code> 方法，那么会进入执行 <code>&lt;init&gt;()</code> 方法，执行 <code>&lt;init&gt;()</code> 方法完成之后，再回来继续执行 <code>&lt;clinit&gt;()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClInitTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClInitTest instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static Start&quot;</span>);</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">ClInitTest</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;Static Finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClInitTest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Constructor Start&quot;</span>);</span><br><span class="line">        <span class="comment">// 构造器可以访问声明于他们后面的静态变量</span></span><br><span class="line">        <span class="comment">// 因为静态变量在类加载的准备阶段就已经分配内存并初始化0值了</span></span><br><span class="line">        <span class="comment">// 此时 x=0，y=0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;x = &quot;</span> + x + <span class="string">&quot;; y = &quot;</span> + y);</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        System.out.println(<span class="string">&quot;x = &quot;</span> + x + <span class="string">&quot;; y = &quot;</span> + y);</span><br><span class="line">        System.out.println(<span class="string">&quot;Constructor Finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClInitTest <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">father</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">static</span>&#123;</span><br><span class="line">            father = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">son</span> <span class="operator">=</span> father;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClInitTest</span> <span class="variable">clInitTest</span> <span class="operator">=</span> ClInitTest.getInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;x = &quot;</span> + clInitTest.x);</span><br><span class="line">        System.out.println(<span class="string">&quot;y = &quot;</span> + clInitTest.y);</span><br><span class="line">        System.out.println(Son.son);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Static Start</span><br><span class="line">Constructor <span class="type">Start</span></span><br><span class="line"><span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; y = <span class="number">0</span></span><br><span class="line">x = <span class="number">1</span>; y = <span class="number">1</span></span><br><span class="line">Constructor Finish</span><br><span class="line">Static <span class="type">Finish</span></span><br><span class="line"><span class="variable">x</span> <span class="operator">=</span> <span class="number">6</span></span><br><span class="line">y = <span class="number">1</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，先执行 static 代码块，此时调用了构造器，构造器中对类变量 x 和 y 进行加 1 ，之后继续完 static 代码块，接着执行下面的 <code>public static int x = 6</code> 来重新给类变量 x 赋值为 6，因此，最后输出的是 x&#x3D;6， y&#x3D;1。输出<code>Son.son</code>时结果为20，这是因为父类的<code>&lt;ClInit&gt;()</code>方法先执行，也就是说父类的静态代码块中的内容优于子类的赋值操作先执行。</p>
<p>虚拟机会保证一个类的 <code>&lt;clinit&gt;()</code> 方法在多线程环境中被正确地加锁同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 <code>&lt;clinit&gt;()</code> 方法，其他线程都需要阻塞等待，直到活动线程执行 <code>&lt;clinit&gt;()</code> 方法完毕。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    测试一个类的ClInit()方法是否被加锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoaderDeadLoopTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;启动&quot;</span>);</span><br><span class="line">            <span class="type">TestClass</span> <span class="variable">testClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestClass</span>(); <span class="comment">//触发加载TestClass类</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">// 如果不加这个判断 编译器会报死循环的错误</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在执行ClInit()方法&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span>启动</span><br><span class="line">Thread-<span class="number">1</span>启动</span><br><span class="line">Thread-<span class="number">0</span>正在执行ClInit()方法</span><br></pre></td></tr></table></figure>

<p>可以看到发生了程序无法正常结束，说明 当一条线程死循环在<code>&lt;ClInit&gt;()</code>处，别的线程也会阻塞。</p>
<br/>

<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a><strong>类加载的时机</strong></h2><p>对于初始化阶段，虚拟机规范规定了有且只有 5 种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p>
<ol>
<li>遇到<code>new</code>,<code>getStatic</code>，<code>putStatic</code>,<code>invokeStatic</code>,这四条字节码指令的时候，如果改类型没有进行初始化，则会触发其初始化。也就是如下情况 <ul>
<li>遇到<code>new</code>关键字进行创建对象的时候。</li>
<li>读取或者设置一个类的静态字段的时候（必须被final修饰，也就是在编译器把结果放入常量池中)。</li>
<li>调用一个类的静态方法的时候。</li>
</ul>
</li>
<li>使用java.lang.reflect进行反射调用的时候。</li>
<li>当初始化某个类，发现其父类没有初始化的时候。</li>
<li>当虚拟机启动的时候，会触发其主方法所在的类进行初始化。</li>
<li>当使用JDK1.7中的动态语言支持时，如果一个<code>java.lang.invoke.MethidHandle</code>实例最后的解析结果为<code>REF_getStatic</code>,<code>REF_putStatic</code>,<code>REF_invokeStatic</code>,<code>REF_newInvokeSpecial</code>四种类型的方法句柄，并且这个句柄对应的类没有被初始化。</li>
<li>当一个接口实现了JDK1.8中的默认方法的时候，如果这个接口的实现类被初始化，则该接口要在其之前进行实例化。</li>
</ol>
<p>对于以上6中触发类的初始化条件，在JVM规范中有一个很强制的词，<code>if and only if</code> （有且只有）。这六种行为被称为<strong>对类进行主动引用</strong>，除此之外，其他引用类的方式均不会触发类的初始化。</p>
<p>除此之外，所有引用类的方式都不会触发初始化，称为被动引用，例如：</p>
<ol>
<li>通过子类引用父类的静态字段，不会导致子类初始化。</li>
<li>通过数组定义来引用类，不会触发此类的初始化。<code>MyClass[] cs = new MyClass[10];</code></li>
<li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li>
</ol>
<br/>

<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a><strong>类加载器</strong></h2><p>把实现类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作的代码模块称为<strong>类加载器</strong>。</p>
<h3 id="类的唯一性"><a href="#类的唯一性" class="headerlink" title="类的唯一性"></a><strong>类的唯一性</strong></h3><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性。</p>
<p>即使两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类也不相等。<br>这里所指的相等，包括代表类的 Class 对象的 <code>equals() </code>方法、<code>isAssignableFrom() </code>方法、<code>isInstance() </code>方法的返回结果，也包括使用 <code>instanceof </code>关键字做对象所属关系判定等情况。</p>
<br/>

<h3 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a><strong>类加载器的分类</strong></h3><p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有三个:</p>
<p><a target="_blank" rel="noopener" href="https://www.imagehub.cc/image/oIRXp"><img src="https://s1.imagehub.cc/images/2022/03/12/image-20210730200638388.md.png" alt="image-20210730200638388.md.png"></a></p>
<ul>
<li><p><strong>启动类加载器（根加载器）</strong></p>
<p>负责加载<code>JAVA_HOME/lib</code>目录下的可以被虚拟机识别的字节码文件。（如<code>rt.jar</code>、<code>tools.jar</code>）</p>
<p>与之对应的是<code>java.lang.ClassLoader</code>类</p>
</li>
<li><p><strong>扩展类加载器</strong></p>
<p>负责加载<code>JAVA_HOME/lib/ext</code>目录下的的字节码文件。</p>
<p>对应<code>sun.misc.Launcher</code>类 此类继承于启动类加载器<code>ClassLoader</code></p>
</li>
<li><p><strong>应用程序类加载器</strong></p>
<p>负责加载<code>ClassPath</code>路径下的字节码 也就是用户自己写的类。</p>
<p>对应于<code>sun.misc.Launcher.AppClassLoader</code>类 此类继承于扩展类加载器<code>Launcher</code></p>
</li>
<li><p><strong>用户自定义加载器</strong></p>
<p>需要继承系统类加载器<code>ClassLoader</code>，并重写<code>findClass</code>方法。</p>
<p>负责加载指定位置的字节码文件。通过类中的path变量指定。</p>
</li>
</ul>
<p>Java 默认类加载器只加载指定目录下的 class，如果需要动态加载类到内存，例如要从远程网络下来类的二进制，然后调用这个类中的方法实现我的业务逻辑，如此，就需要自定义 ClassLoader。</p>
<p>自定义类加载器分为两步：</p>
<ol>
<li>继承 java.lang.ClassLoader</li>
<li>重写父类的 findClass() 方法</li>
</ol>
<p>第 1 步，为什么要继承 ClassLoader 这个抽象类，而不继承 AppClassLoader 呢？这是因为因为它和 ExtClassLoader 都是 Launcher 的静态内部类，其访问权限是缺省的包访问权限。</p>
<p>第 2 步，JDK 的 <code>loadCalss()</code> 方法在所有父类加载器无法加载的时候，会调用本身的 <code>findClass()</code> 方法来进行类加载，因此我们只需重写 <code>findClass()</code> 方法找到类的二进制数据即可。</p>
<p>自定义了一个简单的类加载器，并加载一个简单的类。首先是需要被加载的简单类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DIYTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Load Successfully&quot;</span>);</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> DIYTest.class.getClassLoader();</span><br><span class="line">        System.out.println(<span class="string">&quot;My ClassLoader is: &quot;</span> + classLoader);</span><br><span class="line">        System.out.println(<span class="string">&quot;My ClassLoader parent is: &quot;</span> + classLoader.getParent());</span><br><span class="line">        System.out.println(<span class="string">&quot;My ClassLoader parent is: &quot;</span> + classLoader.getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并使用 <code>javac -encoding utf8 DIYTest.java</code> 编译成 DIYTest.class 文件。</p>
<p>类加载器代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">clzDir</span> <span class="operator">=</span> <span class="string">&quot;F:\\Study\\JavaSE\\src\\jvm\\classLoader&quot;</span> + File.separatorChar + name.replace(<span class="string">&#x27;.&#x27;</span>, File.separatorChar) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] classData = getClassData(clzDir);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(classData == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] getClassData(String path) &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path);</span><br><span class="line">             <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>()</span><br><span class="line">        ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">bufferSize</span> <span class="operator">=</span> <span class="number">4096</span>;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[bufferSize];</span><br><span class="line">            <span class="type">int</span> <span class="variable">bytesNumRead</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, bytesNumRead);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用类加载器加载调用 DIYTest 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 指定类加载器加载调用</span></span><br><span class="line">        <span class="type">MyClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>();</span><br><span class="line">        classLoader.loadClass(<span class="string">&quot;DIYTest&quot;</span>).getMethod(<span class="string">&quot;test&quot;</span>).invoke(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Load Successfully</span><br><span class="line">My ClassLoader is: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">My ClassLoader parent is: sun.misc.Launcher$ExtClassLoader@1b6d3586</span><br><span class="line">My ClassLoader parent<span class="string">&#x27;s parent is: null</span></span><br></pre></td></tr></table></figure>

<br/>

<h2 id="类加载的常用方法"><a href="#类加载的常用方法" class="headerlink" title="类加载的常用方法"></a><strong>类加载的常用方法</strong></h2><p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）。</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>getParent()</td>
<td>返回该类加载器的父类加载器</td>
</tr>
<tr>
<td>loadClass(String name)</td>
<td>加载名称为name的类，返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td>findClass(String name)</td>
<td>查找名称为name的类，返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td>findLoadedClass(String name)</td>
<td>查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td>defineClass(String name, byte[] b, int off, int len)</td>
<td>把字节数组b中的内容转换为一个Java类 ，返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td>resolveClass(Class&lt;?&gt; c)</td>
<td>连接指定的一个java类</td>
</tr>
</tbody></table>
<p><strong>获取类加载器</strong></p>
<ul>
<li><p>clazz.getClassLoader()</p>
<p>获取当前类的类加载器</p>
</li>
<li><p>Thread.currentThread().getContextClassLoader()</p>
<p>获取当前线程上下文的类加载器</p>
</li>
<li><p>ClassLoader.getSystemClassLoader()</p>
<p>获取系统的类加载器</p>
</li>
<li><p>DriverManager.getCallerClassLoader()</p>
<p>获取调用者的类加载器</p>
</li>
</ul>
<br/>

<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a><strong>双亲委派机制</strong></h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><p> Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成的class对象。</p>
<p> 在加载某个类的class文件时，JVM采用的是双亲委派模式。即把请求交由父类处理，它是一种任务委派模式。</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a><strong>流程</strong></h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bHCPpV"><img src="https://s1.ax1x.com/2022/03/12/bHCPpV.png" alt="bHCPpV.png" style="zoom: 67%;" /></a></p>
<ol>
<li>如果一个类加载器收到了类加载的请求，它并不会自己加载，而是先把请求委托给父类的加载器执行。</li>
<li>如果父类加载器还有父类，则进一步向上委托，依次递归，请求到达最顶层的引导类加载器。</li>
<li>如果顶层类的加载器加载成功，则成功返回。如果失败，则子加载器会尝试加载，直到加载成功否则抛出ClassNotFoundException。</li>
</ol>
<p>这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。</p>
<p>Bootstrap 类加载器是用 C++ 实现的，是虚拟机自身的一部分，如果获取它的对象，将会返回 null；扩展类加载器和应用类加载器是独立于虚拟机外部，为 Java 语言实现的，均继承自抽象类 java.lang.ClassLoader ，开发者可直接使用这两个类加载器。</p>
<p>Application 类加载器对象可以由 <code>ClassLoader.getSystemClassLoader()</code> 方法的返回，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
<p>双亲委派模型对于保证 Java 程序的稳定运作很重要，例如类 <code>java.lang.Object</code>，它存放在 rt.jar 之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。</p>
<p>双亲委派模型的加载类逻辑可参考如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码摘自《深入理解Java虚拟机》</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 首先，检查请求的类是否已经被加载过了</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c = findBootstrapClassOrNull(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// 如果父类加载器抛出ClassNotFoundException</span></span><br><span class="line">        <span class="comment">// 说明父类加载器无法完成加载请求</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在父类加载器无法加载的时候</span></span><br><span class="line">            <span class="comment">// 再调用本身的findClass方法来进行类加载</span></span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>

<h3 id="双亲委派机制的作用"><a href="#双亲委派机制的作用" class="headerlink" title="双亲委派机制的作用"></a><strong>双亲委派机制的作用</strong></h3><ol>
<li>防止重复加载同一个<code>.class</code>。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。</li>
<li>保证核心<code>.class</code>不被篡改。通过委托方式，不会去篡改核心<code>.class</code>，即使篡改也不会去加载，即使加载也不会是同一个<code>.class</code>对象。不同的加载器加载同一个<code>.class</code>也不是同一个<code>Class</code>对象。这样保证了<code>Class</code>执行安全。</li>
</ol>
<br/>

<h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a><strong>沙箱安全机制</strong></h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a><strong>概述</strong></h3><p> Java安全模型的核心就是Java沙箱(sandbox)。</p>
<p>沙箱是一个限制程序运行的环境。沙箱机制就是将Java代码限定在虚拟机(JVM)特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。沙箱<strong>主要限制系统资源访问</strong>，包括CPU、内存、文件系统、网络等资源。不同级别的沙箱对这些资源访问的限制也可以不一样。</p>
<p>所有的Java程序运行都可以指定沙箱，可以定制安全策略。</p>
<br/>

<h3 id="历史版本"><a href="#历史版本" class="headerlink" title="历史版本"></a><strong>历史版本</strong></h3><p> 在Java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的Java实现中，安全依赖于沙箱(Sandbox)机制。</p>
<p>但如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候就无法实现。因此在后续的Java1.1 版本中，针对安全机制做了改进，增加了安全策略，允许用户指定代码对本地资源的访问权限。</p>
<p>在Java1.2版本中，再次改进了安全机制，增加了<strong>代码签名</strong>。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。</p>
<p> 当前最新的安全机制实现，则引入了**域(Domain)**的概念。虚拟机会把所有代码加载到不同的系统域和应用域，系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域，对应不一样的权限。存在于不同域中的类文件就具有了当前域的全部权限。</p>
<p> 以上提到的都是基本的<strong>Java 安全模型概念</strong>，在应用开发中还有一些<strong>关于安全的复杂用法</strong>，其中最常用到的 API 就是 <code>doPrivileged</code>。<code>doPrivileged</code> <strong>方法能够使一段受信任代码获得更大的权限，甚至比调用它的应用程序还要多，可做到临时访问更多的资源</strong>。有时候这是非常必要的，可以应付一些特殊的应用场景。例如，应用程序可能无法直接访问某些系统资源，但这样的应用程序必须得到这些资源才能够完成功能。</p>
<br/>

<h3 id="组成沙箱的基本组件"><a href="#组成沙箱的基本组件" class="headerlink" title="组成沙箱的基本组件"></a><strong>组成沙箱的基本组件</strong></h3><ul>
<li><p><strong>字节码校验器</strong>(bytecode verifier)︰确保Java类文件遵循Java语言规范。这样可以帮助Java程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。</p>
</li>
<li><p><strong>类装载器</strong>(class loader) :</p>
<p>其中类装载器在3个方面对Java沙箱起作用：</p>
<ul>
<li>它防止恶意代码去干涉善意的代码</li>
<li>它守护了被信任的类库边界</li>
<li>它将代码归入保护域，确定了代码可以进行哪些操作</li>
</ul>
</li>
</ul>
<p> 虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成，每一个被装载的类将有一个名字，这个命名空间是由Java虚拟机为每一个类装载器维护的，它们互相之间甚至不可见。</p>
<br/>

<h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a><strong>运行时数据区</strong></h1><hr>
<h2 id="运行时数据区概述"><a href="#运行时数据区概述" class="headerlink" title="运行时数据区概述"></a><strong>运行时数据区概述</strong></h2><p>运行时数据区（Runtime Data Area），用于保存Java程序运行过程中需要用到的数据和相关信息。经常说的把数据读入内存，包括类加载之后的信息，从磁盘读取文件信息等都是指运行时数据区。</p>
<br/>

<h2 id="运行时数据区结构"><a href="#运行时数据区结构" class="headerlink" title="运行时数据区结构"></a><strong>运行时数据区结构</strong></h2><p><img src="https://s1.imagehub.cc/images/2022/03/12/imagertd.png" alt="imagertd.png"></p>
<ul>
<li><p>方法区（Method Area）</p>
<p>方法区对应JDK8之后的元数据区</p>
</li>
<li><p>Java堆区（Heap Area）</p>
</li>
<li><p>Java虚拟机栈区（Stack Area）</p>
</li>
<li><p>程序寄存器（PC Registers）</p>
</li>
<li><p>本地方法栈（Native Method Stack）</p>
</li>
</ul>
<p>一个进程对应一个JVM实例，即一个运行时数据区。JVM一次能支持多线程执行，这些线程共享了方法区和堆，但每个线程独占一个程序计数器、本地方法栈和虚拟机栈。方法区与堆区会随着虚拟机启动而创建，随着虚拟机退出而销毁。</p>
<br/>

<h3 id="程序计数器（PC寄存器）"><a href="#程序计数器（PC寄存器）" class="headerlink" title="程序计数器（PC寄存器）"></a><strong>程序计数器（PC寄存器）</strong></h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h4><p>JVM中的程序计数寄存器（Program Counter Register），Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。JVM中的PC寄存器是对屋里PC寄存器的一种抽象模拟。</p>
<p>JVM一次能支持很多线程执行。每一个JVM线程有它自己的程序计数器。PC寄存器里保存有当前正在执行的JVM指令的地址。</p>
<br/>

<h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a><strong>作用</strong></h4><p>PC寄存器是用来存储指向下一条指令的地址，也即将将要执行的指令代码。由执行引擎读取下一条指令。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bbJGmF"><img src="https://s1.ax1x.com/2022/03/13/bbJGmF.png" alt="bbJGmF.png"  /></a></p>
<br/>

<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a><strong>特征</strong></h4><ul>
<li>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域</li>
<li>在JVM规范中，每个线程都有它自己的程序计数器，<strong>是线程私有的，生命周期与线程的生命周期保持一致</strong></li>
<li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefined）。</li>
<li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</li>
<li>字节码解释器工作时就是通过改变这个计数器的值来选取下一跳需要执行的字节码指令</li>
<li>它是唯一一个在Java虚拟机规范中没有规定任何OOM(OutOfMemoryError)情况的区域</li>
</ul>
<br/>

<h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a><strong>常见问题</strong></h4><ol>
<li><p>使用PC寄存器存储字节码指令地址有什么用呢？</p>
<p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行</p>
<p>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令</p>
</li>
<li><p>PC寄存器为什么会设定为线程私有?</p>
<p>多线程在一个特定的时间段内指回执行其中某一个线程的方法，CPU会不停的做任务切换，这样必然会导致经常中断或恢复。因此，<strong>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，</strong>这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p>
</li>
</ol>
<br/>

<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a><strong>虚拟机栈</strong></h3><p>每个JVM的线程在创建的时候，都会创建一个栈。一个栈包含很多栈桢。JVM的栈好比传统语言C的栈，它维持(存储)本地变量和部分结果，并在方法调用和返回中(被)使用。这个栈是一个后进先出的数据结构，所以当前正在执行的方法在栈的顶端。每当一个方法被调用时，一个新的栈帧就会被创建然后放在了栈的顶端。当方法正常返回或者发生了未捕获的异常，栈帧就会从栈里移除。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bbhbE4"><img src="https://s1.ax1x.com/2022/03/13/bbhbE4.png" alt="bbhbE4.png"></a></p>
<h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a><strong>栈帧</strong></h4><p>JVM为每个方法调用创建一个新的栈帧并推到每个方法调用的栈顶。当方法正常返回或者遇到了未捕获的异常，这个栈帧将被移除。</p>
<p>每个栈帧包含了：</p>
<ul>
<li>局部变量表（Local Variables）</li>
<li>操作数栈（Operand Stack）(或表达式栈)</li>
<li>动态链接（Dynamic Linking）(或执行运行时常量池的方法引用)</li>
<li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li>
<li>附加信息</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bbaWsx"><img src="https://s1.ax1x.com/2022/03/13/bbaWsx.png" alt="bbaWsx.png"></a></p>
<p><strong>影响栈帧大小的主要是局部变量表</strong>。</p>
<br/>

<h4 id="局部变量表（Local-Variables）"><a href="#局部变量表（Local-Variables）" class="headerlink" title="局部变量表（Local Variables）"></a><strong>局部变量表（Local Variables）</strong></h4><h5 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a><strong>概述</strong></h5><p>局部变量表也被称之为局部变量数组或本地变量表。它包含了这个方法执行期间所有用到的变量，包括this引用、所有方法参数以及其他的局部声明变量。</p>
<p>由于局部变量表是建立在线程的栈上，是线程私有的数据，因此不存在数据安全问题</p>
<p><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，保存在方法的Code属性的【字节码最大长度】数据项中。方法运行期间不会改变局部变量表的大小。</p>
<br/>

<h5 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a><strong>特征</strong></h5><ul>
<li><p>局部变量表<strong>最基本的存储单元是Slot(变量槽)</strong></p>
</li>
<li><p>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束</p>
</li>
<li><p>局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</p>
</li>
<li><p>局部变量表里，<strong>32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。</strong></p>
<ul>
<li>byte、short、char、float在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true；</li>
<li>long和double则占据两个slot。</li>
</ul>
</li>
<li><p>JVM会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p>
<p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制到局部变量表中的每一个slot上</strong></p>
<p><strong>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用签一个索引即可。</strong>（比如：访问long或者double类型变量）</p>
<p>如果当前帧是由构造方法或者实例方法创建的，那么<strong>该对象引用this将会存放在index为0的slot处</strong>,其余的参数按照参数表顺序排列。</p>
</li>
<li><p>栈帧中的局部变量表中的槽位是可以重复利用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p>
</li>
</ul>
<br/>

<h5 id="静态变量与局部变量"><a href="#静态变量与局部变量" class="headerlink" title="静态变量与局部变量"></a><strong>静态变量与局部变量</strong></h5><p>变量的分类：</p>
<ul>
<li>按照数据类型分：<ul>
<li>①基本数据类型;</li>
<li>②引用数据类型；</li>
</ul>
</li>
<li>按照在类中声明的位置分：<ul>
<li>①成员变量：在使用前，都经历过默认初始化赋值<ul>
<li>static修饰：类变量：类加载的链接的准备阶段给类变量默认赋值——&gt;初始化阶段给类变量显式赋值即静态代码块赋值；</li>
<li>不被static修饰：实例变量：随着对象的创建，会在堆空间分配实例变量空间，并进行默认赋值</li>
</ul>
</li>
<li>②局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过</li>
</ul>
</li>
<li>补充：<ul>
<li>在栈帧中，与性能调优关系最为密切的部分就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递</li>
<li><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></li>
</ul>
</li>
</ul>
<br/>

<h4 id="操作数栈（Operand-Stack）"><a href="#操作数栈（Operand-Stack）" class="headerlink" title="操作数栈（Operand Stack）"></a><strong>操作数栈（Operand Stack）</strong></h4><h5 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a><strong>概念</strong></h5><p>操作数栈是方法实际运行的工作空间。每个方法都在操作数栈和局部变量数组之间交换数据，并且压入或者弹出其他方法返回的结果。</p>
<p>虚拟机栈规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；如果虚拟机栈可以动态扩展（当前大部分的 Java 虚拟机都可动态扩展），如果扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError 异常。</p>
<br/>

<h5 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a><strong>作用</strong></h5><ul>
<li><strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</strong></li>
<li>操作数栈就是JVM执行引擎的一个工作区，当一个方法开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的</li>
<li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译器就定义好了，保存在方法的code属性中，为max_stack的值。</li>
<li>栈中的任何一个元素都是可以任意的java数据类型<ul>
<li>32bit的类型占用一个栈单位深度</li>
<li>64bit的类型占用两个栈深度单位</li>
<li>操作数栈<strong>并非采用访问索引的方式来进行数据访问</strong>的，而是只能通过标砖的入栈push和出栈pop操作来完成一次数据访问</li>
</ul>
</li>
<li><strong>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，</strong>并更新PC寄存器中下一条需要执行的字节码指令。</li>
<li>操作数栈中的元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类验证阶段的数据流分析阶段要再次验证。</li>
</ul>
<br/>

<h5 id="操作数栈栈帧的执行过程"><a href="#操作数栈栈帧的执行过程" class="headerlink" title="操作数栈栈帧的执行过程"></a><strong>操作数栈栈帧的执行过程</strong></h5><p>Java虚拟机的<strong>解释引擎是基于栈的执行引擎</strong>，其中的栈指的就是操作数栈。 <strong>结合操作数栈的概念来看一个方法（栈帧）的执行过程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span> i= <span class="number">15</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> bipush <span class="number">15</span> <span class="comment">//将值转化为int 保存到操作数栈中</span></span><br><span class="line"><span class="number">2</span> istore_1 <span class="comment">//将int的值15保存到局部变量表中</span></span><br><span class="line"><span class="number">3</span> bipush <span class="number">8</span> <span class="comment">//将值8存入到操作数栈中</span></span><br><span class="line"><span class="number">5</span> istore_2 <span class="comment">//将8存入局部变量表中</span></span><br><span class="line"><span class="number">6</span> iload_1 <span class="comment">// 从局部变量表中取出索引为1的值 15 放入操作数栈中</span></span><br><span class="line"><span class="number">7</span> iload_2 <span class="comment">// 从局部变量表中取出索引为2的值 8 放入操作数栈中</span></span><br><span class="line"><span class="number">8</span> iadd <span class="comment">// 将操作数栈中出栈两个值 相加</span></span><br><span class="line"><span class="number">9</span> istore_3 <span class="comment">// 将上一步的结果放入局部变量表索引3的位置</span></span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span> <span class="comment">//成功返回</span></span><br></pre></td></tr></table></figure>

<br/>

<h4 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a><strong>栈顶缓存技术</strong></h4><p>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读&#x2F;写次数</p>
<p>由于操作数是存储在内存中的，因此频繁地执行内存读&#x2F;写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存技术，<strong>将栈顶元素全部缓存在CPU的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行引擎的执行效率</strong></p>
<br/>

<h4 id="动态链接（Dynamic-Linking）"><a href="#动态链接（Dynamic-Linking）" class="headerlink" title="动态链接（Dynamic Linking）"></a><strong>动态链接（Dynamic Linking）</strong></h4><p>每一个栈帧内部都包含一个指向运行时常量池或该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。比如invokedynamic指令</p>
<p>在Java源文件被编译成字节码文件中时，所有的变量和方法引用都作为符号引用（symbolic Refenrence）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bbfuSP"><img src="https://s1.ax1x.com/2022/03/13/bbfuSP.png" alt="bbfuSP.png"></a></p>
<br/>

<h4 id="方法的调用：解析与分派"><a href="#方法的调用：解析与分派" class="headerlink" title="方法的调用：解析与分派"></a><strong>方法的调用：解析与分派</strong></h4><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p>
<ul>
<li><strong>静态链接</strong> 当一个 字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。</li>
<li><strong>动态链接</strong> 如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</li>
</ul>
<p>对应的方法的绑定机制为：早起绑定（Early Binding）和晚期绑定（Late Bingding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p>
<br/>

<h4 id="方法返回地址（Return-Address）"><a href="#方法返回地址（Return-Address）" class="headerlink" title="方法返回地址（Return Address）"></a><strong>方法返回地址（Return Address）</strong></h4><ul>
<li>存放调用该方法的PC寄存器的值。</li>
<li>一个方法的结束，有两种方式：<ul>
<li>正常执行完成</li>
<li>出现未处理的异常，非正常退出</li>
</ul>
</li>
<li>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<strong>调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。</strong>而通过异常退出时，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</li>
<li>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值也如调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</li>
<li><strong>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</strong></li>
</ul>
<p>当一个方法开始执行后，只要两种方式可以退出这个方法：</p>
<ol>
<li><p>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口；</p>
<ul>
<li><p>一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定</p>
</li>
<li><p>在字节码指令中，返回指令包含ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn以及areturn，另外还有一个return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用</p>
</li>
</ul>
</li>
<li><p>在方法执行的过程中遇到了异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜素到匹配的异常处理器，就会导致方法退出，简称<strong>异常完成出口</strong> 方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。</p>
</li>
</ol>
<br/>

<h4 id="附件信息"><a href="#附件信息" class="headerlink" title="附件信息"></a><strong>附件信息</strong></h4><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。</p>
<br/>

<h3 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a><strong>堆（Heap）</strong></h3><p>堆是整个Java应用程序共享的区域，也是整个虚拟机最大的一块内存空间，而此区域的职责就是存放和管理对象和数组，垃圾回收机制也是主要作用于这一部分内存区域。</p>
<ul>
<li>一个进程对应一个JVM实例。一个进程包含多个线程，这些线程<strong>共享方法区和堆</strong>，每个线程<strong>独有程序计数器、本地方法栈和虚拟机栈</strong></li>
<li>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域</li>
<li>堆是GC（Garbage Collection垃圾收集器）执行垃圾回收的重点区域</li>
<li>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间（堆内存的大小是可以调节的）</li>
<li>堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的</li>
<li>所有的线程共享Java堆，但还可以划分<strong>线程私有缓冲区</strong>（TLAB:Thread Local Allocation Buffer）（面试问题：堆空间一定是所有线程共享的吗？不是，TLAB线程在堆中独有的）</li>
<li>所有的对象实例以及数组都应当在运行时分配在堆上</li>
<li>从实际使用的角度看，几乎所有的对象的实例都在堆内分配内存 （“几乎”是因为可能存储在栈上）</li>
<li>数组或对象永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置</li>
<li>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除</li>
</ul>
<p>为了提高GC效率，从JDK 1.2开始将堆内存做分代（Generation）处理。</p>
<br/>

<h4 id="堆的分代"><a href="#堆的分代" class="headerlink" title="堆的分代"></a><strong>堆的分代</strong></h4><ul>
<li><p>堆内存分为两代：</p>
<ul>
<li>新生代</li>
<li>老年代</li>
</ul>
<p>其中新生代还能划分为</p>
<ul>
<li>伊甸园区（Eden Space）</li>
<li>幸存者0区（Survivor 0 Space）</li>
<li>幸存者1区（Survivor 1 Space）</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bbqsKA"><img src="https://s1.ax1x.com/2022/03/13/bbqsKA.png" alt="bbqsKA.png"></a></p>
<br/>



<h5 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a><strong>新生代</strong></h5><p> HotSpot JVM把年轻代分为了三部分：一个Eden区和两个Survivor区（分别叫from和to）。默认比例为8 : 1。因为新生代中的对象基本都是朝生夕死的（80%以上），所以在新生代的垃圾回收算法使用的是复制算法。</p>
<p>新生代有关参数：</p>
<ul>
<li><p>-XX:NewSize和-XX:MaxNewSize</p>
<p>用于设置新生代的大小，建议设为整个堆大小的1&#x2F;3或者1&#x2F;4,两个值设为一样大。</p>
</li>
<li><p>-XX:SurvivorRatio</p>
<p>用于设置Eden和其中一个Survivor的比值，这个值也比较重要。</p>
</li>
<li><p>-XX:+PrintTenuringDistribution</p>
<p>这个参数用于显示每次Minor GC时Survivor区中各个年龄段的对象的大小。</p>
</li>
<li><p>-XX:InitialTenuringThreshol和-XX:MaxTenuringThreshold</p>
<p>用于设置晋升到老年代的对象年龄的最小值和最大值，每个对象在坚持过一次Minor GC之后，年龄就加1。</p>
</li>
</ul>
<br/>

<h5 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a><strong>老年代</strong></h5><p>存放那些在历经了Eden区和Survivor区的多次GC后仍然存活下来的对象。</p>
<p>对于小对象的分配，会优先在线程私有的 TLAB（Thread Local Allocation Buffer）中分配（因为在堆上分配内存需要锁定整个堆，而在TLAB上则不需要，JVM在分配对象时会尽量在TLAB上分配，以提高效率），TLAB中创建的对象，不存在锁甚至是CAS的开销。TLAB占用的空间在Eden Generation。</p>
<p>当对象比较大，TLAB的空间不足以放下，而JVM又认为当前线程占用的TLAB剩余空间还足够时，就会直接在Eden Generation上分配，此时是存在并发竞争的，所以会有CAS的开销，但也还好。当对象大到Eden Generation放不下时，JVM只能尝试去Old Generation分配，这种情况需要尽可能避免，因为一旦在Old Generation分配，这个对象就只能被Old Generation的GC或是FullGC回收了。</p>
<p>堆有关参数：</p>
<ul>
<li><p>-Xms -Xmx -Xmn </p>
<p>old &#x3D; Xmx-Xmn</p>
</li>
</ul>
<br/>

<h5 id="Minor-GC、Major-GC、Full-GC"><a href="#Minor-GC、Major-GC、Full-GC" class="headerlink" title="Minor GC、Major GC、Full GC"></a><strong>Minor GC、Major GC、Full GC</strong></h5><blockquote>
<p>JVM在进行GC时，并非每次都针对上面三个内存区域（新生代、老年代、方法区）一起回收的，大部分时候回收都是指新生代。</p>
</blockquote>
<p>针对hotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）</p>
<ul>
<li>整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集</li>
<li>部分收集<ul>
<li>新生代收集（Minor GC&#x2F;Young GC）：只是新生代的垃圾收集</li>
<li>老年代收集（Major GC&#x2F;Old GC）：只是老年代的垃圾收集</li>
<li>目前，只有CMS GC会有单独收集老年代的行为</li>
<li>注意，很多时候Major GC 会和 Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收</li>
<li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集</li>
</ul>
</li>
</ul>
<br/>

<h5 id="区域分配"><a href="#区域分配" class="headerlink" title="区域分配"></a><strong>区域分配</strong></h5><ol>
<li>new的对象先放伊甸园区。此区有大小限制。</li>
<li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC),将伊甸园区中的不再被其他对象所引用的对象进行销毁。将伊甸园中的剩余对象移动到幸存者0区。</li>
<li>加载新的对象放到伊甸园区</li>
<li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</li>
<li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</li>
<li>什么时候能去养老区呢？可以设置次数。默认是15次。<ul>
<li>可以设置参数： -XX:MaxTenuringThreshold&#x3D;</li>
</ul>
</li>
<li>当老年区内存不足时，再次触发GC：Major GC，进行养老区的内存清理。</li>
<li>若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生OOM异常。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms600m -Xmx600m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapInstanceTest</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1024</span> * <span class="number">200</span>)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;HeapInstanceTest&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;HeapInstanceTest&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">HeapInstanceTest</span>());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bqpDxK"><img src="https://s1.ax1x.com/2022/03/13/bqpDxK.png" alt="bqpDxK.png"></a></p>
<p>伊甸园区的分配如图所示，当分配的对象到达150M，则进行一次垃圾回收，将非垃圾放入幸存者1区，继续分配放入伊甸园区，到达150之后，将对象放入0区，并且将之前1区中的对象放入老年区，以此类推。直到老年区满400M，爆出OOM(OutOfMemory)异常。</p>
<p><strong>总结</strong>：</p>
<ul>
<li><p><strong>针对幸存者s0，s1区：复制之后有交换，谁空谁是to</strong></p>
</li>
<li><p><strong>GC垃圾回收主要是在新生区，很少在养老区，几乎不再永久区&#x2F;元空间收集。</strong></p>
</li>
<li><p><strong>如果堆内存不够，或者存在死循环，就会导致OOM（OutOfMemoryError）</strong>。</p>
</li>
</ul>
<br/>

<h5 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a><strong>堆空间分代思想</strong></h5><p>为什么要把Java堆分代？不分代就不能正常工作了么</p>
<ul>
<li>经研究，不同对象的生命周期不同。70%-99%的对象都是临时对象。<ul>
<li>新生代：有Eden、Survivor构成（s0，s1 又称为from to），to总为空</li>
<li>老年代：存放新生代中经历多次依然存活的对象</li>
</ul>
</li>
<li>其实不分代完全可以，分代的唯一理由就是<strong>优化GC性能</strong>。 如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。 GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描，而很多对象都是朝生夕死的。 如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</li>
</ul>
<br/>

<h5 id="提升到老年代的规则"><a href="#提升到老年代的规则" class="headerlink" title="提升到老年代的规则"></a><strong>提升到老年代的规则</strong></h5><p>如果对象在Eden出生并经过第一次Minor GC后依然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，把那个将对象年龄设为1。对象在Survivor区中每熬过一次MinorGC，年龄就增加一岁，当它的年龄增加到一定程度（默认15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代中。</p>
<p>对象晋升老年代的年龄阈值，可以通过选项 -XX：MaxTenuringThreshold来设置</p>
<p>针对不同年龄段的对象分配原则如下：</p>
<ul>
<li><p>优先分配到Eden</p>
</li>
<li><p>大对象之间分配到老年代（尽量避免程序中出现过多的大对象）</p>
</li>
<li><p>长期存活的分配到老年代</p>
</li>
<li><p>动态年龄的判断</p>
<p>如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入到老年代。无需等到MaxTenuringThreshold中要求的年龄</p>
</li>
<li><p>空间分配担保</p>
<p>-XX: HandlePromotionFailure</p>
</li>
</ul>
<br/>

<h4 id="为对象分配TLAB"><a href="#为对象分配TLAB" class="headerlink" title="为对象分配TLAB"></a><strong>为对象分配TLAB</strong></h4><h5 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a><strong>概念</strong></h5><p>TLAB是从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bqSYtI"><img src="https://s1.ax1x.com/2022/03/13/bqSYtI.jpg" alt="bqSYtI.jpg"></a></p>
<p>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。</p>
<p>所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</p>
<br/>

<h5 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a><strong>作用</strong></h5><ul>
<li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li>
<li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li>
<li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</li>
</ul>
<br/>

<h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h5><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bqSL36"><img src="https://s1.ax1x.com/2022/03/13/bqSL36.png" alt="bqSL36.png"></a></p>
<br/>

<h4 id="利用JProfile工具分析OOM原因"><a href="#利用JProfile工具分析OOM原因" class="headerlink" title="利用JProfile工具分析OOM原因"></a><strong>利用JProfile工具分析OOM原因</strong></h4><h5 id="JProfile功能"><a href="#JProfile功能" class="headerlink" title="JProfile功能"></a><strong>JProfile功能</strong></h5><ul>
<li>分析Dump文件，快速定位内存泄露</li>
<li>获取堆中数据</li>
<li>获取大对象</li>
</ul>
<p>首先编写会发生OOM的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    分析OOM原因</span></span><br><span class="line"><span class="comment">    查看Dump文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OOM</span> &#123;</span><br><span class="line">    Byte[] array = <span class="keyword">new</span> <span class="title class_">Byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">// 1M</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">OOM</span>());</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Error e)&#123;</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改配置文件<code>VM options</code>: <code>-Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError</code></p>
<p>运行代码输出:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid11996.hprof ...</span><br><span class="line">Heap dump file created [<span class="number">9988778</span> bytes in <span class="number">0.024</span> secs]</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>到项目文件目录下找到生成的文件用JProfile打开查看:</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bqmlGD"><img src="https://s1.ax1x.com/2022/03/13/bqmlGD.png" alt="bqmlGD.png" style="zoom: 50%;" /></a></p>
<p>我们可以发现在大对象中，java.util.ArrayList占用了84%的堆内存。再去Thread Dump中查看各个线程：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bqmZrR"><img src="https://s1.ax1x.com/2022/03/13/bqmZrR.png" alt="bqmZrR.png" style="zoom:50%;" /></a></p>
<p>发现在<code>main()</code>中代码第18行发生错误：<code>list.add(new OOM());</code></p>
<p>经过这些步骤，我们就可以在遇到OOM时进行排错了。</p>
<p>相关VM参数：</p>
<ul>
<li><strong>-Xms</strong>&#x3D;&#x3D;**：设置初始分配大小，默认为物理内存的 “1&#x2F;64”。</li>
<li><strong>-Xmx</strong>：最大分配内存，默认为物理内存的 “1&#x2F;4”。</li>
<li>**-XX:+PrintGCDetails&#x3D;&#x3D;**：输出详细的GC处理日志。</li>
<li><strong>-XX:+HeapDumpOnOutOfMemoryError</strong>：在发生OOM时生成Dump文件</li>
</ul>
<p><strong>总结：</strong></p>
<p>遇到OOM时：</p>
<ol>
<li>尝试扩大堆内存空间，如果还有OOM问题则排查是否是代码问题</li>
<li>使用工具分析排错，定位问题并修改</li>
</ol>
<br/>

<h3 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a><strong>本地方法栈（Native Method Stack）</strong></h3><p>用于管理本地方法的调用。 每个线程创建时分配一个本地方法栈，是线程私有的。</p>
<p>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持本地方法，也可以无需实现本地方法栈。</p>
<p>允许被实现成固定或者是可动态拓展的内存大小。（在内存溢出方面是相同的）</p>
<ul>
<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackOverFlowError异常。</li>
<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么java虚拟机将会抛出一个OutOfMemoryError异常。</li>
</ul>
<p>本地方法是使用C语言实现的</p>
<p>它的具体做法是在虚拟机栈中登记native方法，在Execution Engine执行时加载本地方法库。</p>
<p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限</p>
<ul>
<li>本地方法可以通过本地方法接口来 <strong>访问虚拟机内部的运行时数据区</strong></li>
<li>它甚至可以直接使用本地处理器中的寄存器</li>
<li>直接从本地内存的堆中分配任意数量的内存</li>
</ul>
<p>在hotSpot JVM中，本地方法栈与虚拟机栈合二为一。</p>
<br/>

<h4 id="本地方法接口（Native-Method-Interface）"><a href="#本地方法接口（Native-Method-Interface）" class="headerlink" title="本地方法接口（Native Method Interface）"></a><strong>本地方法接口（Native Method Interface）</strong></h4><h5 id="本地方法"><a href="#本地方法" class="headerlink" title="本地方法"></a><strong>本地方法</strong></h5><h6 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a><strong>概念</strong></h6><p>　用<code>native</code>修饰的、不能和<code>abstract</code>共同使用的、不显示方法体但却是用非Java语言实现方法体的方法。</p>
<p>简单来说，一个Native Method就是一个Java调用非Java代码的接口。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。</p>
<p>在定义一个<code>native method</code>时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非Java语言在外面实现的。</p>
<p>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C&#x2F;C++。</p>
<br/>

<h6 id="为什么要用Native-Method"><a href="#为什么要用Native-Method" class="headerlink" title="为什么要用Native Method"></a><strong>为什么要用Native Method</strong></h6><p>Native使用起来非常方便，然而有些层次的任务用java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p>
<ul>
<li><p>与java环境外交互</p>
<p>有时java应用需要与java外面的环境交互，这是本地方法存在的主要原因。 你可以想想java需要与一些底层系统，如擦偶偶系统或某些硬件交换信息时的情况。本地方法正式这样的一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解java应用之外的繁琐细节。</p>
</li>
<li><p>与操作系统交互</p>
<p>JVM支持着java语言本身和运行库，它是java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用java实现了jre的与底层系统的交互，甚至jvm的一些部分就是用C写的。还有，如果我们要使用一些java语言本身没有提供封装的操作系统特性时，我们也需要使用本地方法。</p>
</li>
<li><p>Sun’s Java</p>
<p>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的事该类里的本地方法setPriority0（）。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 SetProority（）API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用</p>
</li>
</ul>
<br/>

<h3 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a><strong>方法区（Method Area）</strong></h3><h4 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a><strong>概念</strong></h4><p>方法区与 Java 堆一样，是各个<strong>线程共享</strong>的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的是与 Java 堆区分开来。方法区在逻辑上存在，在物理上不存在。</p>
<p>Java 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以<strong>选择不实现垃圾收集</strong>。垃圾收集行为在这个区域是比较少出现的，其内存回收目标主要是针对常量池的回收和对类型的卸载。当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。</p>
<p>对应元空间：</p>
<p>对虚拟机参数进行调整：<code>-Xms1m -Xmx1m -XX:+PrintGCDetails</code>，再输出最大内存与总内存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;max: &quot;</span> + Runtime.getRuntime().maxMemory());</span><br><span class="line">System.out.println(<span class="string">&quot;total: &quot;</span> + Runtime.getRuntime().totalMemory());</span><br></pre></td></tr></table></figure>

<p>得到控制台输出如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 512K-&gt;488K(1024K)] 512K-&gt;536K(1536K), <span class="number">0.0008682</span> secs] [Times: user=<span class="number">0.02</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 1000K-&gt;504K(1024K)] 1048K-&gt;708K(1536K), <span class="number">0.0007992</span> secs] [Times: user=<span class="number">0.02</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 1016K-&gt;496K(1024K)] 1220K-&gt;868K(1536K), <span class="number">0.0006226</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Ergonomics)</span> [PSYoungGen: 496K-&gt;379K(1024K)] [ParOldGen: 372K-&gt;271K(512K)] 868K-&gt;650K(1536K), [Metaspace: 3034K-&gt;3034K(1056768K)], <span class="number">0.0041716</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">max: <span class="number">1572864</span></span><br><span class="line">total: <span class="number">1572864</span></span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 1024K, used 559K [<span class="number">0x00000000ffe80000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 512K, <span class="number">35</span>% used [<span class="number">0x00000000ffe80000</span>,<span class="number">0x00000000ffead278</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line">  from space 512K, <span class="number">74</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff5ec28</span>,<span class="number">0x00000000fff80000</span>)</span><br><span class="line">  to   space 512K, <span class="number">0</span>% used [<span class="number">0x00000000fff80000</span>,<span class="number">0x00000000fff80000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line"> ParOldGen       total 512K, used 271K [<span class="number">0x00000000ffe00000</span>, <span class="number">0x00000000ffe80000</span>, <span class="number">0x00000000ffe80000</span>)</span><br><span class="line">  object space 512K, <span class="number">53</span>% used [<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000ffe43e80</span>,<span class="number">0x00000000ffe80000</span>)</span><br><span class="line"> Metaspace       used 3249K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 344K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>我们可以发现：年轻代与老年代所占内存 <code>1024K + 512K = 1572864</code>，就已经占满空间。因此元空间也可以说是在逻辑上存在而在物理上不存在。</p>
<br/>

<h4 id="变更"><a href="#变更" class="headerlink" title="变更"></a><strong>变更</strong></h4><p><strong>JDK8 之前，Hotspot 中方法区的实现是永久代（Perm），JDK8 开始使用元空间（Metaspace），以前永久代所有内容的字符串常量移至堆内存，其他内容移至元空间，元空间直接在本地内存分配。</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bqYAzt"><img src="https://s1.ax1x.com/2022/03/13/bqYAzt.jpg" alt="bqYAzt.jpg"></a></p>
<p>为什么要使用元空间取代永久代的实现？</p>
<ol>
<li>字符串存在永久代中，容易出现性能问题和内存溢出。</li>
<li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</li>
<li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</li>
<li>将 HotSpot 与 JRockit 合二为一。</li>
</ol>
<br/>

<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h4><ul>
<li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域</li>
<li>方法区在JVM启动时就会被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的</li>
<li>方法区的大小，跟堆空间一样，可以选择固定大小或者可拓展</li>
<li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误OOM。如：<ul>
<li>加载大量的第三方jar包；</li>
<li>Tomcat部署的工程过多；</li>
<li>大量动态生成反射类；</li>
</ul>
</li>
<li>关闭JVM就会释放这个区域的内存</li>
</ul>
<br/>

<h4 id="运行时常量池（Runtime-Constant-Pool）"><a href="#运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="运行时常量池（Runtime Constant Pool）"></a><strong>运行时常量池（Runtime Constant Pool）</strong></h4><p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
<p>一般来说，除了保存 Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</p>
<p>运行时常量池相对于 Class 文件常量池的另外一个重要特征是具备动态性，Java 语言并不要求常量一定只有编译期才能产生，也就是并非预置入 Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是 String 类的 intern() 方法。</p>
<p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。</p>
<p>它可以通过-XX:PermSize及-XX:MaxPermSize来进行调节。</p>
<h5 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a><strong>字符串常量池</strong></h5><p>String类正是利用了常量池进行优化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(str1 == str2);</span><br><span class="line">    System.out.println(str1.equals(str2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的结果也是显而易见的，由于<code>str1</code>和<code>str2</code>是单独创建的两个对象，那么这两个对象实际上会在堆中存放，保存在不同的地址：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bqUKoD"><img src="https://s1.ax1x.com/2022/03/13/bqUKoD.jpg" alt="bqUKoD.jpg"></a></p>
<p>所以当我们使用<code>==</code>判断时，得到的结果<code>false</code>，而使用<code>equals</code>时因为比较的是值，所以得到<code>true</code>。现在我们来稍微修改一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(str1 == str2);</span><br><span class="line">    System.out.println(str1.equals(str2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们没有使用new的形式，而是直接使用双引号创建，那么这时得到的结果就变成了两个<code>true</code>，这是为什么呢？这其实是因为我们直接使用双引号赋值，会先在常量池中查找是否存在相同的字符串，若存在，则将引用直接指向该字符串；若不存在，则在常量池中生成一个字符串，再将引用指向该字符串：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bqUwFg"><img src="https://s1.ax1x.com/2022/03/13/bqUwFg.jpg" alt="bqUwFg.jpg"></a></p>
<p>实际上两次调用String类的<code>intern()</code>方法，和上面的效果差不多，也是第一次调用会将堆中字符串复制并放入常量池中，第二次通过此方法获取字符串时，会查看常量池中是否包含，如果包含那么会直接返回常量池中字符串的地址：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">    <span class="comment">//不能直接写&quot;abc&quot;，双引号的形式，写了就直接在常量池里面吧abc创好了</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>)+<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>)+<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(str1.intern() == str2.intern());</span><br><span class="line">    System.out.println(str1.equals(str2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bqUsln"><img src="https://s1.ax1x.com/2022/03/13/bqUsln.jpg" alt="bqUsln.jpg"></a></p>
<p>所以上述结果中得到的依然是两个<code>true</code>。在JDK1.7之后，稍微有一些区别，在调用<code>intern()</code>方法时，当常量池中没有对应的字符串时，不会再进行复制操作，而是将其直接修改为指向当前字符串堆中的的引用：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bqU4fJ"><img src="https://s1.ax1x.com/2022/03/13/bqU4fJ.jpg" alt="bqU4fJ.jpg"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  	<span class="comment">//不能直接写&quot;abc&quot;，双引号的形式，写了就直接在常量池里面吧abc创好了</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>)+<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    System.out.println(str1.intern() == str1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>)+<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>)+<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(str1 == str1.intern());</span><br><span class="line">    System.out.println(str2.intern() == str1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以最后我们会发现，<code>str1.intern()</code>和<code>str1</code>都是同一个对象，结果为<code>true</code>。</p>
<p>值得注意的是，在JDK7之后，字符串常量池从方法区移动到了堆中。</p>
<br/>

<h4 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a><strong>方法区的垃圾回收</strong></h4><p>有些人认为方法区（如Hotspot，虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java 虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如 JDK11 时期的 2GC 收集器就不支持类卸载）。  一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前 Sun 公司的 Bug 列表中，曾出现过的若干个严重的 Bug 就是由于低版本的 Hotspot 虚拟机对此区域未完全回收而导致内存泄漏。  方法区的垃圾收集主要回收两部分内容：常量池中废奔的常量和不再使用的类型</p>
<ul>
<li>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。 字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：<ul>
<li>1、类和接口的全限定名</li>
<li>2、字段的名称和描述符</li>
<li>3、方法的名称和描述符</li>
</ul>
</li>
<li>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</li>
<li>回收废弃常量与回收Java堆中的对象非常类似。</li>
<li>·判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
</li>
<li>Java虛拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了一Xnoclassgc 参数进行控制，还可以使用一verbose：class以及一XX： +TraceClass一Loading、一XX：+TraceClassUnLoading查 看类加载和卸载信息</li>
<li>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及oSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</li>
</ul>
<br/>

<h4 id="面试"><a href="#面试" class="headerlink" title="面试"></a><strong>面试</strong></h4><ul>
<li><p>百度</p>
<p>说一下JVM内存模型，有哪些区？分别干什么的？</p>
</li>
<li><p>蚂蚁金服</p>
<p>Java8的内存分代改进 JVM内存分哪几个区，每个区的作用是什么？ </p>
<p>JVM内存分布&#x2F;内存结构？栈和堆的区别？堆的结构？为什么两个Survivor区？</p>
<p>Eden和Survivor的比例分配</p>
</li>
<li><p>小米</p>
<p>JVM内存分区，为什么要有新生代和老年代</p>
</li>
<li><p>字节跳动</p>
<p>Java的内存分区 二面：讲讲JVM运行时数据库区 什么时候对象会进入老年代？</p>
</li>
<li><p>京东</p>
</li>
<li><p>JVM的内存结构，Eden和Survivor比例 。 </p>
<p>JVM内存为什么要分成新生代，老年代，持久代。</p>
<p>新生代中为什么要分为Eden和Survivor。</p>
</li>
<li><p>天猫</p>
<p>Jvm内存模型以及分区，需要详细到每个区放什么。</p>
<p>JVM的内存模型，Java8做了什么修改</p>
</li>
<li><p>拼多多</p>
<p>JVM内存分哪几个区，每个区的作用是什么？</p>
</li>
<li><p>美团</p>
<p>Java内存分配 JVM的永久代中会发生垃圾回收吗？</p>
<p>JVM内存分区，为什么要有新生代和老年代？</p>
</li>
</ul>
<br/>

<h2 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a><strong>对象的实例化</strong></h2><h3 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a><strong>创建对象的方式</strong></h3><ul>
<li><p>new</p>
<p>最常见的方式</p>
<p>变形1 ： Xxx的静态方法</p>
<p>变形2 ： XxBuilder&#x2F;XxoxFactory的静态方法</p>
</li>
<li><p>Class的newInstance（）：反射的方式，只能调用空参的构造器，权限必须是public</p>
</li>
<li><p>Constructor的newInstance（Xxx）：反射的方式，可以调用空参、带参的构造器，权限没有要求</p>
</li>
<li><p>使用clone（） ：不调用任何构造器，当前类需要实现Cloneable接口，实现clone（）</p>
</li>
<li><p>使用反序列化：从文件中、从网络中获取一个对象的二进制流</p>
</li>
<li><p>第三方库Objenesis</p>
</li>
</ul>
<br/>

<h3 id="创建对象的步骤"><a href="#创建对象的步骤" class="headerlink" title="创建对象的步骤"></a><strong>创建对象的步骤</strong></h3><h4 id="1-判断对象对应的类是否已加载、链接、初始化"><a href="#1-判断对象对应的类是否已加载、链接、初始化" class="headerlink" title="1. 判断对象对应的类是否已加载、链接、初始化"></a><strong>1. 判断对象对应的类是否已加载、链接、初始化</strong></h4><p> 检查元空间的常量池中是否有类的符号引用，检查是否加载链接初始化。</p>
<ul>
<li>如果是，则生成对应的Class文件。</li>
<li>如果否，则在双亲委派机制模式下，使用当前类以 【ClassLoader+包名+类名】为Key查找对应的.class文件。<ul>
<li>如果找到，进行加载生成对应的Class文件。</li>
<li>如果找不到，抛出ClassNotFoundException</li>
</ul>
</li>
</ul>
<h4 id="2-为对象分配内存"><a href="#2-为对象分配内存" class="headerlink" title="2. 为对象分配内存"></a><strong>2. 为对象分配内存</strong></h4><p>计算对象占用大小，堆中分配对应字节。如果实例变量是引用变量，仅分配4个字节。</p>
<ul>
<li>如果内存规整：指针碰撞<ul>
<li>所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带有compact （整理）过程的收集器时，使用指针碰撞。</li>
</ul>
</li>
<li>如果内存不规整：空闲列表<ul>
<li>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虛拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为“空闲列表（Free List）。</li>
</ul>
</li>
<li>说明：选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</li>
<li>给对象的属性赋值的操作先后顺序： ① 属性的默认初始化 ② 显式初始化&#x2F;代码块中初始化 （谁在前先谁执行） ③ 构造器中初始化</li>
</ul>
<h4 id="3-处理并发安全问题"><a href="#3-处理并发安全问题" class="headerlink" title="3. 处理并发安全问题"></a><strong>3. 处理并发安全问题</strong></h4><ol>
<li>CAS （ Compare And Swap ）失败重试、区域加锁：保证指针更新操作的原子性；</li>
<li>TLAB把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆的伊甸园区中预先分配一小块内存，称为本地线程分配缓冲区，（TLAB ，Thread Local Allocation Buffer） 虚拟机是否使用TLAB，可以通过一XX：+UseTLAB参数来 设定。</li>
</ol>
<h4 id="4-初始化分配到的空间"><a href="#4-初始化分配到的空间" class="headerlink" title="4. 初始化分配到的空间"></a><strong>4. 初始化分配到的空间</strong></h4><p>内存分配结束，虚拟机将分配到的内存空间都初始化为零值。这一步保证了对象的实例字段在Java代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<h4 id="5-设置对象的对象头"><a href="#5-设置对象的对象头" class="headerlink" title="5. 设置对象的对象头"></a><strong>5. 设置对象的对象头</strong></h4><p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p>
<h4 id="6-执行init方法进行初始化"><a href="#6-执行init方法进行初始化" class="headerlink" title="6. 执行init方法进行初始化"></a><strong>6. 执行init方法进行初始化</strong></h4><p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。 因此一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之 后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。</p>
<p>加载类元信息 -&gt; 为对象分配内存 -&gt; 处理并发问题 -&gt; 属性的默认初始化 -&gt; 设置对象头 -&gt; init方法</p>
<br/>

<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a><strong>对象的内存布局</strong></h3><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a><strong>对象头</strong></h4><p>运行时元数据</p>
<ul>
<li><p>哈希值（ HashCode ）</p>
<p>GC分代年龄</p>
<p>锁状态标志</p>
<p>线程持有的锁</p>
<p>偏向线程ID</p>
<p>偏向时间戳</p>
</li>
<li><p>类型指针：指向类元数据的InstanceKlass，确定该对象所属的类型</p>
</li>
</ul>
<blockquote>
<p>说明：如果是数组，还需记录数组的长度</p>
</blockquote>
<h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a><strong>实例数据</strong></h4><p> 它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段） 规则：</p>
<ul>
<li>相同宽度的字段总被分配在一起</li>
<li>父类中定义的变量会出现在子类之前</li>
<li>如果CompactFields参数为true（默认为true），子类的窄变量可能插入到父类变量的空隙</li>
</ul>
<h4 id="填充"><a href="#填充" class="headerlink" title="填充"></a><strong>填充</strong></h4><p>非必须，仅仅起到占位符作用。</p>
<br/>

<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a><strong>对象的访问定位</strong></h3><p>JVM通过栈帧中栈上reference访问到对象引用内部的对象实例。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bqtuX6"><img src="https://s1.ax1x.com/2022/03/13/bqtuX6.png" alt="bqtuX6.png" style="zoom: 67%;" /></a></p>
<br/>

<h4 id="对象访问的方式"><a href="#对象访问的方式" class="headerlink" title="对象访问的方式"></a><strong>对象访问的方式</strong></h4><h5 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a><strong>句柄访问</strong></h5><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bqtwB8"><img src="https://s1.ax1x.com/2022/03/13/bqtwB8.png" alt="bqtwB8.png"></a></p>
<p>通过句柄访问的实现方式中，JVM堆中会专门有一块区域用来作为句柄池，存储相关句柄所执行的实例数据地址（包括在堆中地址和在方法区中的地址）。这种实现方法由于用句柄表示地址，因此十分稳定。</p>
<br/>

<h4 id="直接访问（HotShot采用）"><a href="#直接访问（HotShot采用）" class="headerlink" title="直接访问（HotShot采用）"></a><strong>直接访问（HotShot采用）</strong></h4><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bqtdnf"><img src="https://s1.ax1x.com/2022/03/13/bqtdnf.png" alt="bqtdnf.png"></a></p>
<p>通过直接指针访问的方式中，reference中存储的就是对象在堆中的实际地址，在堆中存储的对象信息中包含了在方法区中的相应类型数据。这种方法最大的优势是速度快，在HotSpot虚拟机中用的就是这种方式。</p>
<br/>

<h3 id="直接内存（Direct-Memory）"><a href="#直接内存（Direct-Memory）" class="headerlink" title="直接内存（Direct Memory）"></a><strong>直接内存（Direct Memory）</strong></h3><p>Java中的内存分为两个部分，一部分是不需要JVM管理的直接内存，也被称为堆外内存。堆外内存就是把内存对象分配在JVM堆意外的内存区域，这部分内存不是虚拟机管理，而是由操作系统来管理，这样可以减少垃圾回收对应用程序的影响。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bqNDr6"><img src="https://s1.ax1x.com/2022/03/13/bqNDr6.jpg" alt="bqNDr6.jpg"></a></p>
<p>通常，访问直接内存的速度会优于Java堆。即读写性能高</p>
<ul>
<li>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存</li>
<li>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</li>
</ul>
<p>也可能导致OutOfMemoryError异常</p>
<p>由于直接内存在Java堆外，因此它的大小不会直接受限于一Xmx指定的最大 堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</p>
<ul>
<li>缺点<ul>
<li>分配回收成本较高</li>
<li>不受JVM内存回收管理</li>
</ul>
</li>
</ul>
<p>直接内存大小可以通过MaxDirectMemorySize设置</p>
<p>如果不指定，默认与堆的最大值一Xmx参数值一致</p>
<p><strong>Java 进程占用内存  &#x3D;  Java堆  + 本地直接内存</strong></p>
<br/>

<h1 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a><strong>执行引擎</strong></h1><hr>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bqdEb6"><img src="https://s1.ax1x.com/2022/03/13/bqdEb6.png" alt="bqdEb6.png"></a></p>
<h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a><strong>概述</strong></h2><p>执行引擎是 Java 虚拟机核心的组成部分之一。“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行处理是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行处理则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。</p>
<p>JVM 的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被 JVM 所识别的字节码指令、符号表，以及其他辅助信息。</p>
<p>那么，如果想要让一个 Java 程序运行起来，执行引擎（Execution Engine）的任务就是将字节码指令解释&#x2F;编译为对应平台上的本地机器指令才可以。简单来说，JVM 中的执行引擎充当了将高级语言翻译为机器语言的译者。</p>
<br/>

<h2 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a><strong>工作过程</strong></h2><p>从外观上来看，所有的Java虚拟机的执行引擎输入、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果。</p>
<p>具体过程：</p>
<ul>
<li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。</li>
<li>每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。</li>
<li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li>
</ul>
<br/>

<h2 id="Java代码编译执行过程"><a href="#Java代码编译执行过程" class="headerlink" title="Java代码编译执行过程"></a><strong>Java代码编译执行过程</strong></h2><p>大部分程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前,都需要经过下图各个步骤</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bqwNex"><img src="https://s1.ax1x.com/2022/03/13/bqwNex.png" alt="bqwNex.png"></a></p>
<ul>
<li>前面橙色是生成字节码文件的过程 和JVM无关</li>
<li>后面蓝色和绿色是JVM需要考虑的过程</li>
</ul>
<p>Java代码编译是由Java源码编译器来完成，Java字节码的执行就由JVM执行引擎来完成。</p>
<br/>

<h2 id="机器码、指令、汇编语言"><a href="#机器码、指令、汇编语言" class="headerlink" title="机器码、指令、汇编语言"></a><strong>机器码、指令、汇编语言</strong></h2><h3 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a><strong>机器码</strong></h3><ul>
<li>各种用二进制编码方式表示的指令，叫做<strong>机器指令码</strong>。开始，人们就用它采编写程序，这就是机器语言。</li>
<li>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</li>
<li>用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。</li>
<li>机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。</li>
</ul>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a><strong>指令</strong></h3><ul>
<li>由于机器码是有0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。</li>
<li>指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好</li>
<li>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。</li>
</ul>
<h4 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a><strong>指令集</strong></h4><ul>
<li>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。</li>
<li>如常见的<ul>
<li>x86指令集，对应的是x86架构的平台</li>
<li>ARM指令集，对应的是ARM架构的平台</li>
</ul>
</li>
</ul>
<h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a><strong>汇编语言</strong></h3><ul>
<li>由于指令的可读性还是太差，于是人们又发明了汇编语言。</li>
<li>在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。</li>
<li>在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。<ul>
<li>由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行。</li>
</ul>
</li>
</ul>
<h3 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a><strong>高级语言</strong></h3><ul>
<li>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言更接近人的语言</li>
<li>当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。</li>
</ul>
<h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a><strong>字节码</strong></h3><ul>
<li>字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</li>
<li>字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。</li>
<li>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。<ul>
<li>字节码的典型应用为Java bytecode</li>
</ul>
</li>
</ul>
<h3 id="C、C-源程序执行过程"><a href="#C、C-源程序执行过程" class="headerlink" title="C、C++源程序执行过程"></a><strong>C、C++源程序执行过程</strong></h3><p>编译过程又可以分成两个阶段：编译和汇编。</p>
<ul>
<li>编译过程：是读取源程序（字符流），对 之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码</li>
<li>汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。</li>
</ul>
<br/>

<h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a><strong>解释器</strong></h2><p> JVM设计者们的初衷仅仅只是单纯地为了<strong>满足Java程序实现跨平台特性</strong>，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。 </p>
<ul>
<li>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</li>
<li>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</li>
</ul>
<p>  在Java的发展历史里，一共有两套解释执行器，即古老的<strong>字节码解释器</strong>、现在普遍使用的<strong>模板解释器</strong>。</p>
<ul>
<li>字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。· - 而模板解释器将每一 条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。<ul>
<li>在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。<ul>
<li>Interpreter模块：实现了解释器的核心功能</li>
<li>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>

<h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a><strong>现状</strong></h3><ul>
<li>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、 Perl、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C&#x2F;C+ +程序员所调侃。</li>
<li>为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。</li>
<li>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</li>
</ul>
<br/>

<h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a><strong>编译器</strong></h2><h3 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a><strong>JIT编译器</strong></h3><ul>
<li>Java 语言的“编译器” 其实是一段“不确定”的操作过程，因为它可能是指一个<strong>前端编译器</strong>（其实叫“编译器的前端” 更准确一些）把.java文件转变成.class文件的过程。</li>
<li>也可能是指虚拟机的<strong>后端运行期编译器</strong>（JIT 编译器，Just In Time Compiler）把字节码转变成机器码的过程。</li>
<li>还可能是指使用<strong>静态提前编译器</strong>（AOT 编译器，Ahead Of Time Compiler）直接把. java文件编译成本地机器代码的过程。</li>
</ul>
<p>前端编译器： Sun的Javac、 Eclipse JDT中的增量式编译器（ECJ）</p>
<p>JIT编译器： HotSpot VM的C1、C2编译器。</p>
<p>AOT编译器： GNU Compiler for the Java （GCJ） 、Excelsior JET。</p>
<br/>

<h3 id="Java代码的执行分类"><a href="#Java代码的执行分类" class="headerlink" title="Java代码的执行分类"></a><strong>Java代码的执行分类</strong></h3><ul>
<li>第一种是将源代码编译成字节码文件，然后在运行时通过解释题将字节码文件转成机器码执行。</li>
<li>第二种是编译执行（直接编译成机器码）。现在虚拟机为了提高执行效率，会使用即是编译技术JIT将方法编译成机器码再执行。</li>
<li>HotSpot是目前市面上高性能虚拟机的代表之一。它采用解释器和即时编译器并存的架构。在JVM运行时，解释器和即时编译器能够相互协调，各自取长补短。尽量选择最合适的方法来权衡编译本地代码的事件和直接解释执行的事件。</li>
</ul>
<br/>

<h3 id="有了JIT为什么还需要解释器"><a href="#有了JIT为什么还需要解释器" class="headerlink" title="有了JIT为什么还需要解释器?"></a><strong>有了JIT为什么还需要解释器?</strong></h3><ul>
<li>JRockit虚拟机砍掉了解释器，只采用JIT。因为JRockit只部署在服务器上，一般已经有足够的时间让他进行指令编译过程，对于响应要求不高，等编译完成之后又更好的性能。</li>
<li>程序启动后，解释器可以马上发挥作用省去编译时间立即执行。编译器想要发挥作用，需要把代码编译成本地代码，需要一定执行的时间，但编译成本地代码后,执行效率高。</li>
<li>所以JRockit VM执行效率高，但程序在启动的时候需要花费更长的事件来编译。但在服务器端来说.更看重的给用户响应的时间而不是启动时间。</li>
<li>在JVM启动时，解释器立刻发挥作用，随着时间推移编译器发挥作用，把越来越多的代码编译成本地代码，从而提高执行效率。</li>
</ul>
<br/>

<h3 id="HotSpot-JVM执行方式"><a href="#HotSpot-JVM执行方式" class="headerlink" title="HotSpot JVM执行方式"></a><strong>HotSpot JVM执行方式</strong></h3><p>JVM启动之后，解释器立刻发挥作用对代码进行解释执行，随着程序运行时间的推移，JIT逐渐发挥作用，根据热点探测功能，将有价值的字节码编译成本地机器执行，从而提高执行效率。</p>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a><strong>案例</strong></h4><ul>
<li>机器在热机状态下可能承受的负载要大于冷机状态。如果以热机状态的流量进行切流，能使得处于冷机状态下的服务器无法承载流程而假死。</li>
<li>在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1&#x2F;8。</li>
</ul>
<h4 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a><strong>概念解释</strong></h4><ul>
<li>.java文件编译成.class文件的过程叫前端编译。对应前端编译器也可能是JVM在运行时期编译器JIT生成的class文件</li>
<li>还可能是使用静态提前编译器AOT（Ahead Of Time Compiler）直接把.java文件编译成本地机器代码</li>
<li>前端编译器：Sun的javac Ecplise JDT中的增量式编译器ECJ</li>
<li>JIT编译器：HotSpot VM的C1、C2编译器</li>
<li>AOT编译器：GNU Compiler for the Java GCJ 、 Excelsior JET</li>
</ul>
<h4 id="热点探测技术"><a href="#热点探测技术" class="headerlink" title="热点探测技术"></a><strong>热点探测技术</strong></h4><ul>
<li>一个被多次调用的方法或者方法体中的循环次数较多的循环体都可以成为热点代码。因此都可以通过JIT编译成本地机器指令，由于这种编译行为发生在方法执行的过程中，因此也成为栈上替换OSR（On Stack Replacement）编译。</li>
<li>HotSpot VM采用热点探测方式是基于计数器的特点探测。</li>
<li>采用基于计数器的热点探测，HotSpot VM将为每一个方法建立2个不同类型的计数器，分别是<strong>方法调用计数器</strong>（Invocation Counter）和<strong>回边计数器</strong>（Back Edge Counter）。<ul>
<li>方法调用计数器：记录方法调用的次数</li>
<li>汇编计数器：记录循环体执行的次数</li>
</ul>
</li>
</ul>
<h5 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a><strong>方法调用计数器</strong></h5><ul>
<li>用于统计方法的调用次数,默认阈值在Client模式1500次，Server模式下是10000次。超过这个阈值就会触发JIT编译。</li>
<li><code>-XX:CompileThreshold</code> 设置阈值。</li>
<li>当一个方法被调用，会先检查改方法是否存在JIT编译后的版本，如果存在直接使用被JIT编译成本地代码来执行。如果不存在，此方法的调用计数器+1，然后判断方法调用计数器和回边计数器是否超过阈值，如果超过阈值触发JIT提交一个该方法的代码编译请求。</li>
</ul>
<h5 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a><strong>回边计数器</strong></h5><ul>
<li>统计一个方法中循环体的执行次数，在字节码中遇到控制流往后跳转的指令成为回边（Back Edge）。</li>
<li>遇到回边指令，先判断JIT中是否有编译好的版本，有直接用，没有回边计数器+1，判断是否超过阈值，超过阈值触发JIT编译成本地代码缓存到方法区。</li>
</ul>
<h5 id="热点衰减"><a href="#热点衰减" class="headerlink" title="热点衰减"></a><strong>热点衰减</strong></h5><ul>
<li>不做任何设置，方法调用计数器统计的并不是被方法调用的绝对次数而是一个相对的执行频率。即一段时间之后方法被调用的次数。当超过一定的时间限定，如果方法调用次数打不到阈值触发JIT，那么这个方法的调用计数器就会减少一半，这个过程称为方法调用技术器的<strong>热度衰减</strong>，而这段时间称为方法统计的半衰期（Counter Half Life Time）。</li>
<li>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用<code>-XX:-UseCounterDecay</code>来关闭热度衰减，让方法计数器统计变成绝对次数，这样只要系统运行时间够长。绝大部分方法都会被编译成本地代码。</li>
<li><code>-XX:CounterHalfLifeTime</code> 设置半衰期的时间周期，单位是秒。</li>
</ul>
<br/>

<h1 id="垃圾回收机制（GC）"><a href="#垃圾回收机制（GC）" class="headerlink" title="垃圾回收机制（GC）"></a><strong>垃圾回收机制（GC）</strong></h1><hr>
<h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a><strong>概述</strong></h2><h3 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a><strong>什么是垃圾</strong></h3><p>垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。 如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空 间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。</p>
<ul>
<li>垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。</li>
<li>关于垃圾收集有三个经典问题：<ul>
<li>➢哪些内存需要回收？</li>
<li>➢什么时候回收？</li>
<li>➢如何回收？</li>
</ul>
</li>
<li>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</li>
</ul>
<br/>

<h3 id="为什么要回收垃圾"><a href="#为什么要回收垃圾" class="headerlink" title="为什么要回收垃圾"></a><strong>为什么要回收垃圾</strong></h3><ul>
<li>对于高级语言来说，一个基本认知是，如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</li>
<li>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM 将整理出的内存分配给新的对象。</li>
<li>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</li>
</ul>
<br/>

<h3 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a><strong>Java垃圾回收机制</strong></h3><ul>
<li>自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险</li>
<li>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发</li>
<li>对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。</li>
<li>此时，了 解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见OutOfMemoryError时， 快速地根据错误异常日志定位问题和解决问题。</li>
<li>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。</li>
<li>垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区的回收。<ul>
<li>其中，Java堆是垃圾收集器的工作重点。</li>
<li>从次数上讲：<ul>
<li>频繁收集Young区</li>
<li>较少收集0ld区</li>
<li>基本不动Perm区(方法区)</li>
</ul>
</li>
</ul>
</li>
</ul>
<br/>

<h2 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a><strong>GC算法</strong></h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a><strong>引用计数法</strong></h3><h4 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a><strong>概念</strong></h4><p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型 的引用计数器属性。用于记录对象被引用的情况。</p>
<p>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p>
<br/>

<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h4><p><strong>优点</strong></p>
<ul>
<li>实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>需要单独的字段存储计数器，这样的做法增加了存储空间的开销。</li>
<li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。</li>
<li>引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一 条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。</li>
</ul>
<br/>

<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a><strong>复制算法</strong></h3><h4 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a><strong>概念</strong></h4><p> 将活着的内存空间分为两块，每次使用一块，进行垃圾回收的时候，将存活对象复制到另一块未使用的区域，然后将源区域清空，然后交换两个内存的角色。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bqyjtx"><img src="https://s1.ax1x.com/2022/03/13/bqyjtx.png" alt="bqyjtx.png"></a></p>
<br/>

<h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h4><p><strong>优点</strong></p>
<ul>
<li>没有标记和清除过程，实现简单，运行高效。</li>
<li>复制过去以后保证<strong>空间连续性</strong>，不会出现“碎片”问题。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li>
<li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。</li>
<li><strong>特别的</strong>，如果系统中的可用对象很多，复制算法不会很理想，因为要复制大量的对象</li>
</ul>
<p>在新生代，对常规应用的垃圾回收，一次通常可以回收70%~ 99%的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p>
<br/>

<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a><strong>标记清除</strong></h3><h4 id="概念-7"><a href="#概念-7" class="headerlink" title="概念"></a><strong>概念</strong></h4><p>当堆中的有效内存空间被耗尽时，就会停止程序STW，然后进行标记-清除。</p>
<ul>
<li>标记：Collector从引用的根节点开始遍历，标记所有的被引用的对象，在对象的对象头中记录为可达对象。</li>
<li>清除：将对象头中没有标记为可达对象的对象进行清除。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bq6du4"><img src="https://s1.ax1x.com/2022/03/13/bq6du4.png" alt="bq6du4.png" style="zoom: 67%;" /></a></p>
<br/>

<p><strong>优缺点</strong></p>
<p><strong>优点</strong></p>
<ul>
<li>常用，简单</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>效率不算高（两次O(n)）。</li>
<li>在进行GC的时候，需要停止整个应用程序，导致用户体验差。</li>
<li>这种方式清理出来的<strong>空闲内存是不连续的，产生内存碎片</strong>，需要维护一个空闲列表。</li>
</ul>
<p>标记清除算法中所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放。</p>
<br/>

<h3 id="标记压缩"><a href="#标记压缩" class="headerlink" title="标记压缩"></a><strong>标记压缩</strong></h3><h4 id="概念-8"><a href="#概念-8" class="headerlink" title="概念"></a><strong>概念</strong></h4><ul>
<li>第一阶段和标记一清除算法一样，从根节点开始标记所有被引用对象。</li>
<li>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。</li>
<li>之后，清理边界外所有的空间。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bq6b28"><img src="https://s1.ax1x.com/2022/03/13/bq6b28.png" alt="bq6b28.png"></a></p>
<ul>
<li>标记一压缩算法的最终效果等同于标记一清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记一清除一压缩（Mark一 Sweep一Compact）算法。</li>
<li>二者的本质差异在于<strong>标记清除算法是一种非移动式</strong>的回收算法，<strong>标记压缩是移动式</strong>的。是否移动回收后的存活对象是一项优缺点并存的风险决策。</li>
<li>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</li>
</ul>
<br/>

<h4 id="指针碰撞"><a href="#指针碰撞" class="headerlink" title="指针碰撞"></a><strong>指针碰撞</strong></h4><p>如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞（Bump the Pointer） 。</p>
<br/>

<h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h4><p><strong>优点</strong></p>
<ul>
<li>消除了标记清除算法当中内存区域分散的缺点。我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li>
<li>消除了复制算法当中，内存减半的高额代价。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>从效率.上来说，标记压缩算法要低于复制算法。</li>
<li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。</li>
<li>移动过程中，需要全程暂停用户应用程序。即： STW</li>
</ul>
<br/>

<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a><strong>对比</strong></h3><table>
<thead>
<tr>
<th>属性\算法</th>
<th>标记清除算法</th>
<th>复制算法</th>
<th>标记压缩算法</th>
</tr>
</thead>
<tbody><tr>
<td>时间复杂度</td>
<td>中</td>
<td>快</td>
<td>满</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>少</td>
<td>占用2倍</td>
<td>少</td>
</tr>
<tr>
<td>内存碎片</td>
<td>有</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>移动对象</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<p>可以看出：</p>
<ul>
<li>内存效率：复制算法 &gt; 标记清除算法 &gt; 标记压缩算法 （时间复杂度）；</li>
<li>内存整齐度：复制算法 &#x3D; 标记压缩算法 &gt; 标记清除算法；</li>
<li>内存利用率：标记压缩算法 &#x3D; 标记清除算法 &gt; 复制算法；</li>
</ul>
<p>效率上来说，复制算法是最好的，但是却浪费了太多内存，而为了尽量兼顾上面所提到的三个指标，标记压缩算法相对来说更平滑一些 ， 但是效率上依然不尽如人意，它比复制算法多了一个标记的阶段，又比标记清除多了一个整理内存的过程。</p>
<br/>

<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a><strong>分代收集算法</strong></h3><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p>
<p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，<strong>不同生命周期的对象可以采取不同的收集方式，以便提高回收效率</strong>。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p>
<p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，</p>
<ul>
<li>比如Http请求中的Session对象、线程、Socket连接， 这类对象跟业务直接挂钩，因此生命周期比较长</li>
<li>但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如： String对象， 由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</li>
</ul>
<p>  目前几乎所有的GC都是采用分代收集（Generational Collecting） 算法执行垃圾回收的。  在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p>
<ul>
<li>年轻代（Young Gen）<ul>
<li>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</li>
<li>这种情况<strong>复制算法</strong>的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过Hotspot中的两个Survivor的设计得到缓解。</li>
</ul>
</li>
<li>老年代（Tenured Gen）<ul>
<li>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</li>
<li>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由<strong>标记清除或者是标记整理的混合实现</strong>。<ul>
<li>标记阶段的开销与存活对象的数量成正比。</li>
<li>清除阶段的开销与所管理区域的大小成正相关。</li>
<li>压缩阶段的开销与存活对象的数据成正比。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>以HotSpot中的CMS回收器为例，CMS是基于标记清除实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于标记压缩算法的Serialold回收器作为补偿措施：当内存回收不佳（碎片导致的执行失败时），将采用Serial 0ld执行Full GC（标记整理算法）以达到对老年代内存的整理。 分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代。</p>
<br/>

<h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a><strong>JMM</strong></h2><h3 id="概念-9"><a href="#概念-9" class="headerlink" title="概念"></a><strong>概念</strong></h3><p>JMM，即Java内存模型（Java memory model），在JSR133里指出了JMM是用来定义一个<strong>一致的、跨平台</strong>的内存模型，是缓存一致性协议，用来定义数据读写的规则。</p>
<blockquote>
<p>内存模型描述了程序中各个变量（实例域、静态域和数组元素）之间的关系，以及在实际计算机系统中将变量存储到内存和从内存中取出变量这样的底层细节</p>
</blockquote>
<p>JMM本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范。它是围绕着在并发过程中如何处理<strong>可见性</strong>、<strong>原子性</strong>、<strong>有序性</strong>这三个特性而建立的模型。</p>
<br/>

<h3 id="为什么要引入JMM"><a href="#为什么要引入JMM" class="headerlink" title="为什么要引入JMM"></a><strong>为什么要引入JMM</strong></h3><ul>
<li>在Java语言之前，C、C++等语言是直接使用物理硬件和操作系统的内存模型的，正因为这些语言直接和底层打交道，使得这些语言执行效率更高，但同时也带来了一些问题：由于不同平台上，软件和硬件都有一定差异（比如硬件厂商不同、操作系统不同），导致有可能同一个程序在一套平台上执行没问题，另一个平台上执行却得到不一样的结果，甚至报错。</li>
<li>Java语言试图定义一个Java内存模型来屏蔽掉各种硬件和操作系统的内存访问差异，达到让Java程序在不同平台上都能达到一致的内存访问效果的目的，这就是Java内存模型的意义。</li>
</ul>
<br/>

<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a><strong>结构</strong></h3><blockquote>
<p>JMM规定了所有的变量都存储在主内存（Main Memory）中。每个线程还有自己的工作内存（Working Memory）,线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量（volatile变量仍然有工作内存的拷贝，但是由于它特殊的操作顺序性规定，所以看起来如同直接在主内存中读写访问一般）。不同的线程之间也无法直接访问对方工作内存中的变量，线程之间值的传递都需要通过主内存来完成。</p>
</blockquote>
<h4 id="主内存和本地内存结构"><a href="#主内存和本地内存结构" class="headerlink" title="主内存和本地内存结构"></a><strong>主内存和本地内存结构</strong></h4><p>从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读&#x2F;写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。本地内存它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化之后的一个数据存放位置。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bqWbnO"><img src="https://s1.ax1x.com/2022/03/13/bqWbnO.jpg" alt="bqWbnO.jpg"></a></p>
<p>一句话概括本地内存和主内存的关系：线程无法直接对共享变量进行读取、修改操作，因此在线程中开辟了一块工作内存，存放共享变量的变量副本。</p>
<br/>

<h3 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a><strong>三大特性</strong></h3><h4 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a><strong>原子性（Atomicity）</strong></h4><p><strong>一个操作不能被打断，要么全部执行完毕，要么不执行。在这点上有点类似于事务操作，要么全部执行成功，要么回退到执行该操作之前的状态</strong>。</p>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a><strong>可见性</strong></h4><p><strong>一个线程对共享变量做了修改之后，其他的线程立即能够看到（感知到）该变量的这种修改（变化）</strong>。</p>
<h4 id="有序性："><a href="#有序性：" class="headerlink" title="有序性："></a><strong>有序性：</strong></h4><p><strong>在单线程环境下，程序的执行是按照一定顺序执行的，无论何时何地执行，都能保证输出结果是一致的。在多线程环境下，在本线程内观察，所有操作是有序的；在其他线程看来，所有操作是无序的。</strong></p>
<br/>

<h3 id="JMM的内存间的交互"><a href="#JMM的内存间的交互" class="headerlink" title="JMM的内存间的交互"></a><strong>JMM的内存间的交互</strong></h3><p>Java内存模型定义了8种操作来完成交互：</p>
<ul>
<li><p><strong>lock（锁定）</strong>：作用于主内存的变量，把一个变量标识为一条线程独占状态。</p>
</li>
<li><p><strong>unlock（解锁）</strong>：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</p>
</li>
<li><p><strong>read（读取）</strong>：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</p>
</li>
<li><p><strong>load（载入）</strong>：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</p>
</li>
<li><p><strong>use（使用）</strong>：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</p>
</li>
<li><p><strong>assign（赋值）</strong>：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</p>
</li>
<li><p><strong>store（存储）</strong>：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作</p>
</li>
<li><p><strong>write（写入）</strong>：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</p>
</li>
</ul>
<p><strong>Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：</strong></p>
<ul>
<li>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。</li>
<li>不允许read和load、store和write操作之一单独出现。</li>
<li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</li>
<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</li>
<li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</li>
<li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现。</li>
<li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值。</li>
<li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</li>
</ul>
<br/>

<h3 id="JMM保证多线程环境下的线程同步问题"><a href="#JMM保证多线程环境下的线程同步问题" class="headerlink" title="JMM保证多线程环境下的线程同步问题"></a><strong>JMM保证多线程环境下的线程同步问题</strong></h3><ul>
<li><p><strong>使用volatile关键字</strong></p>
</li>
<li><p><strong>为什么volatile关键字不能保证线程的安全性？</strong></p>
</li>
<li><ul>
<li>保证了有序性和可见性。</li>
<li>不保证原子性。</li>
<li>综上不能保证线程的安全性。</li>
</ul>
</li>
<li><p><strong>volatile关键字如何保证了线程的可见性的？</strong></p>
</li>
<li><ul>
<li>复习一下JMM的内存间是如何进行交互的：如果要修改共享变量的值，首先要将修改后的值assign到工作内存的变量副本中，然后进行store、write操作到主内存中，至此一个完整的修改共享变量操作结束。</li>
<li>对于普通变量来说，当进行了assign操作后，并不一定马上将assign后的变量副本的值刷新（store、write）到主内存中。</li>
<li>对于volatile修饰的变量来说，当进行了assign操作后，会强制将assign后变量副本的值刷新到主内存中，这样就保证了多线程之间变量的可见性。</li>
</ul>
</li>
<li><p><strong>volatile关键字为何不能保证原子性？</strong></p>
</li>
<li><ul>
<li>既然在保证可见性的时候，assign后的变量副本会马上进行store、write操作，那么为什么不能保证原子性呢？原因就出在“<strong>马上</strong>”</li>
<li>在Java语言中，只有对基本数据类型的赋值、读取操作保证原子性，如 a &#x3D; 1；这个语句在JVM内部就是一个原子操作。</li>
<li>而一次修改共享变量的操作有assign、store、write，因此有可能A线程进行assign操作之后，失去了CPU执行权，B线程此时获得CPU执行权，也进行assign操作，此时进行store、write操作之后，A再获得CPU执行权，再进行store、write操作，此时就会导致线程安全问题。</li>
</ul>
</li>
<li></li>
<li><p><strong>volatile关键字如何保证有序性的？</strong></p>
</li>
<li><ul>
<li>使用volatile关键字后可以<strong>禁止指令重排序</strong>，保证有序性。</li>
<li><strong>什么是指令重排序？</strong></li>
<li>对于我们手写的每一句代码，JVM都不能理解和执行，.java文件要先通过编译成字节码文件（.class结尾），然后通过类加载器，加载到JVM中，JVM再转换成一串01机器码，无论什么语言运行，最后都会转化称为机器码，因为计算机只认机器码。</li>
</ul>
</li>
<li><p>按照推理，指令执行顺序应该是和我们编写的程序一一对应的,但实际上编译器、CPU、JVM会出于优化的目的，对指令的执行顺序进行调整，这就是指令的重排序。</p>
</li>
<li><p><strong>重排序带来的好处显而易见：提高了整个程序执行的效率，但是重排序带来了哪些问题，又要如何解决呢？</strong></p>
<ul>
<li>重排序只能保证单线程环境下结果的一致性，但是在多线程环境下会导致结果的不一致性。</li>
<li>使用volatile关键字对变量进行修饰，可以禁止指令的重排序。</li>
</ul>
</li>
<li><p><strong>volatile是如何禁止指令重排序的？原理是什么？</strong></p>
<ul>
<li><p>原理就是：<strong>在指令间插入的内存屏障</strong>。</p>
</li>
<li><p>内存屏障的分类？（<strong>对比JMM内存模型理解</strong>）</p>
<ul>
<li><p>Load LoadBarrier  </p>
<p>Load1在Load2之前读取完成</p>
</li>
<li><p>LoadStoreBarrier </p>
<p>Load1在Store2读取完成</p>
</li>
<li><p>StoreStoreBarrier</p>
<p>Store1在Store2之前写入主内存，并且对其他所有处理器可见</p>
</li>
<li><p>StoreLoadBarrier</p>
<p>Store在Load2之前写入写入主内存，并且对其他所有处理器可见</p>
</li>
</ul>
</li>
<li><p><strong>内存屏障原理</strong>：</p>
</li>
<li><ul>
<li>在每个volatile读操作之后插入一个LoadLoad屏障，在读操作插入一个LoadStore屏障，禁止了volatile修饰的变量对应指令和接下来其他指令的重排序。</li>
<li>在每个volatile写操作前面插入一个StoreStore屏障，后面插入一个StoreLoad屏障。</li>
</ul>
</li>
<li></li>
</ul>
</li>
<li><p><strong>对于Java内存模型中，指令重排序是为了优化指令集，达到提高系统效率的效果，那么重排序是随便进行排序吗？如果不是，应该遵守什么原则呢？</strong></p>
</li>
<li><ul>
<li>重排序当然不可能是随便进行的，是要遵守一定原则的，这样才能使得在单线程环境下，无论如何，最后执行的结果都是一致的。</li>
<li>遵守<strong>先行发生原则（Happens-Before）</strong>：先行发生原则并不是一个原则，是<strong>八大原生子原则的归纳</strong>，理解了子原则，也就很容易理解什么是先行发生原则。</li>
<li><strong>程序次序规则</strong>：一个线程内，按照控制流顺序，书写前面的操作先执行于书写在后面的操作。注意:这里说的是控制流，而不是程序代码顺序，因为要考虑分支、循环等结构。</li>
</ul>
</li>
<li><ul>
<li><strong>volatile变量规则</strong>：对于一个被volatile修饰的变量进行的写操作一定先行发生于后面对这个变量的读操作。</li>
<li><strong>管程锁定原则（监视器锁定原则）</strong>：无论单线程还是多线程环境下，对于一个被锁定的对象，首先要进行unlock操作，才能再进行lock操作，也就是说：“一个unlock操作先行发生于后面对同一个对象的lock操作”</li>
<li><strong>线程启动原则</strong>：假如线程A执行了ThreadB.start()（启动了线程B），那么A线程在之前对共享变量的修改将能够被线程B读取。</li>
<li><strong>线程终止原则</strong>：线程中所有操作都先行发生于对此线程的终止检测，我们可以通过join（）方法是否结束、isAlive（）方法的返回值等手段检测线程是否已经终止执行。</li>
<li><strong>线程中断原则</strong>：对线程interrupt方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过interrupt方法检测是否有中断发生。</li>
<li><strong>对象终结原则</strong>：一个对象的初始化完成（构造方法执行完成）先行发生于它的finalize方法的开始。</li>
<li><strong>传递原则</strong>：如果A操作先行发生于B操作，B操作先行发生于C操作，那么一定有A操作先行发生于C操作。（此处证明先行发生原则具有传递性）</li>
</ul>
</li>
<li><p><strong>对于先行发生原则的总结</strong>：</p>
<ul>
<li><p>先行发生原则是八大原生原则的概括，既然有原生原则，肯定有衍生原则，衍生原则就是结合八大原生原则推到出来的原则。</p>
</li>
<li><p>先行发生原则本质上就是一种用来指定两个操作之间执行顺序的规则。由于两个操作可能在单线程内，也可能在多线程内，因此JMM通过happens-before关系向程序员提供跨线程的内存可见性。</p>
</li>
</ul>
</li>
</ul>
<br/>

<p>end</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>Buy me a coffee</div>
  <button onclick="document.querySelector('.post-reward').classList.toggle('active');">
    Donate
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="Ssssv11 WeChat Pay">
        <span>WeChat Pay</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/Java-JVM/" rel="tag"><i class="fa fa-tag"></i> Java JVM</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/04/29/Java8/" rel="prev" title="Java8">
                  <i class="fa fa-chevron-left"></i> Java8
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/04/29/HTML/" rel="next" title="HTML">
                  HTML <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ssssv</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script size="90" alpha="0.6" zIndex="-1" src="/js/ribbon/ribbon.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="/js/local-search.js"></script>






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>

<script src="/js/cursor/fireworks.js"></script>

