<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="baidu-site-verification" content="code-jbS6cVmQ2r">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.lug.ustc.edu.cn/css?family=JetBrains+Mono:300,300italic,400,400italic,700,700italic%7CFira+Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ssssv11.github.io","root":"/","images":"/images","scheme":"Pisces","version":"8.2.2","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"manual"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="面试八股文">
<meta property="og:type" content="article">
<meta property="og:title" content="面试八股文">
<meta property="og:url" content="https://ssssv11.github.io/2022/09/15/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/index.html">
<meta property="og:site_name" content="Ssssv">
<meta property="og:description" content="面试八股文">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.loli.net/2022/09/20/CceHsnEJp8hZMB5.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/20/yWApstLGFBo7Jiz.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/23/89ri6aFJsbA4YEf.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/20/If6iWvV73pntgca.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/20/hn3W5DkmAXazPVr.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/20/VgJejDkBR5pTONZ.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/20/Urtu9DoSwa7fdvy.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/20/pFLDbM8rRNzGvkt.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/20/vbIeXyV8xoR6pEa.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/20/sK7i8IEoMzWcnHl.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/20/E4AieYPozySKq6n.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/20/zoJxvbMusq6iHrp.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/21/6OVWEBNfIv5ctPu.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/21/IE8VKobtwXAph6f.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/21/N5xkLuTAj4m8n32.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/22/rQbtNj8zMF16vnV.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/09/22/xFxy90.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/09/22/xFxccT.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/09/24/xAaTVx.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/09/24/xAavMd.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/09/24/xAYbcR.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/09/24/xA0Pgg.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/09/25/xEFFSJ.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/09/25/xEEB1e.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/09/25/xEMVo9.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/09/25/xEMYFA.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/09/25/xEQm7Q.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/09/25/xEQdhR.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/09/25/xElaqS.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/09/25/xElXZD.png">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/278fe431-af88-4a95-a895-9c3b80117de3.jpg">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/62e77997-6957-4b68-8d12-bfd609bb2c68.jpg">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4cf711a8-7ab2-4152-b85c-d5c226733807.png">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9bbddeeb-e939-41f0-8e8e-2b1a0aa7e0a7.png">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f99ee771-c56f-47fb-9148-c0036695b5fe.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2022/09/25/xEgkIH.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/25/UEPkmR8qrM1xgZO.png">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/bb6a49be-00f2-4f27-a0ce-4ed764bc605c.png">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/051e436c-0e46-4c59-8f67-52d89d656182.png">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/baaa681f-7c52-4198-a5ae-303b9386cf47.png">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/390c913b-5f31-444f-bbdb-2b88b688e7ce.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/19/ObCXJ1.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/18/OoXzUU.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/18/Ooxi0x.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/21/OjaKns.md.png">
<meta property="og:image" content="https://s2.loli.net/2022/03/25/hnHQdtLoxcOpUjE.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/26/XELtXD.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/26/XEjFkd.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/ODF3Pf.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/ODF2L9.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/ODkfXQ.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/ODAl38.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/ODA03T.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/ODEyz8.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/ODZYHH.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/OrUdQU.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/13/Oslk7V.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/14/O627TI.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/05/14/O6fYTA.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/09/28/xmE4uF.png">
<meta property="og:image" content="https://s1.imagehub.cc/images/2022/04/18/QQ20220418194935.png">
<meta property="og:image" content="https://s1.imagehub.cc/images/2022/04/18/1614350-20201209082514905-1720451943.png">
<meta property="og:image" content="https://s1.imagehub.cc/images/2022/04/18/QQ20220418195434.png">
<meta property="og:image" content="https://s1.imagehub.cc/images/2022/04/18/QQ20220418195601.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/de6d2b213f112297298f3e223bf08f28.png">
<meta property="og:image" content="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/sort1.png">
<meta property="og:image" content="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/bubble_sort.gif">
<meta property="og:image" content="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/selection_sort.gif">
<meta property="og:image" content="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/insertion_sort.gif">
<meta property="og:image" content="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/random_quick_sort.gif">
<meta property="article:published_time" content="2022-09-15T02:22:42.950Z">
<meta property="article:modified_time" content="2022-09-28T14:01:02.208Z">
<meta property="article:author" content="Ssssv11">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/09/20/CceHsnEJp8hZMB5.png">


<link rel="canonical" href="https://ssssv11.github.io/2022/09/15/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>
<title>面试八股文 | Ssssv</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Ssssv</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">26</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">44</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%AF%87"><span class="nav-number">1.</span> <span class="nav-text">基础篇</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86"><span class="nav-number">1.1.</span> <span class="nav-text">基础概念与常识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E8%AF%AD%E8%A8%80%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.1.1.</span> <span class="nav-text">Java 语言的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E7%A0%81%E3%80%81%E9%87%87%E7%94%A8%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.1.2.</span> <span class="nav-text">什么是字节码、采用字节码的好处是什么</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.</span> <span class="nav-text">基本数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E4%B8%AD%E7%9A%84%E5%85%AB%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.1.</span> <span class="nav-text">Java 中的八种基本数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1%E5%8F%8A%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="nav-number">1.2.2.</span> <span class="nav-text">自动装箱与拆箱及缓存机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.2.3.</span> <span class="nav-text">隐式类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#float-%E4%B8%8E-double"><span class="nav-number">1.2.4.</span> <span class="nav-text">float 与 double</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E7%9A%84%E6%97%B6%E5%80%99%E4%BC%9A%E6%9C%89%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%A3%8E%E9%99%A9"><span class="nav-number">1.2.5.</span> <span class="nav-text">为什么浮点数运算的时候会有精度丢失的风险</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E7%9A%84%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.6.</span> <span class="nav-text">如何解决浮点数运算的精度丢失问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B6%85%E8%BF%87-long-%E6%95%B4%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA"><span class="nav-number">1.2.7.</span> <span class="nav-text">超过 long 整型的数据应该如何表示</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80"><span class="nav-number">1.3.</span> <span class="nav-text">面向对象基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.1.</span> <span class="nav-text">面向对象与面向过程的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="nav-number">1.3.2.</span> <span class="nav-text">面向对象三大特征</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">多态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-number">1.3.3.</span> <span class="nav-text">接口和抽象类的异同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD"><span class="nav-number">1.3.4.</span> <span class="nav-text">重写与重载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%86%99"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">重写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">重载</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">1.3.5.</span> <span class="nav-text">Java 创建对象的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.6.</span> <span class="nav-text">深拷贝和浅拷贝的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.4.</span> <span class="nav-text">关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#final"><span class="nav-number">1.4.1.</span> <span class="nav-text">final</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static"><span class="nav-number">1.4.2.</span> <span class="nav-text">static</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E5%B8%B8%E8%A7%81%E7%B1%BB"><span class="nav-number">1.5.</span> <span class="nav-text">Java 常见类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Object"><span class="nav-number">1.5.1.</span> <span class="nav-text">Object</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#equals-%E4%B8%8E-x3D-x3D"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">equals 与 &#x3D;&#x3D;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hashCode-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">hashCode 有什么用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-hashCode"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">为什么要有 hashCode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E8%AE%AE%E8%A6%81%E5%90%8C%E6%97%B6%E9%87%8D%E5%86%99-equals-%E4%B8%8E-hashCode"><span class="nav-number">1.5.1.4.</span> <span class="nav-text">为什么建议要同时重写 equals 与 hashCode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%B8%A4%E4%B8%AA%E4%B8%8D%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8D%B4%E6%8B%A5%E6%9C%89%E7%9B%B8%E5%90%8C-hashcode-%E7%9A%84%E6%83%85%E5%86%B5%E5%90%97"><span class="nav-number">1.5.1.5.</span> <span class="nav-text">会出现两个不相等的对象却拥有相同 hashcode 的情况吗</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String"><span class="nav-number">1.5.2.</span> <span class="nav-text">String</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#String%E3%80%81StringBuffer-%E4%B8%8E-StringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">String、StringBuffer 与 StringBuilder 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">String 为什么是不可变的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String-%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">String 不可变的好处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E7%94%A8-%E8%BF%98%E6%98%AF-StringBuilder"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">字符串拼接用 + 还是 StringBuilder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.5.2.5.</span> <span class="nav-text">字符串常量池是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String-s1-x3D-new-String-%E2%80%9Cabc%E2%80%9D-%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.5.2.6.</span> <span class="nav-text">String s1 &#x3D; new String(“abc”) 创建了几个字符串对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#intern-%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.5.2.7.</span> <span class="nav-text">intern 方法的作用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">1.6.</span> <span class="nav-text">异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Exception-%E5%92%8C-Error-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.6.1.</span> <span class="nav-text">Exception 和 Error 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Checked-Exception-%E5%92%8C-Unchecked-Exception-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.6.2.</span> <span class="nav-text">Checked Exception 和 Unchecked Exception 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Throwable-%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">1.6.3.</span> <span class="nav-text">Throwable 类常用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#try-catch-finally-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="nav-number">1.6.4.</span> <span class="nav-text">try-catch-finally 如何使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#finally-%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%80%E5%AE%9A%E4%BC%9A%E6%89%A7%E8%A1%8C%E5%90%97"><span class="nav-number">1.6.5.</span> <span class="nav-text">finally 中的代码一定会执行吗</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">1.7.</span> <span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B"><span class="nav-number">1.7.1.</span> <span class="nav-text">什么是泛型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">1.7.2.</span> <span class="nav-text">泛型的使用方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B3%9B%E5%9E%8B"><span class="nav-number">1.7.3.</span> <span class="nav-text">项目中常用的泛型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">1.8.</span> <span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84"><span class="nav-number">1.8.1.</span> <span class="nav-text">什么是反射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.8.2.</span> <span class="nav-text">反射的优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96-Class-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">1.8.3.</span> <span class="nav-text">获取 Class 对象的四种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.8.4.</span> <span class="nav-text">反射的应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.9.</span> <span class="nav-text">注解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.9.1.</span> <span class="nav-text">什么是注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E8%A7%A3%E6%9E%90%E6%96%B9%E6%B3%95"><span class="nav-number">1.9.2.</span> <span class="nav-text">注解的解析方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-x2F-O"><span class="nav-number">1.10.</span> <span class="nav-text">I&#x2F;O</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">1.10.1.</span> <span class="nav-text">序列化与反序列化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%B8%8D%E9%9C%80%E8%A6%81%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%AD%97%E6%AE%B5"><span class="nav-number">1.10.2.</span> <span class="nav-text">如何处理不需要序列化的字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-IO-%E6%B5%81"><span class="nav-number">1.10.3.</span> <span class="nav-text">Java IO 流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-x2F-O-%E6%B5%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E4%B8%BA%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="nav-number">1.10.4.</span> <span class="nav-text">I&#x2F;O 流为什么要分为字节流和字符流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BIO%E3%80%81NIO-%E5%92%8C-AIO"><span class="nav-number">1.10.5.</span> <span class="nav-text">BIO、NIO 和 AIO</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E9%87%8D%E7%82%B9"><span class="nav-number">1.11.</span> <span class="nav-text">其他重点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Java-%E4%B8%AD%E5%8F%AA%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92"><span class="nav-number">1.11.1.</span> <span class="nav-text">为什么 Java 中只有值传递</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%A2%E5%8F%82-amp-%E5%AE%9E%E5%8F%82"><span class="nav-number">1.11.1.1.</span> <span class="nav-text">形参 &amp; 实参</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92-amp-%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="nav-number">1.11.1.2.</span> <span class="nav-text">值传递 &amp; 引用传递</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Java-%E5%8F%AA%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92"><span class="nav-number">1.11.1.3.</span> <span class="nav-text">为什么 Java 只有值传递</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.11.1.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.11.2.</span> <span class="nav-text">代理模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">1.11.2.1.</span> <span class="nav-text">静态代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">1.11.2.2.</span> <span class="nav-text">动态代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">1.11.2.3.</span> <span class="nav-text">静态代理和动态代理</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">2.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#List"><span class="nav-number">2.1.</span> <span class="nav-text">List</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList-%E4%B8%8E-LinkedList-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.1.1.</span> <span class="nav-text">ArrayList 与 LinkedList 的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E4%BD%BF%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">底层使用的数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-1"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">线程安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">2.1.1.3.</span> <span class="nav-text">插入与删除的复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E6%A0%91"><span class="nav-number">2.1.1.4.</span> <span class="nav-text">继承树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="nav-number">2.1.2.</span> <span class="nav-text">ArrayList 扩容机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CopyOnWriteArrayList"><span class="nav-number">2.1.3.</span> <span class="nav-text">CopyOnWriteArrayList</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Set"><span class="nav-number">2.2.</span> <span class="nav-text">Set</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E5%BA%8F%E6%80%A7%E4%B8%8E%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%80%A7"><span class="nav-number">2.2.1.</span> <span class="nav-text">无序性与不可重复性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashSet%E3%80%81LinkedHashSet-%E5%92%8C-TreeSet"><span class="nav-number">2.2.2.</span> <span class="nav-text">HashSet、LinkedHashSet 和 TreeSet</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Queue"><span class="nav-number">2.3.</span> <span class="nav-text">Queue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Queue-%E4%B8%8E-Deque"><span class="nav-number">2.3.1.</span> <span class="nav-text">Queue 与 Deque</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayDeque-%E4%B8%8E-LinkedList-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.3.2.</span> <span class="nav-text">ArrayDeque 与 LinkedList 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PriorityQueue"><span class="nav-number">2.3.3.</span> <span class="nav-text">PriorityQueue</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map"><span class="nav-number">2.4.</span> <span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-%E4%B8%8E-Hashtable"><span class="nav-number">2.4.1.</span> <span class="nav-text">HashMap 与 Hashtable</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-2"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">线程安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%88%E7%8E%87"><span class="nav-number">2.4.1.2.</span> <span class="nav-text">效率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Null-Key-%E5%92%8C-Null-Value"><span class="nav-number">2.4.1.3.</span> <span class="nav-text">Null Key 和 Null Value</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%AE%B9%E9%87%8F%E4%B8%8E%E6%89%A9%E5%AE%B9%E5%A4%A7%E5%B0%8F"><span class="nav-number">2.4.1.4.</span> <span class="nav-text">初始容量与扩容大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.4.1.5.</span> <span class="nav-text">数据结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-%E4%B8%8E-HashSet"><span class="nav-number">2.4.2.</span> <span class="nav-text">HashMap 与 HashSet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-%E4%B8%8E-TreeMap"><span class="nav-number">2.4.3.</span> <span class="nav-text">HashMap 与 TreeMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashSet-%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E9%87%8D%E5%A4%8D"><span class="nav-number">2.4.4.</span> <span class="nav-text">HashSet 如何检查重复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.4.5.</span> <span class="nav-text">HashMap 的底层实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK1-8-%E4%B9%8B%E5%89%8D"><span class="nav-number">2.4.5.1.</span> <span class="nav-text">JDK1.8 之前</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK1-8-%E4%B9%8B%E5%90%8E"><span class="nav-number">2.4.5.2.</span> <span class="nav-text">JDK1.8 之后</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hashtable-%E4%B8%8E-ConcurrentHashMap"><span class="nav-number">2.4.6.</span> <span class="nav-text">Hashtable 与 ConcurrentHashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK1-8-%E8%BE%83-JDK1-7-ConcurrentHashMap-%E7%9A%84%E5%8D%87%E7%BA%A7"><span class="nav-number">2.4.7.</span> <span class="nav-text">JDK1.8 较 JDK1.7 ConcurrentHashMap 的升级</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-8-%E8%BE%83-1-7-%E7%9A%84%E5%8D%87%E7%BA%A7"><span class="nav-number">2.4.7.1.</span> <span class="nav-text">1.8 较 1.7 的升级</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM"><span class="nav-number">3.</span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="nav-number">3.1.</span> <span class="nav-text">运行时数据区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-number">3.1.1.</span> <span class="nav-text">程序计数器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="nav-number">3.1.2.</span> <span class="nav-text">Java 虚拟机栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="nav-number">3.1.3.</span> <span class="nav-text">本地方法栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86"><span class="nav-number">3.1.4.</span> <span class="nav-text">堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-number">3.1.5.</span> <span class="nav-text">方法区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">3.1.6.</span> <span class="nav-text">运行时常量池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="nav-number">3.1.7.</span> <span class="nav-text">直接内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HotSpot-%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">3.1.8.</span> <span class="nav-text">HotSpot 中对象的创建</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">3.2.</span> <span class="nav-text">垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%AB%E5%9B%9E%E6%94%B6"><span class="nav-number">3.2.1.</span> <span class="nav-text">判断一个对象是否可被回收</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">1. 引用计数法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E6%B3%95"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">2. 可达性分析法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9B%9E%E6%94%B6"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">3. 方法区的回收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-finalize"><span class="nav-number">3.2.1.4.</span> <span class="nav-text">4. finalize()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.2.2.</span> <span class="nav-text">引用类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">强引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">软引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="nav-number">3.2.2.3.</span> <span class="nav-text">弱引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8"><span class="nav-number">3.2.2.4.</span> <span class="nav-text">虚引用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-number">3.2.3.</span> <span class="nav-text">垃圾回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">标记 - 清除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">标记 - 整理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6"><span class="nav-number">3.2.3.3.</span> <span class="nav-text">复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86"><span class="nav-number">3.2.3.4.</span> <span class="nav-text">分代收集</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">3.2.4.</span> <span class="nav-text">垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Serial-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">3.2.4.1.</span> <span class="nav-text">Serial 收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ParNew-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">3.2.4.2.</span> <span class="nav-text">ParNew 收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Parallel-Scavenge-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">3.2.4.3.</span> <span class="nav-text">Parallel Scavenge 收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Serial-Old-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">3.2.4.4.</span> <span class="nav-text">Serial Old 收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Parallel-Old-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">3.2.4.5.</span> <span class="nav-text">Parallel Old 收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CMS-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">3.2.4.6.</span> <span class="nav-text">CMS 收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#G1-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">3.2.4.7.</span> <span class="nav-text">G1 收集器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="nav-number">3.3.</span> <span class="nav-text">内存分配与回收策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Minor-GC-%E4%B8%8E-Full-GC"><span class="nav-number">3.3.1.</span> <span class="nav-text">Minor GC 与 Full GC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="nav-number">3.3.2.</span> <span class="nav-text">内存分配策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%85%88%E5%9C%A8-Eden-%E5%88%86%E9%85%8D"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">1. 对象优先在 Eden 分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%A4%A7%E5%AF%B9%E8%B1%A1%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-number">3.3.2.2.</span> <span class="nav-text">2. 大对象直接进入老年代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E9%95%BF%E6%9C%9F%E5%AD%98%E6%B4%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-number">3.3.2.3.</span> <span class="nav-text">3. 长期存活的对象进入老年代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1%E5%B9%B4%E9%BE%84%E5%88%A4%E5%AE%9A"><span class="nav-number">3.3.2.4.</span> <span class="nav-text">4. 动态对象年龄判定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D"><span class="nav-number">3.3.2.5.</span> <span class="nav-text">5. 空间分配担保</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Full-GC-%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="nav-number">3.3.3.</span> <span class="nav-text">Full GC 的触发条件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E8%B0%83%E7%94%A8-System-gc"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">1. 调用 System.gc()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%80%81%E5%B9%B4%E4%BB%A3%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3"><span class="nav-number">3.3.3.2.</span> <span class="nav-text">2. 老年代空间不足</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D%E5%A4%B1%E8%B4%A5"><span class="nav-number">3.3.3.3.</span> <span class="nav-text">3. 空间分配担保失败</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-JDK-1-7-%E5%8F%8A%E4%BB%A5%E5%89%8D%E7%9A%84%E6%B0%B8%E4%B9%85%E4%BB%A3%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3"><span class="nav-number">3.3.3.4.</span> <span class="nav-text">4. JDK 1.7 及以前的永久代空间不足</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-Concurrent-Mode-Failure"><span class="nav-number">3.3.3.5.</span> <span class="nav-text">5. Concurrent Mode Failure</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-number">3.4.</span> <span class="nav-text">类加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">3.4.1.</span> <span class="nav-text">类的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-number">3.4.2.</span> <span class="nav-text">类加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%8A%A0%E8%BD%BD"><span class="nav-number">3.4.2.1.</span> <span class="nav-text">1. 加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E9%AA%8C%E8%AF%81"><span class="nav-number">3.4.2.2.</span> <span class="nav-text">2. 验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%87%86%E5%A4%87"><span class="nav-number">3.4.2.3.</span> <span class="nav-text">3. 准备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E8%A7%A3%E6%9E%90"><span class="nav-number">3.4.2.4.</span> <span class="nav-text">4. 解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">3.4.2.5.</span> <span class="nav-text">5. 初始化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%9C%BA"><span class="nav-number">3.4.3.</span> <span class="nav-text">类初始化时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%B8%BB%E5%8A%A8%E5%BC%95%E7%94%A8"><span class="nav-number">3.4.3.1.</span> <span class="nav-text">1. 主动引用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">3.4.4.</span> <span class="nav-text">类与类加载器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">3.4.5.</span> <span class="nav-text">类加载器的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.4.6.</span> <span class="nav-text">双亲委派模型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E5%B9%B6%E5%8F%91"><span class="nav-number">4.</span> <span class="nav-text">Java 并发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-number">4.1.</span> <span class="nav-text">基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="nav-number">4.1.1.</span> <span class="nav-text">什么是线程和进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">4.1.1.2.</span> <span class="nav-text">线程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">4.1.2.</span> <span class="nav-text">进程和线程的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B"><span class="nav-number">4.1.3.</span> <span class="nav-text">如何使用线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="nav-number">4.1.4.</span> <span class="nav-text">并发与并行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="nav-number">4.1.5.</span> <span class="nav-text">同步和异步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81"><span class="nav-number">4.1.6.</span> <span class="nav-text">线程的生命周期和状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="nav-number">4.1.7.</span> <span class="nav-text">什么是上下文切换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81"><span class="nav-number">4.1.8.</span> <span class="nav-text">什么是死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2%E5%92%8C%E9%81%BF%E5%85%8D%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81"><span class="nav-number">4.1.9.</span> <span class="nav-text">如何预防和避免线程死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep-%E4%B8%8E-wait"><span class="nav-number">4.1.10.</span> <span class="nav-text">sleep() 与 wait()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-wait-%E6%96%B9%E6%B3%95%E4%B8%8D%E5%AE%9A%E4%B9%89%E5%9C%A8-Thread-%E4%B8%AD"><span class="nav-number">4.1.11.</span> <span class="nav-text">为什么 wait() 方法不定义在 Thread 中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8-Thread-%E7%B1%BB%E7%9A%84-run-%E6%96%B9%E6%B3%95%E5%90%97"><span class="nav-number">4.1.12.</span> <span class="nav-text">可以直接调用 Thread 类的 run 方法吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#happens-before-%E8%A7%84%E5%88%99"><span class="nav-number">4.1.13.</span> <span class="nav-text">happens-before 规则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">4.2.</span> <span class="nav-text">volatile 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">4.2.1.</span> <span class="nav-text">并发编程的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile-%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">4.2.2.</span> <span class="nav-text">volatile 的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">4.2.3.</span> <span class="nav-text">如何保证变量的可见性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="nav-number">4.2.4.</span> <span class="nav-text">如何禁止指令重排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile-%E5%8F%AF%E4%BB%A5%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%90%97"><span class="nav-number">4.2.5.</span> <span class="nav-text">volatile 可以保证原子性吗</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">4.3.</span> <span class="nav-text">synchronized 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="nav-number">4.3.1.</span> <span class="nav-text">对 synchronized 关键字的了解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">4.3.2.</span> <span class="nav-text">如何使用 synchronized 关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM-%E5%AF%B9-synchronized-%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">4.3.3.</span> <span class="nav-text">JVM 对 synchronized 的优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">4.3.3.1.</span> <span class="nav-text">自旋锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E6%B6%88%E9%99%A4"><span class="nav-number">4.3.3.2.</span> <span class="nav-text">锁消除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E7%B2%97%E5%8C%96"><span class="nav-number">4.3.3.3.</span> <span class="nav-text">锁粗化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="nav-number">4.3.3.4.</span> <span class="nav-text">轻量级锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="nav-number">4.3.3.5.</span> <span class="nav-text">偏向锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-%E4%B8%8E-volatile"><span class="nav-number">4.3.4.</span> <span class="nav-text">synchronized 与 volatile</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">4.4.</span> <span class="nav-text">ThreadLocal</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">4.4.1.</span> <span class="nav-text">ThreadLocal 的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-ThreadLocal"><span class="nav-number">4.4.2.</span> <span class="nav-text">如何使用 ThreadLocal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal-%E5%8E%9F%E7%90%86"><span class="nav-number">4.4.3.</span> <span class="nav-text">ThreadLocal 原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98"><span class="nav-number">4.4.4.</span> <span class="nav-text">ThreadLocal 内存泄漏问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">4.5.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">4.5.1.</span> <span class="nav-text">线程池的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-Runnable-%E4%B8%8E-Callable-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.5.2.</span> <span class="nav-text">实现 Runnable 与 Callable 接口的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C-execute-%E4%B8%8E-submit-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.5.3.</span> <span class="nav-text">执行 execute() 与 submit() 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">4.5.4.</span> <span class="nav-text">如何创建线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%88%9B%E5%BB%BA%E3%80%82"><span class="nav-number">4.5.4.1.</span> <span class="nav-text">通过构造方法创建。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-Executor-%E6%A1%86%E6%9E%B6%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB-Executors-%E6%9D%A5%E5%88%9B%E5%BB%BA%E3%80%82"><span class="nav-number">4.5.4.2.</span> <span class="nav-text">通过 Executor 框架的工具类 Executors 来创建。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">4.5.5.</span> <span class="nav-text">如何停止线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-number">4.5.6.</span> <span class="nav-text">如何确定线程池的大小</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="nav-number">4.6.</span> <span class="nav-text">原子类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="nav-number">4.6.1.</span> <span class="nav-text">什么是原子类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.6.2.</span> <span class="nav-text">原子类类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">4.6.3.</span> <span class="nav-text">原子类的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAS"><span class="nav-number">4.7.</span> <span class="nav-text">CAS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-CAS"><span class="nav-number">4.7.1.</span> <span class="nav-text">什么是 CAS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS-%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">4.7.2.</span> <span class="nav-text">CAS 存在的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ABA-%E9%97%AE%E9%A2%98"><span class="nav-number">4.7.2.1.</span> <span class="nav-text">ABA 问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E6%97%B6%E9%97%B4%E9%95%BF%E5%BC%80%E9%94%80%E5%A4%A7"><span class="nav-number">4.7.2.2.</span> <span class="nav-text">循环时间长开销大</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AA%E8%83%BD%E4%BF%9D%E8%AF%81%E4%B8%80%E4%B8%AA%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">4.7.3.</span> <span class="nav-text">只能保证一个共享变量的原子操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="nav-number">4.8.</span> <span class="nav-text">并发容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS"><span class="nav-number">4.9.</span> <span class="nav-text">AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS-%E7%BB%84%E4%BB%B6"><span class="nav-number">4.9.1.</span> <span class="nav-text">AQS 组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-AQS"><span class="nav-number">4.9.2.</span> <span class="nav-text">什么是 AQS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86"><span class="nav-number">4.9.3.</span> <span class="nav-text">AQS 内部原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#state-%E7%8A%B6%E6%80%81"><span class="nav-number">4.9.3.1.</span> <span class="nav-text">state 状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FIFO-%E9%98%9F%E5%88%97"><span class="nav-number">4.9.3.2.</span> <span class="nav-text">FIFO 队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96-x2F-%E9%87%8A%E6%94%BE%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">4.9.3.3.</span> <span class="nav-text">获取&#x2F;释放的方法</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL"><span class="nav-number">5.</span> <span class="nav-text">MySQL</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-number">5.1.</span> <span class="nav-text">MySQL 基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">5.1.1.</span> <span class="nav-text">什么是关系型数据库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">5.2.</span> <span class="nav-text">MySQL 存储引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MyISAM-%E4%B8%8E-InnoDB-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.2.1.</span> <span class="nav-text">MyISAM 与 InnoDB 的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-%E4%BA%8B%E5%8A%A1"><span class="nav-number">5.3.</span> <span class="nav-text">MySQL 事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1"><span class="nav-number">5.3.1.</span> <span class="nav-text">什么是事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">5.3.2.</span> <span class="nav-text">并发事务带来的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.3.3.</span> <span class="nav-text">不可重复读和幻读的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">5.3.4.</span> <span class="nav-text">事务的隔离级别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-%E9%94%81"><span class="nav-number">5.4.</span> <span class="nav-text">MySQL 锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81%E5%92%8C%E8%A1%8C%E7%BA%A7%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.4.1.</span> <span class="nav-text">表级锁和行级锁的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E6%8E%92%E4%BB%96%E9%94%81"><span class="nav-number">5.4.2.</span> <span class="nav-text">共享锁和排他锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB-%E7%9A%84%E8%A1%8C%E9%94%81"><span class="nav-number">5.4.3.</span> <span class="nav-text">InnoDB 的行锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-%E7%B4%A2%E5%BC%95"><span class="nav-number">5.5.</span> <span class="nav-text">MySQL 索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95"><span class="nav-number">5.5.1.</span> <span class="nav-text">什么是索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%AE%97%E6%B3%95"><span class="nav-number">5.5.2.</span> <span class="nav-text">索引算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB-%E7%B4%A2%E5%BC%95%E5%8D%B3%E6%95%B0%E6%8D%AE"><span class="nav-number">5.5.3.</span> <span class="nav-text">InnoDB 索引即数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E6%A0%91%E7%B4%A2%E5%BC%95"><span class="nav-number">5.5.3.1.</span> <span class="nav-text">B+ 树索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="nav-number">5.5.3.2.</span> <span class="nav-text">聚簇索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95"><span class="nav-number">5.5.3.3.</span> <span class="nav-text">辅助索引</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E2%80%9C%E5%B7%A6%E4%BE%A7%E7%94%A8%E6%B3%95%E2%80%9D"><span class="nav-number">5.5.4.</span> <span class="nav-text">索引的“左侧用法”</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="nav-number">5.5.4.1.</span> <span class="nav-text">联合索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="nav-number">5.5.4.2.</span> <span class="nav-text">字符串的前缀索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-Like"><span class="nav-number">5.5.4.3.</span> <span class="nav-text">字符串 Like</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="nav-number">5.5.5.</span> <span class="nav-text">索引失效</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-%E6%97%A5%E5%BF%97"><span class="nav-number">5.6.</span> <span class="nav-text">MySQL 日志</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E4%BD%93%E7%B3%BB"><span class="nav-number">5.6.1.</span> <span class="nav-text">日志体系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binlog-%E5%BD%92%E6%A1%A3%E6%97%A5%E5%BF%97"><span class="nav-number">5.6.2.</span> <span class="nav-text">binlog 归档日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undo-log-%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97"><span class="nav-number">5.6.3.</span> <span class="nav-text">undo log 回滚日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redo-log-%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97"><span class="nav-number">5.6.4.</span> <span class="nav-text">redo log 重做日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redo-log-%E4%B8%8E-binlog-%E5%8C%BA%E5%88%AB"><span class="nav-number">5.6.5.</span> <span class="nav-text">redo log 与 binlog 区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B"><span class="nav-number">5.6.6.</span> <span class="nav-text">数据更新流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="nav-number">5.7.</span> <span class="nav-text">多版本并发控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E7%85%A7%E8%AF%BB%EF%BC%88%E4%B8%80%E8%87%B4%E6%80%A7%E9%9D%9E%E9%94%81%E5%AE%9A%E8%AF%BB%EF%BC%89"><span class="nav-number">5.7.1.</span> <span class="nav-text">快照读（一致性非锁定读）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%93%E5%89%8D%E8%AF%BB%EF%BC%88%E4%B8%80%E8%87%B4%E6%80%A7%E9%94%81%E5%AE%9A%E8%AF%BB%EF%BC%89"><span class="nav-number">5.7.2.</span> <span class="nav-text">当前读（一致性锁定读）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%93%E5%89%8D%E8%AF%BB%E4%B8%8E%E5%BF%AB%E7%85%A7%E8%AF%BB%E8%AF%BB%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">5.7.3.</span> <span class="nav-text">当前读与快照读读区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98"><span class="nav-number">5.7.4.</span> <span class="nav-text">如何解决幻读问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis"><span class="nav-number">6.</span> <span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E5%9F%BA%E7%A1%80"><span class="nav-number">6.1.</span> <span class="nav-text">Redis 基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Redis"><span class="nav-number">6.1.1.</span> <span class="nav-text">什么是 Redis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB"><span class="nav-number">6.1.2.</span> <span class="nav-text">Redis 为什么这么快</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-Redis-x2F-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="nav-number">6.1.3.</span> <span class="nav-text">为什么要用 Redis&#x2F;为什么要用缓存？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E9%99%A4%E4%BA%86%E5%81%9A%E7%BC%93%E5%AD%98%E8%BF%98%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88"><span class="nav-number">6.1.4.</span> <span class="nav-text">Redis 除了做缓存还能做什么</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">6.2.</span> <span class="nav-text">Redis 数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">6.2.1.</span> <span class="nav-text">Redis 常用的数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-%E4%B8%8E-Hash"><span class="nav-number">6.2.2.</span> <span class="nav-text">String 与 Hash</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">6.2.3.</span> <span class="nav-text">String 的应用场景有哪些？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.3.</span> <span class="nav-text">Redis 线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.3.1.</span> <span class="nav-text">Redis 单线程模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">6.3.2.</span> <span class="nav-text">Redis 为什么不使用多线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis6-0-%E4%B9%8B%E5%90%8E%E4%B8%BA%E4%BD%95%E5%BC%95%E5%85%A5%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">6.3.3.</span> <span class="nav-text">Redis6.0 之后为何引入了多线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="nav-number">6.4.</span> <span class="nav-text">Redis 持久化机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">6.4.1.</span> <span class="nav-text">RDB 持久化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB-%E5%88%9B%E5%BB%BA%E5%BF%AB%E7%85%A7%E6%97%B6%E4%BC%9A%E9%98%BB%E5%A1%9E%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%90%97"><span class="nav-number">6.4.2.</span> <span class="nav-text">RDB 创建快照时会阻塞主线程吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">6.4.3.</span> <span class="nav-text">AOF 持久化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">6.5.</span> <span class="nav-text">Redis 性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-bigkey"><span class="nav-number">6.5.1.</span> <span class="nav-text">Redis bigkey</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-bigkey"><span class="nav-number">6.5.1.1.</span> <span class="nav-text">什么是 bigkey</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%8F%91%E7%8E%B0-bigkey"><span class="nav-number">6.5.1.2.</span> <span class="nav-text">如何发现 bigkey</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E9%87%8F-key-%E9%9B%86%E4%B8%AD%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98"><span class="nav-number">6.5.2.</span> <span class="nav-text">大量 key 集中过期问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98"><span class="nav-number">6.6.</span> <span class="nav-text">Redis 生产问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-number">6.6.1.</span> <span class="nav-text">缓存穿透</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">6.6.1.1.</span> <span class="nav-text">问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">6.6.1.2.</span> <span class="nav-text">解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BA%E6%95%B0%E6%8D%AE%E4%B8%8E%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">6.6.1.3.</span> <span class="nav-text">缓存空数据与布隆过滤器的比较</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="nav-number">6.6.2.</span> <span class="nav-text">缓存击穿</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98-1"><span class="nav-number">6.6.2.1.</span> <span class="nav-text">问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1"><span class="nav-number">6.6.2.2.</span> <span class="nav-text">解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98-2"><span class="nav-number">6.6.2.3.</span> <span class="nav-text">问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-2"><span class="nav-number">6.6.2.4.</span> <span class="nav-text">解决方案</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring"><span class="nav-number">7.</span> <span class="nav-text">Spring</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-IoC"><span class="nav-number">7.1.</span> <span class="nav-text">Spring IoC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Spring-IoC"><span class="nav-number">7.1.1.</span> <span class="nav-text">什么是 Spring IoC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Spring-Bean"><span class="nav-number">7.1.2.</span> <span class="nav-text">什么是 Spring Bean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Autowired-%E5%92%8C-Resource-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.1.3.</span> <span class="nav-text">@Autowired 和 @Resource 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bean-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">7.1.4.</span> <span class="nav-text">Bean 的作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">7.1.5.</span> <span class="nav-text">Bean 的生命周期</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-AOP"><span class="nav-number">7.2.</span> <span class="nav-text">Spring AOP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-AOP"><span class="nav-number">7.2.1.</span> <span class="nav-text">什么是 AOP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-AOP-%E4%BA%8E%E5%92%8C-AspectJ-AOP-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.2.2.</span> <span class="nav-text">Spring AOP 于和 AspectJ AOP 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AspectJ-%E5%AE%9A%E4%B9%89%E7%9A%84%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.2.3.</span> <span class="nav-text">AspectJ 定义的通知类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E5%A4%9A%E4%B8%AA%E5%88%87%E9%9D%A2%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">7.2.4.</span> <span class="nav-text">如何控制多个切面的执行顺序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-MVC"><span class="nav-number">7.3.</span> <span class="nav-text">Spring MVC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Spring-MVC"><span class="nav-number">7.3.1.</span> <span class="nav-text">什么是 Spring MVC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-MVC-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="nav-number">7.3.2.</span> <span class="nav-text">Spring MVC 的核心组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringMVC-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">7.3.3.</span> <span class="nav-text">SpringMVC 工作原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">8.</span> <span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">8.1.</span> <span class="nav-text">排序算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-Bubble-Sort"><span class="nav-number">8.2.</span> <span class="nav-text">冒泡排序 (Bubble Sort)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4"><span class="nav-number">8.2.1.</span> <span class="nav-text">算法步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95"><span class="nav-number">8.2.2.</span> <span class="nav-text">图解算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.2.3.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-number">8.2.4.</span> <span class="nav-text">算法分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-Selection-Sort"><span class="nav-number">8.3.</span> <span class="nav-text">选择排序 (Selection Sort)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4-1"><span class="nav-number">8.3.1.</span> <span class="nav-text">算法步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95-1"><span class="nav-number">8.3.2.</span> <span class="nav-text">图解算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">8.3.3.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-1"><span class="nav-number">8.3.4.</span> <span class="nav-text">算法分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-Insertion-Sort"><span class="nav-number">8.4.</span> <span class="nav-text">插入排序 (Insertion Sort)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4-2"><span class="nav-number">8.4.1.</span> <span class="nav-text">算法步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95-2"><span class="nav-number">8.4.2.</span> <span class="nav-text">图解算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-2"><span class="nav-number">8.4.3.</span> <span class="nav-text">算法分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-Quick-Sort"><span class="nav-number">8.5.</span> <span class="nav-text">快速排序 (Quick Sort)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4-3"><span class="nav-number">8.5.1.</span> <span class="nav-text">算法步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95-3"><span class="nav-number">8.5.2.</span> <span class="nav-text">图解算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="nav-number">8.5.3.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-3"><span class="nav-number">8.5.4.</span> <span class="nav-text">算法分析</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ssssv11"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">Ssssv11</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTE=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Ssssv11"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ssssv11.github.io/2022/09/15/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="Ssssv11">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ssssv">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试八股文
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-09-15 10:22:42" itemprop="dateCreated datePublished" datetime="2022-09-15T10:22:42+08:00">2022-09-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-09-28 22:01:02" itemprop="dateModified" datetime="2022-09-28T22:01:02+08:00">2022-09-28</time>
      </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <center>面试八股文</center>

<span id="more"></span>

<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="基础概念与常识"><a href="#基础概念与常识" class="headerlink" title="基础概念与常识"></a>基础概念与常识</h2><h3 id="Java-语言的特点"><a href="#Java-语言的特点" class="headerlink" title="Java 语言的特点"></a>Java 语言的特点</h3><ol>
<li>简单易学、有丰富的类库。</li>
<li>面向对象（Java 最重要的特性，让程序低耦合高内聚，继承、封装、多态）</li>
<li>平台独立。不受操作平台的限制，可以应用在各个平台上（JVM）</li>
<li>安全可靠。提供了许多安全机制来保证其使用安全性（字节码解释器和类格式检验、运行时动态装载和检查库的机制、垃圾回收机制）</li>
<li>支持多线程。</li>
<li>支持网络编程并且很方便。</li>
<li>编译与解释并存。</li>
</ol>
</br>

<h3 id="什么是字节码、采用字节码的好处是什么"><a href="#什么是字节码、采用字节码的好处是什么" class="headerlink" title="什么是字节码、采用字节码的好处是什么"></a>什么是字节码、采用字节码的好处是什么</h3><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
<p>Java 程序从源代码到运行的过程如下图所示：</p>
<p><img data-src="https://s2.loli.net/2022/09/20/CceHsnEJp8hZMB5.png" alt="img"></p>
<p>需要格外注意的是 <code>.class-&gt;机器码</code> 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。</p>
</br>

<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="Java-中的八种基本数据类型"><a href="#Java-中的八种基本数据类型" class="headerlink" title="Java 中的八种基本数据类型"></a>Java 中的八种基本数据类型</h3><table>
<thead>
<tr>
<th align="left">基本类型</th>
<th align="left">位数</th>
<th align="left">字节</th>
<th align="left">默认值</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>byte</code></td>
<td align="left">8</td>
<td align="left">1</td>
<td align="left">0</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td align="left"><code>short</code></td>
<td align="left">16</td>
<td align="left">2</td>
<td align="left">0</td>
<td>-32768 ~ 32767</td>
</tr>
<tr>
<td align="left"><code>int</code></td>
<td align="left">32</td>
<td align="left">4</td>
<td align="left">0</td>
<td>-2147483648 ~ 2147483647</td>
</tr>
<tr>
<td align="left"><code>long</code></td>
<td align="left">64</td>
<td align="left">8</td>
<td align="left">0L</td>
<td>-9223372036854775808 ~ 9223372036854775807</td>
</tr>
<tr>
<td align="left"><code>char</code></td>
<td align="left">16</td>
<td align="left">2</td>
<td align="left">‘u0000’</td>
<td>0 ~ 65535</td>
</tr>
<tr>
<td align="left"><code>float</code></td>
<td align="left">32</td>
<td align="left">4</td>
<td align="left">0f</td>
<td>1.4E-45 ~ 3.4028235E38</td>
</tr>
<tr>
<td align="left"><code>double</code></td>
<td align="left">64</td>
<td align="left">8</td>
<td align="left">0d</td>
<td>4.9E-324 ~ 1.7976931348623157E308</td>
</tr>
<tr>
<td align="left"><code>boolean</code></td>
<td align="left">1</td>
<td align="left"></td>
<td align="left">false</td>
<td>true、false</td>
</tr>
</tbody></table>
<p><strong>注意</strong>：</p>
<ul>
<li><code>int</code> 是基本类型，<code>Integer</code> 是 <code>int</code> 的封装类，是引用类型。<code>int</code> 的默认值是 <code>0</code>，而 <code>Integer</code> 的默认值为 <code>null</code>，所以 <code>Integer</code> 可以区分 <code>0</code> 和 <code>null</code> 的情况。一旦 Java 看到 <code>null</code>，就知道这个引用还没有指向某个对象，在使用引用前必须为其指定一个对象，否则会报错。</li>
<li>基本数据类型在声明时系统会自动为它分配空间，而引用类型声明时只分配了引用空间，必须通过实例化开辟数据空间之后才可以赋值。数组对象也是一个引用对象，将一个数组赋值给另一个数组只是复制了一个引用，所以通过某一个数组所做的修改在另一个数组中也能看得见。</li>
<li>虽然定义了 <code>boolean</code> 这种数据类型，但是只对它提供了非常有限的支持。在 Java 虚拟机中没有任何供 <code>boolean</code> 值专用的字节码指令，Java 语言表达式所操作的 <code>boolean</code> 值在编译之后都使用 Java 虚拟机中的 <code>int</code> 数据类型来代替，而 <code>boolean</code> 数组将会被编码成 Java 虚拟机的 <code>byte</code> 数组，每个 boolean 元素占 <code>8</code> 位。<code>boolean</code> 类型的数据如果单独使用，占 <code>4</code> 个字节的空间，而如果存储到 <code>boolean</code> 数组中，每个元素又只占 <code>1</code> 个字节。使用 <code>int</code> 是因为对于当下 <code>32</code> 位的处理器来说，一次处理数据是 <code>32</code> 位具有高效存取的特点。</li>
</ul>
</br>

<h3 id="自动装箱与拆箱及缓存机制"><a href="#自动装箱与拆箱及缓存机制" class="headerlink" title="自动装箱与拆箱及缓存机制"></a>自动装箱与拆箱及缓存机制</h3><p><strong>装箱就是自动将基本数据类型转换为包装器类型，调用 <code>Integer.valueOf()</code> 方法；拆箱就是自动将包装器类型转换为基本数据类型，调用 <code>Integer.intValue()</code> 方法。</strong></p>
<p>在 Java Se5 之前，如果要生成一个数值为 10 的 <code>Integer</code> 对象，必须这样进行:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>从 Java Se5 之后就开始提供自动装箱的特性，只需要：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>装箱其实就是调用了包装类的 <code>valueOf()</code> 方法，拆箱其实就是调用了 <code>xxxValue()</code> 方法。</p>
<p>因此：</p>
<ul>
<li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li>
<li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>;</li>
</ul>
<p>注意：<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p>
<hr>
<p>面试题1：以下代码会输出什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    </span><br><span class="line">    System.out.println(i1 == i2);</span><br><span class="line">    System.out.println(i3 == i4);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line">fasle</span><br></pre></td></tr></table></figure>

<p>输出结果表明 <code>i1</code> 和 <code>i2</code> 指向的是同一个对象，而 <code>i3</code> 和 <code>i4</code> 指向的是不同的对象。此时只需一看源码便知究竟，下面这段代码是 <code>Integer</code> 的 <code>valueOf()</code> 方法的具体实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(i &gt;= -<span class="number">128</span> &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">    <span class="keyword">return</span> IntegerCache.cache[i + <span class="number">128</span>];</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>IntegerCache</code> 类的实现为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="comment">// high value may be configured by property</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">      <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span></span><br><span class="line">        sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (integerCacheHighPropValue != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parseInt(integerCacheHighPropValue);</span><br><span class="line">          i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">          <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">          h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">          <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      high = h;</span><br><span class="line"></span><br><span class="line">      cache = <span class="keyword">new</span> <span class="title class_">Integer</span>[(high - low) + <span class="number">1</span>];</span><br><span class="line">      <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">        cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">      <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">IntegerCache</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这两段代码可以看出，在通过 <code>valueOf()</code> 方法创建 <code>Integer</code> 对象时，如果数值在 [-128, 127] 之间，便返回指向 <code>IntegerCache.cache</code> 中已经存在的对象的引用；否则创建一个新的 <code>Integer</code> 对象。<strong>（包装类的缓存机制）</strong></p>
<p>上面的代码中 <code>i1</code> 和 <code>i2</code> 的数值为 <code>100</code>，因此会直接从 cache 中取已经存在的对象，所以 <code>i1</code> 和 <code>i2</code> 指向的是同一个对象，而 <code>i3</code> 和 <code>i4</code> 则是分别指向不同的对象。</p>
<hr>
<p>面试题2：以下代码会输出什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Double</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">100.0</span>;</span><br><span class="line">        <span class="type">Double</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">100.0</span>;</span><br><span class="line">        <span class="type">Double</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">200.0</span>;</span><br><span class="line">        <span class="type">Double</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">200.0</span>;</span><br><span class="line">      </span><br><span class="line">        System.out.println(i1 == i2);</span><br><span class="line">      	System.out.println(i1.equals(i2);</span><br><span class="line">        System.out.println(i3 == i4);</span><br><span class="line">        System.out.println(i3.equals(i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>这是因为 <code>Double</code> 的 <code>valueOf()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title function_">valueOf</span><span class="params">(<span class="type">double</span> d)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Double</span>(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次调用 <code>valueOf()</code> 都创建了一个新的对象，以此 <code>i1</code> 和 <code>i2</code> 、<code>i3</code> 和 <code>i4</code> 没有指向相同对象。</p>
<p>对于 <code>Integer</code> 在 (-128,128] 之间只有固定的 256 个值，所以为了避免多次创建对象，可以事先就创建好一个大小为 256 的 <code>Integer</code> 数组 <code>SMALL_VALUES</code>，所以如果值在这个范围内可以直接返回事先创建好的对象。但对于 <code>Double</code> 类型就不能这样做，因为它在这个范围内个数是无限的。</p>
<p><strong>总结</strong>：</p>
<ul>
<li>在某个范围内的整型数值的个数是有限的，而浮点数却不是。</li>
<li><code>Integer</code> 派别：<code>Integer</code>、<code>Short</code>、<code>Byte</code>、<code>Character</code>、<code>Long</code> 这几个类的 <code>valueOf()</code> 方法的实现是类似的。</li>
<li><code>Double</code> 派别：<code>Double</code>、<code>Float</code> 的 <code>valueOf()</code> 方法的实现是类似的。每次都返回不同的对象。</li>
</ul>
</br>

<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>由于字面量 1 是 <code>int</code> 类型，它比 <code>short</code> 类型精度更高，因此不能隐式地将 <code>int</code> 类型向下转型为 <code>short</code> 类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">s1 = s1 + <span class="number">1</span>;	<span class="comment">// Require type: short, provided: int</span></span><br></pre></td></tr></table></figure>

<p>但使用 <code>+=</code> 或 <code>++</code> 运算符会执行隐式类型转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 += <span class="number">1</span>;</span><br><span class="line">s1++;</span><br></pre></td></tr></table></figure>

<p>上面的语句相当于将 <code>s1 + 1</code> 的计算结果进行了向下转型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 = (<span class="type">short</span>)(s1 + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

</br>

<h3 id="float-与-double"><a href="#float-与-double" class="headerlink" title="float 与 double"></a>float 与 double</h3><p>Java 不能隐式向下转型，因为这会使得精度降低。</p>
<p>1.1 字面量属于 <code>double</code> 类型，不能直接将 1.1 赋值给 <code>float</code> 变量，因为这是向下转型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">1.1</span>;		<span class="comment">// Require type: float, provided: double</span></span><br></pre></td></tr></table></figure>

<p>1.1f 字面量才是 <code>float</code> 类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">1.1f</span>;</span><br></pre></td></tr></table></figure>

</br>

<h3 id="为什么浮点数运算的时候会有精度丢失的风险"><a href="#为什么浮点数运算的时候会有精度丢失的风险" class="headerlink" title="为什么浮点数运算的时候会有精度丢失的风险"></a>为什么浮点数运算的时候会有精度丢失的风险</h3><p>浮点数运算精度丢失代码演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2.0f</span> - <span class="number">1.9f</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1.8f</span> - <span class="number">1.7f</span>;</span><br><span class="line">System.out.println(a);		<span class="comment">// 0.100000024</span></span><br><span class="line">System.out.println(b);		<span class="comment">// 0.099999905</span></span><br><span class="line">System.out.println(a == b);	<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>这个和计算机保存浮点数的机制有很大关系。由于计算机是二进制的，而且计算机在表示一个数字时宽度是有限的，无限循环的小数存储在计算机中只能被截断，所以就会导致小数精度发生损失的情况。这就是为什么浮点数没有办法用二进制精确表示。</p>
<p>如十进制下的 0.2 就无法精确转换成二进制小数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，</span></span><br><span class="line"><span class="comment">// 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">0.4</span> * <span class="number">2</span> = <span class="number">0.8</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">0.8</span> * <span class="number">2</span> = <span class="number">1.6</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">0.6</span> * <span class="number">2</span> = <span class="number">1.2</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> -&gt; <span class="number">0</span>（发生循环）</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

</br>

<h3 id="如何解决浮点数运算的精度丢失问题"><a href="#如何解决浮点数运算的精度丢失问题" class="headerlink" title="如何解决浮点数运算的精度丢失问题"></a>如何解决浮点数运算的精度丢失问题</h3><p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到金钱的场景）都是通过 <code>BigDecimal</code> 实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.subtract(b);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> b.subtract(c);</span><br><span class="line"></span><br><span class="line">System.out.println(x); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(y); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(Objects.equals(x, y)); <span class="comment">/* true */</span></span><br></pre></td></tr></table></figure>

</br>

<h3 id="超过-long-整型的数据应该如何表示"><a href="#超过-long-整型的数据应该如何表示" class="headerlink" title="超过 long 整型的数据应该如何表示"></a>超过 long 整型的数据应该如何表示</h3><p>基本数值类型都有一个表达范围，如果超过这个范围就会有数值溢出的风险。</p>
<p>在 Java 中，64 位 long 整型是最大的整数类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">System.out.println(l + <span class="number">1</span>); <span class="comment">// -9223372036854775808</span></span><br><span class="line">System.out.println(l + <span class="number">1</span> == Long.MIN_VALUE); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>BigInteger</code> 内部使用 <code>int[]</code> 数组来存储任意大小的整形数据。</p>
<p>相对于常规整数类型的运算来说，<code>BigInteger</code> 运算的效率会相对较低。</p>
</br>

<h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><h3 id="面向对象与面向过程的区别"><a href="#面向对象与面向过程的区别" class="headerlink" title="面向对象与面向过程的区别"></a>面向对象与面向过程的区别</h3><p>他们都是一种软件的开发方法，一种编程范式。</p>
<ul>
<li><strong>面向过程</strong>是先分析解决问题的步骤，然后用函数将步骤一步步实现，在使用时一一调用函数即可。这样性能较高，因此单片机、嵌入式开发一般采用面向过程开发。</li>
<li><strong>面向对象</strong>是把构成问题的事物分解成对象来描述某个事物在解决整个问题的过程中所发生的行为。面向对象有 <strong>继承、封装、多态</strong> 的特性，因此易维护、易复用、易扩展。但在性能上不如面向过程。</li>
</ul>
</br>

<h3 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装是指把一个对象的状态信息（属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但可以提供一些可被外界访问的方法来操作属性。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>不同类型的对象相互之间经常有一定数量的共同点，同时每一个对象还定义了额外的特性使得它们又彼此与众不同。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类、提高代码的重用、程序的可维护性，节省大量创建新类的时间，提高开发效率。</p>
<p><strong>总结：</strong></p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但父类中的私有属性和私有方法子类无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。</li>
</ol>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p>
<p><strong>多态的特点:</strong></p>
<ul>
<li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系。</li>
<li>引用类型变量发出的方法调用的是哪个类中的方法必须在程序运行期间才能确定。</li>
<li>多态不能调用“只在子类存在但在父类不存在”的方法。</li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ul>
</br>

<h3 id="接口和抽象类的异同"><a href="#接口和抽象类的异同" class="headerlink" title="接口和抽象类的异同"></a>接口和抽象类的异同</h3><p>共同点：</p>
<ul>
<li>它们都不能被实例化。</li>
<li>它们都可以包含抽象方法。</li>
<li>它们都可以有默认实现的方法（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）。</li>
</ul>
<p>不同点：</p>
<ul>
<li>接口主要用于对类的行为进行约束，而抽象类主要用于代码复用，强调的是所属关系。</li>
<li>一个类只能继承一个类，但是可以实现多个接口。</li>
<li>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 <code>default</code>，可在子类中被重新定义，也可被重新赋值。</li>
</ul>
</br>

<h3 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h3><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>重写就是在子类中把父类本身的方法重新写了一遍。子类继承了父类原有的方法，但某些情况下子类并不想原封不动的继承父类的某个方法，所以在方法名、参数列表、返回值类型都相同的情况下对方法体进行修改或重写就被称为<strong>重写</strong>。注意子类方法的访问修饰权限不能小于父类的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">    son.sayHello();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello from son&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li>重写发生在父类与子类之间。</li>
<li>重写的方法名、参数列表、返回类型(除子类中方法的返回类型是父类中返回类型的子类)必须相同。</li>
<li>访问修饰符的限制要大于等于被重写方法的访问修饰符。</li>
<li>重写方法一定不能抛出新的检查异常或比被重写方法申明更加宽泛的检查型异常。</li>
</ul>
<h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>在一个类中，同名的方法如果有不同的参数列表(参数类型不同、参数个数不同或是参数顺序不同)则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但不能通过返回类型是否相同来判断重载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line">    father.sayHello();</span><br><span class="line">    father.sayHello(<span class="string">&quot;Overload&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello&quot;</span> + <span class="string">&quot; &quot;</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li>重载 Overload 是一个类中多态性的一种表现。</li>
<li>重载要求同名方法的参数列表不同(参数类型，参数个数或是参数顺序) 。</li>
<li>重载时返回值类型可以相同也可以不相同。无法以返回值类型型作为重载方法的区分标准。</li>
</ul>
</br>

<h3 id="Java-创建对象的方式"><a href="#Java-创建对象的方式" class="headerlink" title="Java 创建对象的方式"></a>Java 创建对象的方式</h3><p>Java 中提供了以下四种创建对象的方式：</p>
<ul>
<li>通过 <code>new</code> 关键字创建对象</li>
<li>通过反射机制创建对象</li>
<li>通过 clone 机制创建对象</li>
<li>通过序列化机制创建对象</li>
</ul>
</br>

<h3 id="深拷贝和浅拷贝的区别"><a href="#深拷贝和浅拷贝的区别" class="headerlink" title="深拷贝和浅拷贝的区别"></a>深拷贝和浅拷贝的区别</h3><ul>
<li><strong>浅拷贝：</strong>浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），但如果原对象内部的属性是引用类型，那么浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li>
<li><strong>深拷贝：</strong>深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li>
</ul>
<p>浅拷贝的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Constructor、Getter&amp;Setter </span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Address <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Address) <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Constructor、Getter&amp;Setter </span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">            <span class="keyword">return</span> person;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;成都&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">person1Copy</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure>

<p>从输出结构就可以看出 <code>person1</code> 的克隆对象 <code>person1Copy</code> 和 <code>person1</code> 使用的仍然是同一个 <code>Address</code> 对象。</p>
<p>深拷贝的示例代码，这里对 <code>Person</code> 类的 <code>clone()</code> 方法进行修改，连带着把 <code>Person</code> 对象内部的 <code>Address</code> 对象一起复制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">        person.setAddress(person.getAddress().clone());</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;成都&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">person1Copy</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure>

<p>从输出结构可以看出 <code>person1</code> 的克隆对象 <code>person1Copy</code> 和 <code>person1</code> 包含的 <code>Address</code> 对象已经是不同的了，即深拷贝完全复制了一个原对象。</p>
<p>另外，<strong>引用拷贝</strong>就是两个不同的引用指向同一个对象：</p>
<p><img data-src="https://s2.loli.net/2022/09/20/yWApstLGFBo7Jiz.png" alt="img"></p>
</br>

<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p><strong>1. 数据</strong></p>
<p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p>
<ul>
<li>对于基本类型，<code>final</code> 使数值不变</li>
<li>对于引用类型，<code>final</code> 使引用不变，也就是不能引用其他对象，但被引用的对象本身是可以修改的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">x = <span class="number">2</span>; 		<span class="comment">// cannot assign value to final variable &#x27;x&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">a.name = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>2. 方法</strong></p>
<p>声明方法不能被子类重写。</p>
<p><code>private</code> 方法隐式地被指定为 <code>final</code>，如果在子类中定义的方法和父类中的一个 <code>private</code> 方法签名相同，此时子类的方法不是重写的父类方法，而是在子类中重新定义的一个新方法。</p>
<p><strong>3. 类</strong></p>
<p>声明类不允许被继承，如 <code>String</code>。</p>
</br>

<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><strong>1. 静态变量</strong></p>
<ul>
<li>静态变量：又称为类变量，即该变量是属于类的，类的所有实例都共享静态变量，可以直接通过类名来访问。静态变量在内存中只存在一份。</li>
<li>实例变量：每创建一个实例就会相应地创建一个实例变量，它与该实例有相同的生命周期。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;				<span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> y;		<span class="comment">// 静态变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> A.x;	<span class="comment">// Non-static field &#x27;x&#x27; cannot be referenced from a static context</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> a.x;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> A.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 静态方法</strong></p>
<p>静态方法在类加载时就存在了，它不依赖于任何实例。所以静态方法必须要有实现，即它不能是抽象方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func2</span><span class="params">()</span>;  <span class="comment">// Illegal combination of modifiers: &#x27;abstract&#x27; and &#x27;static&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只能访问所属类的静态字段和静态方法，方法中不能有 <code>this</code> 和 <code>super</code> 关键字，因为这两个关键字与具体对象关联。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> y;  		<span class="comment">// Non-static field &#x27;y&#x27; cannot be referenced from a static context</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="built_in">this</span>.y;     <span class="comment">// &#x27;A.this&#x27; cannot be referenced from a static context</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 静态代码块</strong></p>
<p>静态代码块在类加载时运行一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">A</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure>

<p><strong>4. 静态内部类</strong></p>
<p>非静态内部类依赖于外部类的实例，即需要先创建实例才能用实例去创建非静态内部类。而静态内部类不需要。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerClass</span>(); <span class="comment">// &#x27;OuterClass.this&#x27; cannot be referenced from a static context</span></span><br><span class="line">        <span class="type">OuterClass</span> <span class="variable">outerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">        <span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> outerClass.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        <span class="type">StaticInnerClass</span> <span class="variable">staticInnerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticInnerClass</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态内部类不能访问外部类的非静态的变量和方法。</p>
<p><strong>5. 静态导包</strong></p>
<p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.xxx.ClassName.*</span><br></pre></td></tr></table></figure>

<p><strong>6. 初始化顺序</strong></p>
<p>静态变量和静态代码块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p>
<p>存在继承的情况下，初始化顺序为：</p>
<ul>
<li>父类（静态变量、静态语句块）</li>
<li>子类（静态变量、静态语句块）</li>
<li>父类（实例变量、普通语句块）</li>
<li>父类（构造函数）</li>
<li>子类（实例变量、普通语句块）</li>
<li>子类（构造函数）</li>
</ul>
</br>

<h2 id="Java-常见类"><a href="#Java-常见类" class="headerlink" title="Java 常见类"></a>Java 常见类</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><h4 id="equals-与-x3D-x3D"><a href="#equals-与-x3D-x3D" class="headerlink" title="equals 与 &#x3D;&#x3D;"></a>equals 与 &#x3D;&#x3D;</h4><h5 id="x3D-x3D"><a href="#x3D-x3D" class="headerlink" title="&#x3D;&#x3D;"></a>&#x3D;&#x3D;</h5><p><code>==</code> 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否指向同一个对象。比较的是真正意义上的指针操作。</p>
<p><strong>总结：</strong></p>
<ul>
<li>比较的是操作符两端的操作数是否是同一个对象。</li>
<li>两边的操作数必须是同一类型(可以是父子类之间)才能通过编译。</li>
<li>比较的是地址，若是具体的数字相比较则值相等就返回 <code>true</code>。如 <code>int a = 10</code> 、 <code>long b = 10l</code> 与 <code>double c = 10.0</code> 都是相同的，它们都指向地址为 10 的堆。</li>
</ul>
<h5 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h5><p><code>equals</code> 用来比较两个对象的内容是否相同。由于所有类都继承自 <code>Object</code> 类，因此 <code>equals</code> 适用于所有对象。若未对该方法进行覆盖则调用的仍是 <code>Object</code> 类中的方法，而 <code>Object</code> 中的 <code>equals</code> 方法是使用 <code>==</code> 来实现的。</p>
<p><strong>总结：</strong></p>
<ul>
<li>如果没有对 <code>equals</code> 方法进行重写，则比较的是引用类型的变量所指向的对象的地址。</li>
<li>如 <code>String</code>、<code>Date</code> 等类对 <code>equals</code> 方法进行了重写则比较的是所指向的对象的内容。</li>
</ul>
</br>

<h4 id="hashCode-有什么用"><a href="#hashCode-有什么用" class="headerlink" title="hashCode 有什么用"></a>hashCode 有什么用</h4><p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p>
<p><code>hashCode()</code> 定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是： <code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>散列表存储的是键值对(key-value)，它的特点是：<strong>能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码（可以快速找到所需要的对象）。</strong></p>
</br>

<h4 id="为什么要有-hashCode"><a href="#为什么要有-hashCode" class="headerlink" title="为什么要有 hashCode"></a>为什么要有 hashCode</h4><p>当把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。</p>
<p><strong>总结：</strong></p>
<ul>
<li><code>equals()</code> 相等的两个对象它们的 <code>hashCode()</code> 肯定相等，也就是用 <code>equals()</code> 对比是绝对可靠的。</li>
<li><code>hashCode()</code> 相等的两个对象它们的 <code>equals()</code> 不一定相等，只能说明这两个对象在散列存储结构中，也就是 <code>hashCode()</code> 不是绝对可靠的。</li>
</ul>
</br>

<h4 id="为什么建议要同时重写-equals-与-hashCode"><a href="#为什么建议要同时重写-equals-与-hashCode" class="headerlink" title="为什么建议要同时重写 equals 与 hashCode"></a>为什么建议要同时重写 equals 与 hashCode</h4><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p>
<p><strong>总结</strong> ：</p>
<ul>
<li><code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</li>
<li>两个对象有相同的 <code>hashCode</code> 值，它们也不一定是相等的（哈希碰撞）。</li>
</ul>
</br>

<h4 id="会出现两个不相等的对象却拥有相同-hashcode-的情况吗"><a href="#会出现两个不相等的对象却拥有相同-hashcode-的情况吗" class="headerlink" title="会出现两个不相等的对象却拥有相同 hashcode 的情况吗"></a>会出现两个不相等的对象却拥有相同 hashcode 的情况吗</h4><p>会。hash 是通过对数据进行再压缩以提高效率的方法。但由于通过 Hash 函数产生的 hash 值是有限的，而数据较多的情况下就可能导致经过 hash 处理后仍有不同的数据拥有相同的 hash 值，这就产生了 hash 冲突。在产生 hash 冲突时两个不相等的对象就会拥有相同的 hashcode 值。当发送 hash 冲突时，一般会有以下几种处理方式：</p>
<ul>
<li>拉链法：对于相同的 hash 值，使用链表进行连接，使用数组存储每个链表。</li>
<li>开放地址法：一旦发生了冲突，就去寻找下一个空的散列地址。只要散列表足够大，就总能找到空的散列地址。根据寻找下一个地址的方式的不同又可细分为：线性探测法、再平方探测法、伪随机探测法等。</li>
<li>再哈希法：对于冲突的 hash 值再次进行 hash 处理，直到没有 hash 冲突。</li>
<li>建立公共溢出区：建立公共溢出区存储所有 hash 冲突的数据。</li>
</ul>
</br>

<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="String、StringBuffer-与-StringBuilder-的区别"><a href="#String、StringBuffer-与-StringBuilder-的区别" class="headerlink" title="String、StringBuffer 与 StringBuilder 的区别"></a>String、StringBuffer 与 StringBuilder 的区别</h4><h5 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h5><p><code>String</code> 是一个不可变类，任何对 <code>String</code> 改变都是会产生一个新的 <code>String</code> 对象，所以 <code>String</code> 类是使用 <code>final</code> 来修饰的。而 <code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，但没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，因此是可变的。</p>
<h5 id="执行效率"><a href="#执行效率" class="headerlink" title="执行效率"></a>执行效率</h5><p>当需要频繁对字符串进行修改时，使用 <code>String</code> 会生成一些临时对象，多一些附加操作，执行效率较低。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stringA = <span class="string">&quot;stringA&quot;</span> + <span class="string">&quot;2&quot;</span>;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;stringA&quot;</span>)</span><br><span class="line">  buffer.append(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> buffer.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在对 <code>StringA</code> 进行修改时，实际上是先根据字符串创建一个 <code>StringBuffer</code> 对象，然后调用 <code>append</code> 方法对字符串进行修改，再调用 <code>toString</code> 方法返回一个字符串。</p>
<h5 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h5><p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>StringBuffer</code> 的读写方法都使用了 <code>synchronized</code> 修饰，同一时间只有一个线程进行操作，所以是线程安全的。而 <code>StringBuilder</code> 不是线程安全的。</p>
<p><strong>总结：</strong></p>
<ul>
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ul>
</br>

<h4 id="String-为什么是不可变的"><a href="#String-为什么是不可变的" class="headerlink" title="String 为什么是不可变的"></a>String 为什么是不可变的</h4><p><code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被 <code>final</code> 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，<code>final</code> 关键字修饰的数组保存字符串并不是 <code>String</code> 不可变的根本原因，因为这个数组保存的字符串是可变的（<code>final</code> 修饰引用类型变量的情况）。</p>
<p><code>String</code> 真正不可变有下面几点原因：</p>
<ol>
<li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法。</li>
<li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li>
</ol>
</br>

<h4 id="String-不可变的好处"><a href="#String-不可变的好处" class="headerlink" title="String 不可变的好处"></a>String 不可变的好处</h4><p><strong>1. 可以缓存 hash 值</strong></p>
<p>因为 <code>String</code> 的 hash 值经常被用到，例如 <code>String</code> 做 <code>HashMap</code> 的 <code>key</code>。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p>
<p><strong>2. String pool 的需要</strong></p>
<p>如果一个 <code>String</code> 对象已经被创建过了，那么就会从 String pool 中取得引用。只有 <code>String</code> 是不可变的才可能使用 String pool。</p>
<p><img data-src="https://s2.loli.net/2022/09/23/89ri6aFJsbA4YEf.png" alt="image-20220923101137929"></p>
<p><strong>3. 安全性</strong></p>
<p><code>String</code> 经常作为参数，<code>String</code> 的不变性可以保证参数的不可变。例如在网络连接参数的情况下如果 <code>String</code> 时可变的，那么在网络连接过程中 <code>String</code> 被改变，改变 <code>String</code> 的一方以为现在连接的是其他主机而实际情况却不一定是。</p>
<p><strong>4. 线程安全</strong></p>
<p><code>String</code> 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p>
</br>

<h4 id="字符串拼接用-还是-StringBuilder"><a href="#字符串拼接用-还是-StringBuilder" class="headerlink" title="字符串拼接用 + 还是 StringBuilder"></a>字符串拼接用 + 还是 StringBuilder</h4><p>Java 语言本身并不支持运算符重载，<code>+</code> 和 <code>+=</code> 是专门为 <code>String</code> 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。字符串对象通过 <code>+</code> 的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p>
<p>不过，在循环内使用 <code>+</code> 进行字符串的拼接的话，存在比较明显的缺陷：<strong>编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象</strong>。</p>
</br>

<h4 id="字符串常量池是什么"><a href="#字符串常量池是什么" class="headerlink" title="字符串常量池是什么"></a>字符串常量池是什么</h4><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（<code>String</code> 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”ab“</span></span><br><span class="line"><span class="comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">System.out.println(aa == bb);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</br>

<h4 id="String-s1-x3D-new-String-“abc”-创建了几个字符串对象"><a href="#String-s1-x3D-new-String-“abc”-创建了几个字符串对象" class="headerlink" title="String s1 &#x3D; new String(“abc”) 创建了几个字符串对象"></a>String s1 &#x3D; new String(“abc”) 创建了几个字符串对象</h4><p>会创建 1 或 2 个字符串对象。</p>
<ol>
<li>如果字符串常量池中不存在字符串对象 <code>abc</code> 的引用，那么会在堆中创建 2 个字符串对象 <code>abc</code>(先创建一个未被初始化的 <code>String</code> 对象，然后在堆中创建一个 <code>abc</code> 字符串对象并在字符串常量池中保存对应的引用，再调用构造方法为未被初始化的 <code>String</code> 对象赋值)。</li>
<li>如果字符串常量池中已存在字符串对象 <code>abc</code> 的引用，则只会在堆中创建 1 个字符串对象 <code>abc</code>。</li>
</ol>
</br>

<h4 id="intern-方法的作用"><a href="#intern-方法的作用" class="headerlink" title="intern 方法的作用"></a>intern 方法的作用</h4><p>字符串常量池(String pool)保存着所有字符串常量(literal strings)，这些字面量在编译时期就确定。不仅如此，还可以使用 <code>String</code> 的 <code>intern()</code> 方法在运行过程中将字符串添加到 String pool 中。</p>
<p><code>String.intern()</code> 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：</p>
<ul>
<li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li>
<li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</li>
</ul>
<p>在 JDK1.7 之前，String pool 被放在运行时常量池中，属于永久代。而在 JDK1.7，String pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OOM。</p>
</br>

<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><strong>Java 异常类层次结构图概览</strong> ：</p>
<p><img data-src="https://s2.loli.net/2022/09/20/If6iWvV73pntgca.png" alt="img"></p>
<h3 id="Exception-和-Error-的区别"><a href="#Exception-和-Error-的区别" class="headerlink" title="Exception 和 Error 的区别"></a>Exception 和 Error 的区别</h3><p>在 Java 中所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p>
<ul>
<li>**<code>Exception</code>**：程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li>
<li>**<code>Error</code>**：<code>Error</code> 属于程序无法处理的错误，不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li>
</ul>
</br>

<h3 id="Checked-Exception-和-Unchecked-Exception-的区别"><a href="#Checked-Exception-和-Unchecked-Exception-的区别" class="headerlink" title="Checked Exception 和 Unchecked Exception 的区别"></a>Checked Exception 和 Unchecked Exception 的区别</h3><p><strong>Checked Exception</strong> 即<strong>受检查异常</strong>，Java 代码在编译过程中如果受检查异常没有被 <code>catch</code> 或 <code>throws</code> 关键字处理就无法通过编译。除了 <code>RuntimeException</code> 及其子类以外，其他的 <code>Exception</code> 类及其子类都属于受检查异常。常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code>…。</p>
<p><strong>Unchecked Exception</strong> 即<strong>不受检查异常</strong>，Java 代码在编译过程中即使不处理不受检查异常也可以正常通过编译。<code>RuntimeException</code> 及其子类都统称为非受检查异常，常见的有：</p>
<ul>
<li><code>NullPointerException</code>(空指针错误)</li>
<li><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</li>
<li><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）</li>
<li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li>
<li><code>ClassCastException</code>（类型转换错误）</li>
<li><code>ArithmeticException</code>（算术错误）</li>
<li><code>SecurityException</code> （安全错误比如权限不够）</li>
<li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li>
<li>……</li>
</ul>
</br>

<h3 id="Throwable-类常用方法"><a href="#Throwable-类常用方法" class="headerlink" title="Throwable 类常用方法"></a>Throwable 类常用方法</h3><ul>
<li><code>String getMessage()</code>: 返回异常发生时的简要描述</li>
<li><code>String toString()</code>: 返回异常发生时的详细信息</li>
<li><code>String getLocalizedMessage()</code>: 返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li>
<li><code>void printStackTrace()</code>: 在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li>
</ul>
</br>

<h3 id="try-catch-finally-如何使用"><a href="#try-catch-finally-如何使用" class="headerlink" title="try-catch-finally 如何使用"></a>try-catch-finally 如何使用</h3><ul>
<li><code>try </code>块： 用于捕获异常。其后可接 0 到多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li>
<li><code>catch</code> 块： 用于处理 <code>try</code> 捕获到的异常。</li>
<li><code>finally</code> 块： 无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Try to do something&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;RuntimeException&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Try to <span class="keyword">do</span> something</span><br><span class="line">Catch Exception -&gt; RuntimeException</span><br><span class="line">Finally</span><br></pre></td></tr></table></figure>

<p><strong>注意：不要在 <code>finally</code> 语句块中使用 <code>return</code>。</strong>当 <code>try</code> 语句和 <code>finally</code> 语句中都有 <code>return</code> 语句时，<code>try</code> 语句块中的 <code>return</code> 语句会被忽略。这是因为 <code>try</code> 语句中的 <code>return</code> 返回值会先被暂存在一个本地变量中，当执行到 <code>finally</code> 语句中的 <code>return</code> 之后，这个本地变量的值就变为了 <code>finally</code> 语句中的 <code>return</code> 返回值。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(f(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value * value;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>

</br>

<h3 id="finally-中的代码一定会执行吗"><a href="#finally-中的代码一定会执行吗" class="headerlink" title="finally 中的代码一定会执行吗"></a>finally 中的代码一定会执行吗</h3><p>不一定，在某些情况下 <code>finally</code> 中的代码不会被执行:</p>
<ul>
<li><code>finally</code> 之前虚拟机被终止运行。</li>
<li>程序所在的线程死亡。</li>
<li>关闭 CPU。</li>
</ul>
</br>

<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h3><p><strong>Java 泛型（Generics）</strong>是 JDK 5 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。</p>
<blockquote>
<p>“泛型”意味着编写的代码可以被不同类型的对象所重用。</p>
<p>​										—— 《Java 核心技术》</p>
</blockquote>
<p>编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 <code>ArrayList&lt;Person&gt; persons = new ArrayList&lt;Person&gt;()</code> 这行代码就指明了该 <code>ArrayList</code> 对象只能传入 <code>Person</code> 对象，如果传入其他类型的对象就会报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>

<p>并且，原生 <code>List</code> 返回类型是 <code>Object</code> ，需要手动转换类型才能使用，使用泛型后编译器自动转换。</p>
</br>

<h3 id="泛型的使用方式"><a href="#泛型的使用方式" class="headerlink" title="泛型的使用方式"></a>泛型的使用方式</h3><p>泛型一般有三种使用方式:<strong>泛型类</strong>、<strong>泛型接口</strong>、<strong>泛型方法</strong>。</p>
<ol>
<li>泛型类：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例化泛型类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Integer&gt;(<span class="number">123456</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>泛型接口 ：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现泛型接口，不指定类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现泛型接口，指定类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>泛型方法 ：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(E[] inputArray)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (E element : inputArray)&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s &quot;</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建不同类型数组： Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">String[] stringArray = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span> &#125;;</span><br><span class="line">printArray(intArray);</span><br><span class="line">printArray(stringArray);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意: <code>public static &lt;E&gt; void printArray(E[] inputArray)</code> 一般被称为静态泛型方法。在 Java 中泛型只是一个占位符，必须在传递类型后才能使用。类在实例化时才能真正的传递类型参数，由于静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，所以静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的 <code>&lt;E&gt;</code>。</p>
</blockquote>
</br>

<h3 id="项目中常用的泛型"><a href="#项目中常用的泛型" class="headerlink" title="项目中常用的泛型"></a>项目中常用的泛型</h3><ul>
<li>自定义接口通用返回结果 <code>CommonResult&lt;T&gt;</code> 通过参数 <code>T</code> 可根据具体的返回类型动态指定结果的数据类型。</li>
<li>定义 <code>Excel</code> 处理类 <code>ExcelUtil&lt;T&gt;</code> 用于动态指定 <code>Excel</code> 导出的数据类型。</li>
<li>构建集合工具类（参考 <code>Collections</code> 中的 <code>sort</code>, <code>binarySearch</code> 方法）。</li>
<li>…</li>
</ul>
</br>

<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><p>Java 反射机制是指在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种动态获取的信息以及动态调用对象方法的功能称为 Java 语言的反射机制。 </p>
</br>

<h3 id="反射的优缺点"><a href="#反射的优缺点" class="headerlink" title="反射的优缺点"></a>反射的优缺点</h3><p>反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。不过反射让我们在运行时有了分析操作类的能力的同时也增加了安全问题。如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时），另外反射的性能也比较差。</p>
</br>

<h3 id="获取-Class-对象的四种方式"><a href="#获取-Class-对象的四种方式" class="headerlink" title="获取 Class 对象的四种方式"></a>获取 Class 对象的四种方式</h3><ol>
<li>知道具体类的情况下可以使用：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass</span> <span class="operator">=</span> TargetObject.class;</span><br></pre></td></tr></table></figure>

<p>但一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取 Class 对象不会进行初始化。</p>
<ol start="2">
<li>通过 <code>Class.forName()</code> 传入类的全路径获取：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.xxx.TargetObject&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>通过对象实例 <code>instance.getClass()</code> 获取：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TargetObject</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TargetObject</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass2</span> <span class="operator">=</span> o.getClass();</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>通过类加载器 <code>xxxClassLoader.loadClass()</code> 传入类路径获取:</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;com.xxx.TargetObject&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一系列步骤，静态代码块和静态对象不会得到执行。</p>
</br>

<h3 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h3><ul>
<li>一些常用的框架的核心就是使用反射，如 Spring、SpringBoot、Mybatis 等。</li>
<li>动态代理的实现依赖反射。</li>
<li>注解的实现依赖反射。</li>
</ul>
</br>

<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h3><p><code>Annotation</code>（注解）是 Java5 开始引入的新特性，可以看作是一种特殊的注释。主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</p>
<p>注解本质是一个继承了<code>Annotation</code> 的特殊接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Override</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h3 id="注解的解析方法"><a href="#注解的解析方法" class="headerlink" title="注解的解析方法"></a>注解的解析方法</h3><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p>
<ul>
<li><strong>编译期直接扫描</strong> ：编译器在编译 Java 代码的时候扫描对应的注解并处理，如某个方法使用 <code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li>
<li><strong>运行期通过反射处理</strong> ：像框架中自带的注解(如 Spring 框架的 <code>@Value</code> 、<code>@Component</code>)都是通过反射来进行处理的。</li>
</ul>
</br>

<h2 id="I-x2F-O"><a href="#I-x2F-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h2><h3 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h3><p>如果需要持久化 Java 对象如将 Java 对象保存在文件中或在网络中传输 Java 对象，就需要使用到序列化。</p>
<ul>
<li><strong>序列化</strong>： 将数据结构或对象转换成二进制字节流的过程。</li>
<li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程。</li>
</ul>
<p>对于 Java 这种面向对象编程语言来说，序列化的都是对象（Object），也就是实例化后的类(Class)；但在 C++ 这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。</p>
<p><strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p>
<p><img data-src="https://s2.loli.net/2022/09/20/hn3W5DkmAXazPVr.png" alt="img"></p>
</br>

<h3 id="如何处理不需要序列化的字段"><a href="#如何处理不需要序列化的字段" class="headerlink" title="如何处理不需要序列化的字段"></a>如何处理不需要序列化的字段</h3><p>不需要进行序列化的变量可以使用 <code>transient</code> 关键字修饰。</p>
<p><code>transient</code> 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。</p>
<p>关于 <code>transient</code> 有几点注意：</p>
<ul>
<li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li>
<li><code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li>
<li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li>
</ul>
</br>

<h3 id="Java-IO-流"><a href="#Java-IO-流" class="headerlink" title="Java IO 流"></a>Java IO 流</h3><p>IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p>
<p>Java IO 流的 40 多个类都是从以下 4 个抽象类基类中派生出来的：</p>
<ul>
<li><code>InputStream</code>&#x2F;<code>InputReader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li><code>OutputStream</code>&#x2F;<code>OutputWriter</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
</br>

<h3 id="I-x2F-O-流为什么要分为字节流和字符流"><a href="#I-x2F-O-流为什么要分为字节流和字符流" class="headerlink" title="I&#x2F;O 流为什么要分为字节流和字符流"></a>I&#x2F;O 流为什么要分为字节流和字符流</h3><p>字符流是由 Java 虚拟机将字节转换得到的，问题就出现在这个过程非常耗时。并且如果不知道编码类型就很容易乱码。因此 I&#x2F;O 流就提供了一个直接操作字符的接口，方便平时对字符进行操作。如果是音频文件、图片等媒体用字节流比较好，如果涉及到字符如中文则使用字符流比较好。</p>
</br>

<h3 id="BIO、NIO-和-AIO"><a href="#BIO、NIO-和-AIO" class="headerlink" title="BIO、NIO 和 AIO"></a>BIO、NIO 和 AIO</h3><ul>
<li>BIO(Blocking IO)：同步阻塞 IO，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程并处理，如果这个连接不做任何事情会造成不必要的开销，可以通过线程池机制改善，但在高并发场景下传统的 BIO 无能为力，使用线程池也不能解决(线程池中的线程都被占用而不进行IO)。</li>
<li>NIO(Non-blocking IO)：同步非阻塞 IO，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 IO 请求时才启动一个线程进行处理。NIO有三大核心部分: **Channel(通道)、Buffer(缓冲区)、Selector(选择器)**，它支持面向缓冲，基于通道的 I&#x2F;O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。</li>
<li>AIO(Asynchronous IO)：异步非阻塞 IO，服务器实现模式为一个有效请求一个线程，客户端的 IO 请求都是由 OS 先完成了再通知服务器应用去启动线程进行处理。</li>
</ul>
<p><img data-src="https://s2.loli.net/2022/09/20/VgJejDkBR5pTONZ.png" alt="img"></p>
</br>

<h2 id="其他重点"><a href="#其他重点" class="headerlink" title="其他重点"></a>其他重点</h2><h3 id="为什么-Java-中只有值传递"><a href="#为什么-Java-中只有值传递" class="headerlink" title="为什么 Java 中只有值传递"></a>为什么 Java 中只有值传递</h3><h4 id="形参-amp-实参"><a href="#形参-amp-实参" class="headerlink" title="形参 &amp; 实参"></a>形参 &amp; 实参</h4><p>方法的定义可能会用到 <strong>参数</strong>（有参的方法），参数在程序语言中分为：</p>
<ul>
<li><strong>实参（实际参数）</strong> ：用于传递给函数&#x2F;方法的参数，必须有确定的值。</li>
<li><strong>形参（形式参数）</strong> ：用于定义函数&#x2F;方法，接收实参，不需要有确定的值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line"><span class="comment">// hello 为实参</span></span><br><span class="line">sayHello(hello);</span><br><span class="line"></span><br><span class="line"><span class="comment">// str 为形参</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="值传递-amp-引用传递"><a href="#值传递-amp-引用传递" class="headerlink" title="值传递 &amp; 引用传递"></a>值传递 &amp; 引用传递</h4><p>程序设计语言将实参传递给方法（或函数）的方式分为两种：</p>
<ul>
<li><strong>值传递</strong>：方法接收的是实参值的拷贝，会创建副本。</li>
<li><strong>引用传递</strong>：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。</li>
</ul>
<p>很多程序设计语言(如 C++、 Pascal)提供了两种参数传递的方式，但在 Java 中只有值传递。</p>
<h4 id="为什么-Java-只有值传递"><a href="#为什么-Java-只有值传递" class="headerlink" title="为什么 Java 只有值传递"></a>为什么 Java 只有值传递</h4><p><strong>案例 1：传递基本类型参数</strong></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    swap(num1, num2);</span><br><span class="line">    System.out.println(<span class="string">&quot;num1 = &quot;</span> + num1);</span><br><span class="line">    System.out.println(<span class="string">&quot;num2 = &quot;</span> + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">    System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">    System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = 20</span><br><span class="line">b = 10</span><br><span class="line">num1 = 10</span><br><span class="line">num2 = 20</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p>在 <code>swap()</code> 方法中，<code>a</code>、<code>b</code> 的值进行交换，并不会影响到 <code>num1</code>、<code>num2</code>。因为 <code>a</code>、<code>b</code> 的值只是从 <code>num1</code>、<code>num2</code> 的复制过来的。也就是说 <code>a</code>、<code>b</code> 相当于 <code>num1</code>、<code>num2</code> 的副本，副本的内容无论怎么修改都不会影响到原数据本身。</p>
<p><img data-src="https://s2.loli.net/2022/09/20/Urtu9DoSwa7fdvy.png" alt="img"></p>
<p>通过上面例子可以知道一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就会不同。</p>
<p><strong>案例 2：传递引用类型参数 1</strong></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    change(arr);</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">    <span class="comment">// 将数组的第一个元素变为0</span></span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p><img data-src="https://s2.loli.net/2022/09/20/pFLDbM8rRNzGvkt.png" alt="img"></p>
<p>这里 Java 对引用类型的参数采用的也不是是引用传递，传递的还是值，不过这个值是实参的地址。</p>
<p>也就是说 <code>change</code> 方法的参数拷贝的是 <code>arr</code> （实参）的地址。因此，它和 <code>arr</code> 指向的是同一个数组对象。这也就说明了为什么方法内部对形参的修改会影响到实参。</p>
<p><strong>案例 3 ：传递引用类型参数 2</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">   	<span class="comment">// ...</span></span><br><span class="line">   	<span class="comment">// Constructor、Getter&amp;Setter</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">xiaoZhang</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小张&quot;</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">xiaoLi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小李&quot;</span>);</span><br><span class="line">    swap(xiaoZhang, xiaoLi);</span><br><span class="line">    System.out.println(<span class="string">&quot;xiaoZhang:&quot;</span> + xiaoZhang.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;xiaoLi:&quot;</span> + xiaoLi.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Person person1, Person person2)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">temp</span> <span class="operator">=</span> person1;</span><br><span class="line">    person1 = person2;</span><br><span class="line">    person2 = temp;</span><br><span class="line">    System.out.println(<span class="string">&quot;person1:&quot;</span> + person1.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;person2:&quot;</span> + person2.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person1:小李</span><br><span class="line">person2:小张</span><br><span class="line">xiaoZhang:小张</span><br><span class="line">xiaoLi:小李</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p>两个引用类型的形参互换并没有影响实参。</p>
<p><code>swap</code> 方法的参数 <code>person1</code> 和 <code>person2</code> 只是拷贝的实参 <code>xiaoZhang</code> 和 <code>xiaoLi</code> 的地址。因此，<code>person1</code> 和 <code>person2</code> 的互换只是拷贝的两个地址的互换，并不会影响到实参 <code>xiaoZhang</code> 和 <code>xiaoLi</code> 。</p>
<p><img data-src="https://s2.loli.net/2022/09/20/vbIeXyV8xoR6pEa.png" alt="img"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Java 中将实参传递给方法（或函数）的方式是 <strong>值传递</strong> ：</p>
<ul>
<li>如果参数是基本类型，传递的就是基本类型的字面量值的拷贝，会创建副本。</li>
<li>如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。</li>
</ul>
</br>

<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p><strong>使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下提供额外的功能操作，扩展目标对象的功能。</strong></p>
<p><strong>代理模式的主要作用是扩展目标对象的功能，比如在目标对象的某个方法执行前后可以增加一些自定义的操作。</strong></p>
<p>举个例子：新娘找来了自己的姨妈来代替自己处理新郎的提问，新娘收到的提问都是经过姨妈处理过滤之后的。姨妈在这里就可以看作是代理你的代理对象，代理的行为（方法）是接收和回复新郎的提问。</p>
<p><img data-src="https://s2.loli.net/2022/09/20/sK7i8IEoMzWcnHl.png" alt="img"></p>
<p>代理模式有静态代理和动态代理两种实现方式。</p>
<h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>**静态代理中，我们对目标对象的每个方法的增强都是手动完成的，非常不灵活(比如接口一旦新增加方法，目标对象和代理对象都要进行修改)且麻烦(需要对每个目标类都单独写一个代理类)**，实际应用场景非常少。</p>
<p>上面是从实现和应用角度来说的静态代理，从 JVM 层面来说，<strong>静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</strong></p>
<p>静态代理实现步骤:</p>
<ol>
<li>定义一个接口及其实现类</li>
<li>创建一个代理类同样实现这个接口</li>
<li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后进行一些操作</li>
</ol>
<p>代码：</p>
<p><strong>1. 定义发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    String <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 创建代理类并同样实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsProxy</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SmsService smsService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmsProxy</span><span class="params">(SmsService smsService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.smsService = smsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="comment">//调用方法之前添加操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method send()&quot;</span>);</span><br><span class="line">        smsService.send(message);</span><br><span class="line">        <span class="comment">//调用方法之后添加操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method send()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 实际使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SmsService</span> <span class="variable">smsService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsServiceImpl</span>();</span><br><span class="line">        <span class="type">SmsProxy</span> <span class="variable">smsProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsProxy</span>(smsService);</span><br><span class="line">        smsProxy.send(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述代码之后，控制台打印出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before method send()</span><br><span class="line">send message:java</span><br><span class="line">after method send()</span><br></pre></td></tr></table></figure>

<p>可以输出结果看出，我们已经增加了 <code>SmsServiceImpl</code> 的 <code>send()</code> 方法。</p>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>相比于静态代理而言，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类也不必实现接口，可以直接代理实现类(<em>CGLIB 动态代理机制</em>)。</p>
<p><strong>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</strong>Spring AOP、RPC 框架的实现都依赖了动态代理。<strong>虽然动态代理在日常开发中使用地较少，但在框架中是必用的一门技术。学会动态代理对于理解和学习各种框架的原理非常有帮助。</strong>就 Java 来说，动态代理的实现方式有很多种，如 <strong>JDK 动态代理</strong>、<strong>CGLIB 动态代理</strong>等等。</p>
<h5 id="JDK-动态代理机制"><a href="#JDK-动态代理机制" class="headerlink" title="JDK 动态代理机制"></a>JDK 动态代理机制</h5><p><strong>在 Java 动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。</strong></p>
<p><code>Proxy</code> 类中使用频率最高的方法是：<code>newProxyInstance()</code> ，这个方法主要用来生成一个代理对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                      InvocationHandler h)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;removal&quot;)</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; caller = System.getSecurityManager() == <span class="literal">null</span></span><br><span class="line">        ? <span class="literal">null</span></span><br><span class="line">        : Reflection.getCallerClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Look up or generate the designated proxy class and its constructor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Constructor&lt;?&gt; cons = getProxyConstructor(caller, loader, interfaces);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newProxyInstance(caller, cons, h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法有 3 个参数：</p>
<ol>
<li><strong>loader</strong>: 类加载器，用于加载代理对象。</li>
<li><strong>interfaces</strong>: 被代理类实现的一些接口。</li>
<li><strong>h</strong>: 实现了 <code>InvocationHandler</code> 接口的对象。</li>
</ol>
<p>要实现动态代理必须实现 <code>InvocationHandler</code> 来自定义处理逻辑。当动态代理对象调用一个方法时，这个方法的调用就会被转发到实现 <code>InvocationHandler</code> 接口类的 <code>invoke</code> 方法来调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当使用代理对象调用方法的时候实际会调用到这个方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>invoke()</code> 方法有下面三个参数：</p>
<ol>
<li><strong>proxy</strong>: 动态生成的代理类</li>
<li><strong>method</strong>: 与代理类对象调用的方法相对应</li>
<li><strong>args</strong>: 当前 method 方法的参数</li>
</ol>
<p><strong>通过 <code>Proxy</code> 类的 <code>newProxyInstance()</code> 创建的代理对象在调用方法时，实际会调用到实现 <code>InvocationHandler</code> 接口的类的 <code>invoke()</code> 方法。</strong>因此我们可以在 <code>invoke()</code> 方法中自定义处理逻辑，如在方法执行前后进行一些操作。</p>
<h6 id="JDK-动态代理类使用步骤"><a href="#JDK-动态代理类使用步骤" class="headerlink" title="JDK 动态代理类使用步骤"></a>JDK 动态代理类使用步骤</h6><ol>
<li>定义一个接口及其实现类。</li>
<li>自定义 <code>InvocationHandler</code> 并重写 <code>invoke</code> 方法，在 <code>invoke</code> 方法中调用原生方法（被代理类的方法）并自定义一些处理逻辑。</li>
<li>通过 <code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code> 方法创建代理对象。</li>
</ol>
<h6 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h6><p><strong>1. 定义发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    String <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 定义一个 JDK 动态代理类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DebugInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">//调用方法之前添加操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        <span class="comment">//调用方法之后添加操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>invoke()</code> 方法: 当动态代理对象调用原生方法时最终实际上调用到的是 <code>invoke()</code> 方法，<code>invoke()</code> 方法代替我们去调用了被代理对象的原生方法。</p>
<p><strong>4. 获取代理对象的工厂类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(),  <span class="comment">// 目标类的类加载</span></span><br><span class="line">                target.getClass().getInterfaces(),   <span class="comment">// 代理需要实现的接口，可指定多个</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DebugInvocationHandler</span>(target)   <span class="comment">// 代理对象对应的自定义 InvocationHandler</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getProxy()</code>：主要通过 <code>Proxy.newProxyInstance（）</code> 方法获取某个类的代理对象</p>
<p><strong>5. 实际使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SmsService</span> <span class="variable">smsService</span> <span class="operator">=</span> (SmsService) JdkProxyFactory.getProxy(<span class="keyword">new</span> <span class="title class_">SmsServiceImpl</span>());</span><br><span class="line">smsService.send(<span class="string">&quot;java&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>运行上述代码之后，控制台打印出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before method send</span><br><span class="line">send message:java</span><br><span class="line">after method send</span><br></pre></td></tr></table></figure>

</br>

<h5 id="CGLIB-动态代理机制"><a href="#CGLIB-动态代理机制" class="headerlink" title="CGLIB 动态代理机制"></a>CGLIB 动态代理机制</h5><p><strong>JDK 动态代理有一个最致命的问题就是只能代理实现了接口的类。可以用 CGLIB 动态代理机制来避免这个问题。</strong></p>
<p>CGLIB(<em>Code Generation Library</em>)是一个基于 ASM 的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了 CGLIB， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p>
<p><strong>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。</strong>需要自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MethodInterceptor</span></span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">Callback</span>&#123;</span><br><span class="line">    <span class="comment">// 拦截被代理类中的方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, java.lang.reflect.Method method, Object[] args,MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>obj</strong>: 动态生成的代理对象</li>
<li><strong>method</strong>: 被拦截的方法（需要增强的方法）</li>
<li><strong>args</strong>: 方法入参</li>
<li><strong>proxy</strong>: 用于调用原始方法</li>
</ol>
<p>可以通过 <code>Enhancer </code>类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor</code> 中的 <code>intercept</code> 方法。</p>
<h6 id="CGLIB-动态代理类使用步骤"><a href="#CGLIB-动态代理类使用步骤" class="headerlink" title="CGLIB 动态代理类使用步骤"></a>CGLIB 动态代理类使用步骤</h6><ol>
<li>定义一个类；</li>
<li>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</li>
<li>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类；</li>
</ol>
<h6 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h6><p>不同于 JDK 动态代理不需要额外的依赖。CGLIB(<em>Code Generation Library</em>) 实际是属于一个开源项目，如果要使用需要手动添加相关依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>1. 实现一个使用阿里云发送短信的类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliSmsService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 自定义 <code>MethodInterceptor</code>（方法拦截器）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义MethodInterceptor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o           代理对象（增强的对象）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method      被拦截的方法（需要增强的方法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args        方法入参</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 用于调用原始方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//调用方法之前添加操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> methodProxy.invokeSuper(o, args);</span><br><span class="line">        <span class="comment">//调用方法之后添加操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 获取代理类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建动态代理增强类</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">// 设置类加载器</span></span><br><span class="line">        enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">        <span class="comment">// 设置被代理类</span></span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        <span class="comment">// 设置方法拦截器</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">DebugMethodInterceptor</span>());</span><br><span class="line">        <span class="comment">// 创建代理类</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 实际使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AliSmsService</span> <span class="variable">aliSmsService</span> <span class="operator">=</span> (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);</span><br><span class="line">aliSmsService.send(<span class="string">&quot;java&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>运行上述代码之后，控制台打印出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before method send</span><br><span class="line">send message:java</span><br><span class="line">after method send</span><br></pre></td></tr></table></figure>

<h5 id="JDK-动态代理和-CGLIB-动态代理"><a href="#JDK-动态代理和-CGLIB-动态代理" class="headerlink" title="JDK 动态代理和 CGLIB 动态代理"></a>JDK 动态代理和 CGLIB 动态代理</h5><ol>
<li><strong>JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。</strong>另外，CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li>
<li>就二者的效率来说，大部分情况下 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势会更加明显。</li>
</ol>
<h4 id="静态代理和动态代理"><a href="#静态代理和动态代理" class="headerlink" title="静态代理和动态代理"></a>静态代理和动态代理</h4><ol>
<li><strong>灵活性</strong> ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外在静态代理中接口一旦新增加方法，目标对象和代理对象都要进行修改。</li>
<li><strong>JVM 层面</strong> ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li>
</ol>
</br>

<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>Java 集合，也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code> 接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。对于 <code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 和 <code>Queue</code>。</p>
<p>Java 集合框架如下图所示：</p>
<p><img data-src="https://s2.loli.net/2022/09/20/E4AieYPozySKq6n.png" alt="img"></p>
<p><strong>Collection</strong></p>
<ol>
<li><strong>Set</strong><ul>
<li>TreeSet：基于红黑树实现，支持有序性操作，如根据一个范围查找元素的操作。但查找效率不如 <code>HashSet</code>，<code>HashSet</code> 查找的时间复杂度为 <code>O(1)</code>，<code>TreeSet</code> 则为 <code>O(logN)</code>。</li>
<li>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 <code>Iterator</code> 遍历 <code>HashSet</code> 得到的结构是不确定的。</li>
<li>LinkedHashSet：具有 <code>HashSet</code> 的查找效率，并且内部使用双项链表维护元素的插入顺序。</li>
</ul>
</li>
<li><strong>List</strong><ul>
<li>ArrayList：基于动态数组实现，支持随机访问。</li>
<li>Vector：与 <code>ArrayList</code> 类似，但它是线程安全的。</li>
<li>LinkedList：基于双向链表实现，只能顺序访问，但可以快速地在链表中插入和删除元素。此外，<code>LinkedList</code> 还可以用作栈、队列和双向队列。</li>
</ul>
</li>
<li><strong>Queue</strong><ul>
<li>LinkedList：可以用它实现双向队列。</li>
<li>PriorityQueue：基于堆结构实现，可以用它实现优先队列。</li>
</ul>
</li>
</ol>
<p><strong>Map</strong></p>
<ul>
<li><strong>TreeMap</strong>：基于红黑树实现。</li>
<li><strong>HashMap</strong>：基于哈希表实现。</li>
<li><strong>HashTable</strong>：与 <code>HashMap</code> 类似，但它是线程安全的。这意味着同一时刻多个线程同时写入 <code>HashTable</code> 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 <code>ConcurrentHashMap</code> 来支持线程安全，<code>ConcurrentHashMap</code> 的效率会更高，因为 <code>ConcurrentHashMap</code> 引入了分段锁。</li>
<li><strong>LinkedHashMap</strong>：使用双向链表来维护元素的顺序，顺序为插入顺序或最近最少使用(LRU)算法。</li>
</ul>
</br>

<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="ArrayList-与-LinkedList-的区别"><a href="#ArrayList-与-LinkedList-的区别" class="headerlink" title="ArrayList 与 LinkedList 的区别"></a>ArrayList 与 LinkedList 的区别</h3><h4 id="底层使用的数据结构"><a href="#底层使用的数据结构" class="headerlink" title="底层使用的数据结构"></a>底层使用的数据结构</h4><p><code>ArrayList</code> 底层使用的数据结构是 <code>Object</code> <strong>数组</strong>，初始化时就会指向一个 <code>static</code> 修饰的空数组，数组初始长度为 0，插入第一个元素时数组长度会扩展到 10，之后每次数组空间不够进行扩容时都会增加为原来的 1.5 倍。<code>ArrayList</code> 的空间浪费主要体现在在 <code>list</code> 列表的结尾会预留一定的容量空间（避免添加元素时因数组空间不够而频繁申请内存）。</p>
<p><code>LinkedList</code> 底层使用的数据结构是<strong>双向链表</strong>，每个节点保存了指向前驱节点和后继结点的指针。初始化时，不执行任何操作，在添加第一个元素时再去构造链表中的节点。<code>LinkedList</code> 的空间浪费主要体现在它的每一个元素都需要消耗比 <code>ArrayList</code> 更多的空间（存放后继指针 <code>next</code> 和前驱指针 <code>pre</code> 以及数据）。</p>
<p>在项目中一般不会使用到 <code>LinkedList</code> ，需要用到 <code>LinkedList</code> 的场景几乎都可以使用 <code>ArrayList</code> 来代替，并且性能通常会更好。</p>
<h4 id="线程安全-1"><a href="#线程安全-1" class="headerlink" title="线程安全"></a>线程安全</h4><p><code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全。</p>
<p>因为 <code>ArrayList</code> 的插入元素的方法就是直接将原数组 <code>index</code> 及后面的元素拷贝到 <code>index + 1</code> 及后面的位置上，然后将 <code>index</code> 位置设置为插入的值，并发修改时保证不了数据安全性，所以也不允许并发修改，一旦检测到并发修改，会抛出 <code>ConcurrentModificationException</code> 异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArrayList 的插入元素的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!</span></span><br><span class="line">    	<span class="comment">// 将原数组 index 之后的元素拷贝到原数组 index+1 后面的位置上</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入与删除的复杂度"><a href="#插入与删除的复杂度" class="headerlink" title="插入与删除的复杂度"></a>插入与删除的复杂度</h4><ul>
<li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。比如执行 <code>add(E e)</code> 方法时， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 <code>O(1)</code>。但如果要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 <code>O(N - i)</code>。因为在进行上述操作的时候集合中第 <code>i</code> 和第 <code>i</code> 个元素之后的 <code>n-i</code> 个元素都要执行向后位&#x2F;向前移一位的操作。</li>
<li><code>LinkedList</code> 采用链表存储，所以若是在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code> 、 <code>removeLast()</code>），时间复杂度为 <code>O(1)</code>，如果要在指定位置 <code>i</code> 插入和删除元素（<code>add(int index, E element)</code>，<code>remove(Object o)</code>）， 时间复杂度为 <code>O(n)</code> ，因为需要先移动到指定位置再插入。</li>
</ul>
<h4 id="继承树"><a href="#继承树" class="headerlink" title="继承树"></a>继承树</h4><ul>
<li><code>ArrayList</code> 继承自 <code>AbstractList</code> 抽象类，实现了 <code>List</code>, <code>RandomAccess</code>, <code>Cloneable</code>, <code>java.io.Serializable</code> 接口 。</li>
<li><code>LinkedList</code> 继承自 <code>AbstractSequentialList</code> 实现 <code>List</code>, <code>Deque</code>, <code>Cloneable</code>, <code>java.io.Serializable</code> 接口。</li>
</ul>
<p><img data-src="https://s2.loli.net/2022/09/20/zoJxvbMusq6iHrp.png" alt="img"></p>
</br>

<h3 id="ArrayList-扩容机制"><a href="#ArrayList-扩容机制" class="headerlink" title="ArrayList 扩容机制"></a>ArrayList 扩容机制</h3><p>因为 <code>ArrayList</code> 是基于数组实现的，所以支持快速随机访问。<code>RandomAccess</code> 接口标识着该类支持快速随机访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>

<p>数组的默认大小为 <code>10</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>首先，<code>ArrayList</code> 的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 默认初始容量大小</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 默认构造函数，构造一个空列表(无参数构造)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// 创建 initialCapacity 大小的数组</span></span><br><span class="line">         <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// 创建空数组</span></span><br><span class="line">         <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span> + initialCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造包含指定 collection 元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class="line"><span class="comment"> * 如果指定的集合为 null，则 throws NullPointerException。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">     elementData = c.toArray();</span><br><span class="line">     <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">         <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">             elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// replace with empty array.</span></span><br><span class="line">         <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>以无参数构造方法创建 <code>ArrayList</code> 时，实际上初始化赋值的是一个空数组，此时数组容量为 0 ，<code>size</code> 也为 0 。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当向ArrayList中使用 <code>add(E e)</code> 方法添加元素时，会调用 <code>ensureCapacityInternal(size + 1)</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到最小扩容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>ensureCapacityInternal()</code> 方法中，会将 <code>calculateCapacity(elementData, minCapacity)</code> 的值作为参数传入 <code>ensureExplicitCapacity()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>calculateCapacity() </code> 方法中，如果当前数组中元素个数为 0，则会将该数组的容量设值为 <code>DEFAULT_CAPACITY</code> 和  <code>minCapacit</code> 中更大的一个。即当添加第一个元素时，会将数组容量设置为默认容量大小 10。否则数组容量大小就等于传入的 <code>minCapatity</code>。再返回到上层方法 <code>ensureExplicitCapacity()</code> 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否需要扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中，当 <code>minCapatity - elementData.length</code> 的值 <code>&gt; 0</code> 时，调用 <code>grow()</code> 方法，即开始扩容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法将当前数组长度 <code>elementData.length</code> 的值赋给变量 <code>oldCapacity</code>，再声明一个 <code>newCapcity</code> 变量，其值为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>(即 <code>oldCapcity</code> 的值的 1&#x2F;2)。所以 <code>ArrayList</code> 每次扩容之后容量都会变为原来的 1.5 倍左右(<code>oldCapacity</code> 为偶数就是 1.5 倍，为奇数就是 1.5 倍 - 0.5)。</p>
<p>当 <code>newCapcity</code> 的值小于 <code>minCapcity</code> 的值时，让 <code>newCapacity = minCapacity</code>。然后为 <code>elementData</code> 数组赋予新的长度而不改变其中的元素。</p>
<p>最后返回 <code>add(E e)</code> 方法中，将 e 存储在 <code>elementData[size]</code> 位置，再使 <code>size++</code> 。</p>
<p>需要注意的是，扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 <code>ArrayList</code> 对象时就指定大概的容量大小，减少扩容操作的次数。</p>
<p>举例说明：</p>
<ul>
<li>当 <code>add</code> 第 1 个元素时，<code>oldCapacity</code> 为 0，经比较后第一个 if 判断成立，<code>newCapacity = minCapacity</code>(为 10)。但第二个 if 判断不会成立，即 <code>newCapacity</code> 不比 <code>MAX_ARRAY_SIZE</code> 大，则不会进入 <code>hugeCapacity()</code> 方法。数组容量为 10，<code>add</code> 方法中 <code>return true</code>，<code>size</code> 增为 1。</li>
<li>当 <code>add</code> 第 11 个元素进入 <code>grow</code> 方法时，<code>newCapacity</code> 为 15，比 <code>minCapacity</code>（为 11）大，第一个 if 判断不成立。新容量没有大于 <code>MAX_ARRAY_SIZE</code>，不会进入 <code>hugeCapacity</code> 方法。数组容量扩为 15，<code>add</code> 方法中 <code>return true</code>，<code>size</code> 增为 11。</li>
<li>…</li>
</ul>
<p> 如果新容量大于 <code>MAX_ARRAY_SIZE</code> 会进入<code>hugeCapacity()</code> 方法来比较 <code>minCapacity</code> 和 <code>MAX_ARRAY_SIZE</code>，如果 <code>minCapacity</code> 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 <code>MAX_ARRAY_SIZE</code> 即为 <code>Integer.MAX_VALUE - 8</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">    MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><ol>
<li><strong>读写分离</strong></li>
</ol>
<p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写不分离、互不影响。再进行写操作时需要加锁，防止并发写入时导致写入数据丢失，同时在写操作结束后需要把原始数组指向新的复制数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setArray</span><span class="params">(Object[] a)</span> &#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">get</span><span class="params">(Object[] a, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>适用场景</strong></li>
</ol>
<p><code>CopyOnWriteArrayList</code> 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。但 <code>CopyOnWriteArrayList</code> 有其缺陷：</p>
<ul>
<li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li>
<li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li>
</ul>
<p>所以 <code>CopyOnWriteArrayList</code> 不适合内存敏感以及对实时性要求很高的场景。</p>
</br>

<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="无序性与不可重复性"><a href="#无序性与不可重复性" class="headerlink" title="无序性与不可重复性"></a>无序性与不可重复性</h3><ul>
<li>无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</li>
<li>不可重复性是指添加的元素按照 <code>equals()</code> 判断时返回 <code>false</code>，需要同时重写 <code>equals()</code> 方法和 <code>hashCode()</code> 方法。</li>
</ul>
</br>

<h3 id="HashSet、LinkedHashSet-和-TreeSet"><a href="#HashSet、LinkedHashSet-和-TreeSet" class="headerlink" title="HashSet、LinkedHashSet 和 TreeSet"></a>HashSet、LinkedHashSet 和 TreeSet</h3><ul>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li>
<li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li>
</ul>
</br>

<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><h3 id="Queue-与-Deque"><a href="#Queue-与-Deque" class="headerlink" title="Queue 与 Deque"></a>Queue 与 Deque</h3><p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p>
<p><code>Queue</code> 扩展了 <code>Collection</code> 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p>
<table>
<thead>
<tr>
<th><code>Queue</code> 接口</th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody><tr>
<td>插入队尾</td>
<td>add(E e)</td>
<td>offer(E e)</td>
</tr>
<tr>
<td>删除队首</td>
<td>remove()</td>
<td>poll()</td>
</tr>
<tr>
<td>查询队首元素</td>
<td>element()</td>
<td>peek()</td>
</tr>
</tbody></table>
<p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p>
<p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p>
<table>
<thead>
<tr>
<th><code>Deque</code> 接口</th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody><tr>
<td>插入队首</td>
<td>addFirst(E e)</td>
<td>offerFirst(E e)</td>
</tr>
<tr>
<td>插入队尾</td>
<td>addLast(E e)</td>
<td>offerLast(E e)</td>
</tr>
<tr>
<td>删除队首</td>
<td>removeFirst()</td>
<td>pollFirst()</td>
</tr>
<tr>
<td>删除队尾</td>
<td>removeLast()</td>
<td>pollLast()</td>
</tr>
<tr>
<td>查询队首元素</td>
<td>getFirst()</td>
<td>peekFirst()</td>
</tr>
<tr>
<td>查询队尾元素</td>
<td>getLast()</td>
<td>peekLast()</td>
</tr>
</tbody></table>
<p>事实上，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法，可用于模拟栈。</p>
</br>

<h3 id="ArrayDeque-与-LinkedList-的区别"><a href="#ArrayDeque-与-LinkedList-的区别" class="headerlink" title="ArrayDeque 与 LinkedList 的区别"></a>ArrayDeque 与 LinkedList 的区别</h3><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p>
<ul>
<li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li>
<li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li>
<li><code>ArrayDeque</code> 是在 JDK1.6 才被引入的，而<code>LinkedList</code> 早在 JDK1.2 时就已经存在。</li>
<li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 <code>O(1)</code>。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li>
</ul>
<p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p>
</br>

<h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p><code>PriorityQueue</code> 是在 JDK1.5 中被引入的, 其与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p>
<p>这里列举其相关的一些要点：</p>
<ul>
<li><code>PriorityQueue</code> 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li>
<li><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 <code>O(logn)</code> 的时间复杂度内插入元素和删除堆顶元素。</li>
<li><code>PriorityQueue</code> 是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li>
<li><code>PriorityQueue</code> 默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li>
</ul>
</br>

<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="HashMap-与-Hashtable"><a href="#HashMap-与-Hashtable" class="headerlink" title="HashMap 与 Hashtable"></a>HashMap 与 Hashtable</h3><h4 id="线程安全-2"><a href="#线程安全-2" class="headerlink" title="线程安全"></a>线程安全</h4><p><code>HashMap</code> 线程不安全，<code>Hashtable</code> 是线程安全的，其中的方法都是使用 <code>synchronized</code> 关键字修饰的。</p>
<h4 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h4><p>由于线程安全问题，<code>HashMap</code> 的效率高于 <code>Hashtable</code>。另外，<code>Hashtable</code> 在项目中基本不使用，已经几乎被淘汰了。</p>
<h4 id="Null-Key-和-Null-Value"><a href="#Null-Key-和-Null-Value" class="headerlink" title="Null Key 和 Null Value"></a>Null Key 和 Null Value</h4><p><code>HashMap</code> 可以存储 <code>null</code> 的 key 和 value，但 <code>null</code> 作为键只能有一个，<code>null</code> 作为值可以有多个。<code>Hashtable</code> 不允许有 <code>null</code> 的 key 和 value 存在，否则会抛出 <code>NullPointerException</code>。</p>
<h4 id="初始容量与扩容大小"><a href="#初始容量与扩容大小" class="headerlink" title="初始容量与扩容大小"></a>初始容量与扩容大小</h4><ul>
<li>创建时若不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充容量都会变为原来的 <code>2n + 1</code> 倍。<code>HashMap</code> 默认的初始化大小为 16，之后每次扩充容量都会变为原来的 2 倍。</li>
<li>创建时若给定了容量初始值，那么 <code>Hashtable</code> 会直接使用给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的 <code>tableSizeFor()</code> 方法保证）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li>
</ul>
<p>保证 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间。<code>Hashtable</code> 没有这样的机制。</p>
</br>

<h3 id="HashMap-与-HashSet"><a href="#HashMap-与-HashSet" class="headerlink" title="HashMap 与 HashSet"></a>HashMap 与 HashSet</h3><p><code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。（<code>HashSet</code> 的源码除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code> 是 <code>HashSet</code> 自己实现的之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。</p>
<table>
<thead>
<tr>
<th align="center"><code>HashMap</code></th>
<th align="center"><code>HashSet</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">实现 <code>Map</code> 接口</td>
<td align="center">实现 <code>Set</code> 接口</td>
</tr>
<tr>
<td align="center">存储键值对</td>
<td align="center">仅存储对象</td>
</tr>
<tr>
<td align="center">调用 <code>put()</code> 方法向 <code>Map</code> 中添加元素</td>
<td align="center">调用 <code>add()</code> 方法向 <code>Set</code> 中添加元素</td>
</tr>
<tr>
<td align="center"><code>HashMap</code> 使用键（Key）计算 <code>hashcode</code></td>
<td align="center"><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以 <code>equals()</code> 方法用来判断对象的相等性</td>
</tr>
</tbody></table>
</br>

<h3 id="HashMap-与-TreeMap"><a href="#HashMap-与-TreeMap" class="headerlink" title="HashMap 与 TreeMap"></a>HashMap 与 TreeMap</h3><p><code>HashMap</code> 与 <code>TreeMap</code> 都继承自 <code>AbstractMap</code>，但 <code>TreeMap</code> 还实现了 <code>NavigableMap</code> 接口和 <code>SortedMap</code> 接口。</p>
<p><img data-src="https://s2.loli.net/2022/09/21/6OVWEBNfIv5ctPu.png" alt="TreeMap 继承关系图"></p>
<p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</p>
<p>实现 <code>SortedMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素根据键排序的能力。默认是按 <code>key</code> 的升序排序，但也可以指定排序的比较器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TreeMap&lt;Person, String&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person person1, Person person2)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> person2.getAge() - person1.getAge();</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(num, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">3</span>), <span class="string">&quot;person1&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>), <span class="string">&quot;person2&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">35</span>), <span class="string">&quot;person3&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">16</span>), <span class="string">&quot;person4&quot;</span>);</span><br><span class="line">        treeMap.entrySet().stream().forEach(personStringEntry -&gt; &#123;</span><br><span class="line">            System.out.println(personStringEntry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person3</span><br><span class="line">person2</span><br><span class="line">person4</span><br><span class="line">person1</span><br></pre></td></tr></table></figure>

<p>可以看出，<code>TreeMap</code> 中的元素已经是按照 <code>Person</code> 的 <code>age</code> 字段的降序来排列了。也可以将代码替换成 Lambda 表达式实现的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;Person, String&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;((person1, person2) -&gt; &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> person2.getAge() - person1.getAge();</span><br><span class="line">  <span class="keyword">return</span> Integer.compare(num, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>综上，相比于<code>HashMap</code>来说 <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</strong></p>
</br>

<h3 id="HashSet-如何检查重复"><a href="#HashSet-如何检查重复" class="headerlink" title="HashSet 如何检查重复"></a>HashSet 如何检查重复</h3><blockquote>
<p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashcode</code> 值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p>
</blockquote>
<p>在 JDK1.8 中，<code>HashSet</code> 的 <code>add()</code> 方法只是简单的调用了 <code>HashMap</code> 的 <code>put()</code> 方法，并且判断了一下返回值以确保是否有重复元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns: true if this set did not already contain the specified element</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在 <code>HashMap</code> 的 <code>putVal()</code> 方法中也能看到如下说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns : previous value, or null if none</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，在 JDK1.8 中，实际上无论 <code>HashSet</code> 中是否已经存在了某元素，<code>HashSet</code> 都会直接插入，只是会在 <code>add()</code> 方法的返回值处告诉我们插入前是否存在相同元素。</p>
</br>

<h3 id="HashMap-的底层实现"><a href="#HashMap-的底层实现" class="headerlink" title="HashMap 的底层实现"></a>HashMap 的底层实现</h3><h4 id="JDK1-8-之前"><a href="#JDK1-8-之前" class="headerlink" title="JDK1.8 之前"></a>JDK1.8 之前</h4><p>在 JDK1.8 之前，<code>HashMap</code> 底层是<strong>数组和链表</strong>结合在一起使用，也就是链表散列。<code>HashMap</code> 通过 <code>key</code> 的 <code>hashcode</code> 经过扰动函数处理后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置(<code>n</code> 指数组的长度)，若当前位置存在元素，则判断该元素与要存入的元素的 hash 值以及 <code>key</code> 是否相同，如果相同则直接覆盖，否则就通过拉链法解决冲突。</p>
<p>扰动函数指的就是 <code>HashMap</code> 的 <code>hash</code> 方法。使用 <code>hash</code> 方法也就是扰动函数是为了防止一些实现比较差的 <code>hashCode()</code> 方法 换句话说使用扰动函数之后可以减少碰撞。</p>
<p>JDK1.8 的 <code>hash</code> 方法 相比于 JDK1.7 <code>hash</code> 方法更加简化，但原理不变：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回 hashcode</span></span><br><span class="line">    <span class="comment">// ^ ：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;: 无符号右移，忽略符号位，空位都以 0 补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK1.7 的 <code>HashMap</code> 的 <code>hash</code> 方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line"></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比于 JDK1.8 的 <code>hash</code> 方法 ，JDK 1.7 的 <code>hash</code> 方法的性能会稍差一点(扰动了 4 次)。</p>
<p><strong>拉链法</strong>：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<p><img data-src="https://s2.loli.net/2022/09/21/IE8VKobtwXAph6f.png" alt="image-20220921220300619"></p>
<h4 id="JDK1-8-之后"><a href="#JDK1-8-之后" class="headerlink" title="JDK1.8 之后"></a>JDK1.8 之后</h4><p>相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）(将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树)时，将链表转化为红黑树，以减少搜索时间。</p>
<p><img data-src="https://s2.loli.net/2022/09/21/N5xkLuTAj4m8n32.png" alt="image-20220921220437676"></p>
<blockquote>
<p><code>TreeMap</code>、<code>TreeSet</code> 以及 JDK1.8 之后的 <code>HashMap</code> 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p>
</blockquote>
<ol>
<li><code>putVal</code> 方法中执行链表转红黑树的判断逻辑。</li>
</ol>
<p>链表的长度大于 8 的时候，就执行 <code>treeifyBin</code> （转换红黑树）的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历链表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">    <span class="comment">// 遍历到链表最后一个节点</span></span><br><span class="line">    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 如果链表元素个数大于等于TREEIFY_THRESHOLD（8）</span></span><br><span class="line">        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">            <span class="comment">// 红黑树转换（并不会直接转换成红黑树）</span></span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    p = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>treeifyBin</code> 方法中判断是否真的转换为红黑树。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 判断当前数组的长度是否小于 64</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        <span class="comment">// 如果当前数组的长度小于 64，那么会选择先进行数组扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 否则才将列表转换为红黑树</span></span><br><span class="line"></span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将链表转换为红黑树前会判断当前数组的长度是否大于 64，若此时数组的长度还未到达 64 则会先选择进行数组扩容而不是转成红黑树。</p>
</br>

<h3 id="Hashtable-与-ConcurrentHashMap"><a href="#Hashtable-与-ConcurrentHashMap" class="headerlink" title="Hashtable 与 ConcurrentHashMap"></a>Hashtable 与 ConcurrentHashMap</h3><p><code>ConcurrentHashMap</code> 与 <code>Hashtable</code> 的主要区别体现在线程安全的实现方式上。</p>
<ul>
<li>底层数据结构：JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段数组 + 链表</strong> 实现。JDK1.8 采用的数据结构与 JDK1.8 中 <code>HashMap</code> 的结构相同，是 <strong>数组 + 链表&#x2F;红黑树</strong>。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似，都是采用了 <strong>数组 + 链表</strong> 的形式，数组是 <code>HashMap</code> 的主体，链表主要是为了解决 Hash 冲突。</li>
<li>线程安全的实现方式：<ul>
<li>在 JDK1.7 中，<code>ConcurrentHashMap</code> 采用了 <strong>数组 + 分段锁 + 链表</strong> 的方式实现。把容器分成了多个 Segment，每个 Segment 底层数据结构与 <code>HashMap</code> 类似，仍是数组和链表组成的。每个 Segment 独立上 ReentrantLock，因此它们之间互不影响，提高了并发效率。默认有 16 个 Segment，因此最多支持 16 个线程并发写(操作分别分布在不同的 Segment 上)。这个默认值在初始化时可以设置为其他值，但一旦初始化后就不可以修改。</li>
<li>在 JDK1.8 中，<code>ConcurrentHashMap</code> 摒弃了 Segment 的概念，直接使用 <strong><code>Node</code> 数组 + 链表 + 红黑树</strong> 的数据结构来实现。并发控制不再采用分段锁，而是采用无锁算法 CAS。在链表长度超过阈值 8 时将链表（寻址时间复杂度为 <code>O(N)</code>）转换为红黑树（寻址时间复杂度为 <code>O(logN)</code>）。JDK1.8 中，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。</li>
<li>而 <code>Hashtable</code> 是使用 <code>sychronized</code> 来实现线程安全的，效率低。当一个线程访问同步方法时，其他线程再来访问则会进入阻塞或轮询状态。</li>
</ul>
</li>
</ul>
<p>结构图：</p>
<p><img data-src="https://s2.loli.net/2022/09/22/rQbtNj8zMF16vnV.png" alt="image-20220922222126324"></p>
<p><img data-src="https://s1.ax1x.com/2022/09/22/xFxy90.png" alt="xFxy90.png"></p>
<p><img data-src="https://s1.ax1x.com/2022/09/22/xFxccT.png" alt="xFxccT.png"></p>
</br>

<h3 id="JDK1-8-较-JDK1-7-ConcurrentHashMap-的升级"><a href="#JDK1-8-较-JDK1-7-ConcurrentHashMap-的升级" class="headerlink" title="JDK1.8 较 JDK1.7 ConcurrentHashMap 的升级"></a>JDK1.8 较 JDK1.7 ConcurrentHashMap 的升级</h3><h4 id="1-8-较-1-7-的升级"><a href="#1-8-较-1-7-的升级" class="headerlink" title="1.8 较 1.7 的升级"></a>1.8 较 1.7 的升级</h4><ul>
<li>数据结构升级，提高了并发度</li>
<li>当遇到 Hash 碰撞时，会先采取拉链法，达到一定长度后升级为红黑树来提高查找效率</li>
<li>保证并发安全的原理由分段锁升级为了 CAS + synchronized</li>
</ul>
<p>链表长度超过 8 才转为红黑树的原因：</p>
<p>首先在数据量少、链表长度短时查询效率两者差距不大。但红黑树结构所占用的空间是链表的两倍，因此为了节省空间就没有在一开始就使用红黑树结构。在正常情况下想要 Hash 碰撞达到 8 次的概率是十分低的，若真发生这种情况，转为红黑树可以保证在这种极端情况下也能保证查询效率。</p>
</br>

<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。</p>
<p><img data-src="https://s1.ax1x.com/2022/09/24/xAaTVx.png" alt="xAaTVx.png"></p>
<p><img data-src="https://s1.ax1x.com/2022/09/24/xAavMd.png" alt="xAavMd.png"></p>
<p><strong>其中线程私有的区域有：虚拟机栈、本地方法栈、程序计数器。</strong></p>
<p><strong>线程共享的区域有：堆、方法区、直接内存。</strong></p>
</br>

<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</p>
<p>另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>
<p>程序计数器主要有两个作用：</p>
<ul>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来时能够知道该线程上次运行的位置。</li>
</ul>
<p>注意：程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p>
<p>如果执行的是 Native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p>
</br>

<h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3><p>与程序计数器相同，Java 虚拟机栈（后文简称栈）也是线程私有的，它的生命周期和线程相同，随着线程的创建而创建，随着线程的销毁而销毁。</p>
<p>除了 Native 方法调用是通过本地方法栈实现的，其他方法调用的数据需要通过 Java 虚拟机栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。</p>
<p>每个 Java 方法在执行的同时会创建一个<strong>栈帧</strong>用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈到出栈的过程。</p>
<p><img data-src="https://s1.ax1x.com/2022/09/24/xAYbcR.png" alt="xAYbcR.png"></p>
<p>可以通过 <code>-Xss</code> 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK1.4 中默认为 256K，而在 JDK1.5+ 默认为 1M：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xss2M</span><br></pre></td></tr></table></figure>

<p>该区域可能抛出以下异常：</p>
<ul>
<li>当线程请求的栈深度超过最大值，会抛出 <code>StackOverflowError</code>。</li>
<li>栈进行动态扩展时如果无法申请到足够的内存，会抛出 <code>OutOfMemoryError</code>。</li>
</ul>
</br>

<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈与 Java 虚拟机栈类似，它们之间的区别不过是本地方法栈是为本地方法服务的，在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。本地方法一般是使用其他语言(C、C++ 或汇编语言等)编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种错误。</p>
<p>为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p>
</br>

<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存，是垃圾回收的主要区域(GC 堆)**。现代的垃圾回收器基本都是采用分代回收算法，其主要思想是针对不同类型的对象采取不同的垃圾回收算法。Java 堆可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。</p>
<p>在 JDK1.7 及之前，堆内存被通常分为下面三部分：</p>
<ul>
<li>新生代(Young Generation)</li>
<li>老年代(Old Generation)</li>
<li>永久代(Permanent Generation)</li>
</ul>
<p>下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。</p>
<p><img data-src="https://s1.ax1x.com/2022/09/24/xA0Pgg.png" alt="xA0Pgg.png"></p>
<p><strong>JDK1.8 之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存。</strong></p>
<p>堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 <code>OutOfMemoryError</code> 异常。</p>
<p>可以通过 <code>-Xms</code> 和 <code>-Xmx</code> 这两个虚拟机参数来指定一个程序的堆内存大小。第一个参数设置初始值，第二个参数设置最大值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms1M -Xmx2M</span><br></pre></td></tr></table></figure>

</br>

<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。</p>
<p>存放已加载类的信息、常量、静态变量、即时编译器编译后的代码等数据。方法区和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败也会抛出 OOM。对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但一般较难实现。</p>
<p>HotSpot 虚拟机把它当成永久代来进行垃圾回收，但很难确定永久代的大小。因为它受很多因素影响，并且每次 Full GC 后永久代的大小都会改变，所以经常抛出 OOM。为了更容易管理方法区，从 JDK1.8 开始移除了永久代，并把方法区移至元空间，它位于本地内存中而不是虚拟机内存中。</p>
<p>《Java 虚拟机规范》只规定了有方法区这个概念和它的作用，方法区要如何实现是虚拟机要考虑的事情。也就是说，在不同的虚拟机实现上方法区的实现是不同的，永久代和元空间都是其一种实现方式。在 JDK1.8 后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。</p>
</br>

<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池是方法区的一部分。Class 文件中的常量池(编译器生成的字面量和符号引用)会在类加载后被放入这个区域。除了在编译期生成的常量，还允许动态生成，如 <code>String.intern()</code>。</p>
<p>字面量是源代码中的固定值的表示法，即通过字面就能知道其值的含义。字面量包括整数、浮点数和字符串字面量，符号引用包括类符号引用、字段符号引用、方法符号引用和接口方法符号引用。</p>
<p>常量池表会在类加载后存放到方法区的运行时常量池中。运行时常量池的功能类似于传统编程语言的符号表，尽管它包含了比典型符号表更广泛的数据。</p>
<p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 错误。</p>
</br>

<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 <code>OutOfMemoryError</code> 错误出现。在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 <code>DirectByteBuffer</code> 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。</p>
</br>

<h3 id="HotSpot-中对象的创建"><a href="#HotSpot-中对象的创建" class="headerlink" title="HotSpot 中对象的创建"></a>HotSpot 中对象的创建</h3><ol>
<li>类加载检查，判断对象对应的类是否已加载、链接、初始化。</li>
<li>分配内存，计算对象占用大小，堆中分配对应字节。</li>
<li>初始化零值，内存分配结束，虚拟机将分配到的内存空间都初始化为零值。</li>
<li>设置对象头，将对象的所属类（即类的元数据信息）、对象的 HashCode 和对象的 GC 信息、锁信息等数据存储在对象的对象头中。</li>
<li>执行 <code>init</code> 方法，初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。</li>
</ol>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>垃圾回收主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束后就会被销毁，因此不需要对这三个区域进行垃圾回收。</p>
</br>

<h3 id="判断一个对象是否可被回收"><a href="#判断一个对象是否可被回收" class="headerlink" title="判断一个对象是否可被回收"></a>判断一个对象是否可被回收</h3><h4 id="1-引用计数法"><a href="#1-引用计数法" class="headerlink" title="1. 引用计数法"></a>1. 引用计数法</h4><p>为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数器为 0 的对象可以被回收。</p>
<p>但在两个对象存在循环引用的情况下，引用计数器永远不会为 0，导致无法对它们进行回收。正是因为循环引用的存在，Java 虚拟机不使用引用计数法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="type">Test</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="comment">// a 与 b 引用的对象实例互相持有了对象的引用</span></span><br><span class="line">        a.instance = b;</span><br><span class="line">        b.instance = a;</span><br><span class="line">        <span class="comment">//把对 a 对象与 b 对象的引用去除后两个对象还存在互相之间的引用</span></span><br><span class="line">        a = <span class="literal">null</span>;</span><br><span class="line">        b = <span class="literal">null</span>;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h4 id="2-可达性分析法"><a href="#2-可达性分析法" class="headerlink" title="2. 可达性分析法"></a>2. 可达性分析法</h4><p>以 GC Roots 为起点进行搜索，可达的对象都是存活的，不可达的对象可被回收。Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：</p>
<ul>
<li>虚拟机栈中局部变量表中引用的对象</li>
<li>本地方法栈中 JNI 中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
</ul>
<p><img data-src="https://s1.ax1x.com/2022/09/25/xEFFSJ.png" alt="xEFFSJ.png"></p>
</br>

<h4 id="3-方法区的回收"><a href="#3-方法区的回收" class="headerlink" title="3. 方法区的回收"></a>3. 方法区的回收</h4><p>主要是对常量池的回收和对类的卸载。因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行垃圾回收性价比不高。</p>
<p>为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。类卸载的条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：</p>
<ul>
<li>该类的所有实例都已经被回收，此时堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 Class 对象没有再任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li>
</ul>
</br>

<h4 id="4-finalize"><a href="#4-finalize" class="headerlink" title="4. finalize()"></a>4. finalize()</h4><p>类似 C++ 的析构函数，用于关闭外部资源。但是 <code>try-finally</code> 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。</p>
<p>当一个对象可被回收时，如果需要执行该对象的 <code>finalize()</code> 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 <code>finalize()</code> 方法自救，后面回收时不会再调用该方法。</p>
</br>

<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。Java 提供了四种强度不同的引用类型。</p>
<h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>被强引用关联的对象不会被回收。</p>
<p>使用 <code>new</code> 一个新对象的方式来创建强引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>被软引用关联的对象只有在内存不够的情况下才会被回收。</p>
<p>使用 <code>SoftReference</code> 类来创建软引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;  <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure>

<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</p>
<p>使用 <code>WeakReference</code> 类来创建弱引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。</p>
<p>为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。</p>
<p>使用 <code>PhantomReference</code> 来创建虚引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;Object&gt;(obj, <span class="literal">null</span>);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

</br>

<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记 - 清除"></a>标记 - 清除</h4><p><img data-src="https://s1.ax1x.com/2022/09/25/xEEB1e.png" alt="xEEB1e.png"></p>
<p>在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象则程序会在对象头部打上标记。在清除阶段，会进行对象回收并取消标志位。另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，则会合并这两个分块。回收对象就是把对象作为分块，连接到被称为「空闲列表」的单向链表，之后进行分配时只需要遍历这个空闲链表就可以找到分块。</p>
<p>在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 <code>size</code> 的块 <code>block</code>。如果找到的块等于 <code>size</code> 则会直接返回这个分块；如果找到的块大于 <code>size</code>，则会将块分割成大小为 <code>size</code> 和大小为 <code>block - size</code> 的两部分并返回大小为 <code>size</code> 的块，剩下的大小为 <code>block - size</code> 的块会返回给空闲链表。</p>
<p>缺点：</p>
<ul>
<li>标记和清除过程效率都不高。</li>
<li>会产生大量不连续的内存碎片，导致无法给大对象分配内存。</li>
</ul>
</br>

<h4 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记 - 整理"></a>标记 - 整理</h4><p><img data-src="https://s1.ax1x.com/2022/09/25/xEMVo9.png" alt="xEMVo9.png"></p>
<p>与标记 - 清除算法类似，首先也会从根节点开始标记所有被引用对象。但标记 - 整理算法会对活动对象进行整理，将它们向内存的一端移动，然后清除掉端边界以外的内存。</p>
<p>优点：</p>
<ul>
<li>不会产生内存碎片。</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要移动大量对象，处理效率较低。</li>
</ul>
</br>

<h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p><img data-src="https://s1.ax1x.com/2022/09/25/xEMYFA.png" alt="xEMYFA.png"></p>
<p>复制算法将内存划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完时就将存活的对象复制到另一块上，然后再把使用过的内存空间进行回收。但主要不足是只使用了一半内存空间。</p>
<p>现在的商业虚拟机都采用这种回收算法来回收新生代，但划分的两块内存并不是等大小的，而是一块较大的 Eden 空间和两块较小的 Survivor 空间。每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那块 Survivor 即可。</p>
<p>HotSpot 虚拟机的 Eden 和 Survivor 大小默认比例为 8:1，保证了内存的利用率达到 90%。如果每次回收有多余 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。</p>
</br>

<h4 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h4><p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。一般将堆分为新生代和老年代。</p>
<ul>
<li>新生代：复制算法</li>
<li>老年代：标记 - 清除或标记 - 整理算法</li>
</ul>
</br>

<h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p><img data-src="https://s1.ax1x.com/2022/09/25/xEQm7Q.png" alt="xEQm7Q.png"></p>
<p>以上是 HotSpot 虚拟机中的七个垃圾回收器，连线表示垃圾回收器可以配合使用。</p>
<ul>
<li>单线程与多线程：单线程是指垃圾回收器只使用一个线程，而多线程则使用多个线程。</li>
<li>串行与并行：串行是指垃圾回收器与用户程序交替执行，这意味着在执行垃圾回收时需要停顿用户程序；并行是指垃圾回收器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾回收器都是以串行的方式执行。</li>
</ul>
</br>

<h4 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h4><p><img data-src="https://s1.ax1x.com/2022/09/25/xEQdhR.png" alt="xEQdhR.png"></p>
<p>Serial 译为串行，也就是说它以串行的方式执行。Serial 收集器是单线程的收集器，只会使用一个线程进行垃圾回收工作。它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高效的单线程收集效率。</p>
<p>Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择，因为在该场景下内存一般不会很大。</p>
</br>

<h4 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h4><p><img data-src="https://s1.ax1x.com/2022/09/25/xElaqS.png" alt="xElaqS.png"></p>
<p>ParNew 收集器是 Serial 收集器的多线程版本。它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是除了 Serial 收集器，只有它能与 CMS 收集器配合使用。</p>
</br>

<h4 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h4><p>Parallel Scavenge 收集器与 ParNew 收集器一样是多线程收集器。其他收集器的目标是尽可能缩短垃圾回收时用户线程的停顿时间，而 Parallel Scavenge 收集器的目标是达到一个可控制的吞吐量，因此它被称为「吞吐量优先」的收集器。这里的吞吐量是指 CPU 用于运行用户程序的时间占总时间的比值。</p>
<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p>
</br>

<h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><p><img data-src="https://s1.ax1x.com/2022/09/25/xElXZD.png" alt="xElXZD.png"></p>
<p>Serial Old 收集器是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。在 Server 场景下它有两大用途：</p>
<ul>
<li>在 JDK1.5 及之前(Parallel Old 诞生之前)与 Parallel Scavenge 收集器配合使用。</li>
<li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li>
</ul>
</br>

<h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h4><p><img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/278fe431-af88-4a95-a895-9c3b80117de3.jpg" alt="img"></p>
<p>Parallel Old 收集器是 Parallel Scavenge 收集器的老年代版本。在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p>
</br>

<h4 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h4><p><img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/62e77997-6957-4b68-8d12-bfd609bb2c68.jpg" alt="img"></p>
<p>CMS(Concurrent Mark Sweep)，Mark Sweep 指的是标记 - 清除算法。它分为以下四个流程：</p>
<ul>
<li>初始标记：只标记 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li>
<li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li>
<li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那部分对象的标记记录，需要停顿。</li>
<li>并发清除：不需要停顿。</li>
</ul>
<p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p>
<p>缺点：</p>
<ul>
<li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li>
<li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满时再回收。如果预留的内存不够存放浮动垃圾就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li>
<li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li>
</ul>
</br>

<h4 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h4><p>G1(Garbage-First) 是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p>
<p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</p>
<p><img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4cf711a8-7ab2-4152-b85c-d5c226733807.png" alt="img"></p>
<p>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。</p>
<p><img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9bbddeeb-e939-41f0-8e8e-2b1a0aa7e0a7.png" alt="img"></p>
<p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p>
<p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p>
<p><img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f99ee771-c56f-47fb-9148-c0036695b5fe.jpg" alt="img"></p>
<p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li>
<li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li>
</ul>
<p>特点：</p>
<ul>
<li>空间整合：整体来看是基于标记 - 整理算法实现的收集器，从局部（两个 Region 之间）上来看是基于复制算法实现的，这意味着运行期间不会产生内存空间碎片。</li>
<li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li>
</ul>
</br>

<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><h3 id="Minor-GC-与-Full-GC"><a href="#Minor-GC-与-Full-GC" class="headerlink" title="Minor GC 与 Full GC"></a>Minor GC 与 Full GC</h3><ul>
<li>Minor GC：回收新生代。由于新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li>
<li>Full GC：回收老年代和新生代。由于老年代对象存活时间长，因此 Full GC 很少执行，执行速度也会比 Minor GC 慢很多。</li>
</ul>
</br>

<h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><h4 id="1-对象优先在-Eden-分配"><a href="#1-对象优先在-Eden-分配" class="headerlink" title="1. 对象优先在 Eden 分配"></a>1. 对象优先在 Eden 分配</h4><p>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时发起 Minor GC。</p>
</br>

<h4 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2. 大对象直接进入老年代"></a>2. 大对象直接进入老年代</h4><p>大对象是指需要连续内存空间的对象。最典型的大对象就是很长的字符串和数组。经常出现大对象会提前触发垃圾回收以获取足够的连续空间分配给大对象。</p>
<p><code>-XX:PretenureSizeThreshold</code>，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</p>
</br>

<h4 id="3-长期存活的对象进入老年代"><a href="#3-长期存活的对象进入老年代" class="headerlink" title="3. 长期存活的对象进入老年代"></a>3. 长期存活的对象进入老年代</h4><p>为对象定义年龄计数器。若对象在 Eden 出生并经过 Minor GC 依然存活，则将移动到 Survivor 中且年龄增加 1 岁，增加到一定年龄则移动到老年代中。</p>
<p><code>-XX:MaxTenuringThreshold</code> 用来定义年龄的阈值。</p>
</br>

<h4 id="4-动态对象年龄判定"><a href="#4-动态对象年龄判定" class="headerlink" title="4. 动态对象年龄判定"></a>4. 动态对象年龄判定</h4><p>虚拟机并不是要求对象的年龄必须达到 <code>MaxTenuringThreshold</code> 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等达到 <code>MaxTenuringThreshold</code> 中要求的年龄。</p>
</br>

<h4 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5. 空间分配担保"></a>5. 空间分配担保</h4><p>在发生 Minor GC 前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立则可以确认 Minor GC 是安全的。</p>
<p>如果不成立，虚拟机会查看 <code>HandlePromotionFailure</code> 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则将尝试着进行一次 Minor GC；如果小于或 <code>HandlePromotionFailure</code> 的值不允许冒险，那么就要进行一次 Full GC。</p>
</br>

<h3 id="Full-GC-的触发条件"><a href="#Full-GC-的触发条件" class="headerlink" title="Full GC 的触发条件"></a>Full GC 的触发条件</h3><p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：</p>
<h4 id="1-调用-System-gc"><a href="#1-调用-System-gc" class="headerlink" title="1. 调用 System.gc()"></a>1. 调用 System.gc()</h4><p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，最好让虚拟机来管理内存。</p>
</br>

<h4 id="2-老年代空间不足"><a href="#2-老年代空间不足" class="headerlink" title="2. 老年代空间不足"></a>2. 老年代空间不足</h4><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p>
<p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 <code>-Xmn</code> 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收而不进入老年代。还可以通过 <code>-XX:MaxTenuringThreshold</code> 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p>
</br>

<h4 id="3-空间分配担保失败"><a href="#3-空间分配担保失败" class="headerlink" title="3. 空间分配担保失败"></a>3. 空间分配担保失败</h4><p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。</p>
</br>

<h4 id="4-JDK-1-7-及以前的永久代空间不足"><a href="#4-JDK-1-7-及以前的永久代空间不足" class="headerlink" title="4. JDK 1.7 及以前的永久代空间不足"></a>4. JDK 1.7 及以前的永久代空间不足</h4><p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放一些 Class 的信息、常量、静态变量等数据。</p>
<p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 <code>java.lang.OutOfMemoryError</code>。</p>
<p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p>
</br>

<h4 id="5-Concurrent-Mode-Failure"><a href="#5-Concurrent-Mode-Failure" class="headerlink" title="5. Concurrent Mode Failure"></a>5. Concurrent Mode Failure</h4><p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p>
</br>

<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。一次性加载所有类会占用很多内存资源。</p>
</br>

<h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p><img data-src="https://s1.ax1x.com/2022/09/25/xEgkIH.png" alt="xEgkIH.png"></p>
<p>包括以下 7 个阶段：</p>
<ul>
<li><strong>加载(Loading)</strong></li>
<li><strong>连接(Linking)</strong><ul>
<li><strong>验证(Verification)</strong></li>
<li><strong>准备(Preparation)</strong></li>
<li><strong>解析(Resolution)</strong></li>
</ul>
</li>
<li><strong>初始化(Initalization)</strong></li>
<li>使用(Using)</li>
<li>卸载(Unloading)</li>
</ul>
</br>

<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>系统加载 Class 类型的文件主要三步：<strong>加载 -&gt; 连接 -&gt; 初始化</strong>。连接过程又可分为三步：<strong>验证 -&gt; 准备 -&gt; 解析</strong>。</p>
<h4 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h4><p>加载是类加载的一个阶段，加载过程主要完成：</p>
<ul>
<li>通过类的完全限定名获取定义该类的二进制字节流。</li>
<li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构。</li>
<li>在内存中生成一个代表该类的 Class 对象作为方法区中该类各种数据的访问入口。</li>
</ul>
</br>

<h4 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h4><p>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。包括文件格式验证、元数据验证、字节码验证和符号引用验证。</p>
</br>

<h4 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h4><p>类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。实例变量不会在该阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。(实例化不是类加载的过程，类加载发生在所有实例化之前，并且类加载只进行一次，而实例化可以进行多次)</p>
<p>初始值一般为 0，例如下面的类变量 value 被初始化为 0 而不是 123：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<h4 id="4-解析"><a href="#4-解析" class="headerlink" title="4. 解析"></a>4. 解析</h4><p>解析就是将常量池的符号引用替换为直接引用的过程。其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</p>
</br>

<h4 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5. 初始化"></a>5. 初始化</h4><p>初始化阶段是执行初始化方法 <code>&lt;clinit&gt;()</code> 方法的过程，是类加载的最后一步。这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。</p>
<blockquote>
<p><code>&lt;clinit&gt;()</code> 方法是编译之后自动生成的。</p>
</blockquote>
<p>编译器会按照<strong>语句在源文件中出现的顺序</strong>依次自动收集类中所有<strong>静态类变量的赋值动作</strong>和<strong>静态代码块</strong>中的语句合并产生 <code>&lt;clinit&gt;()</code> 方法。如果类中没有静态语句和静态代码块则可以不生成 <code>&lt;clinit&gt;()</code> 方法。</p>
<p>并且 <code>&lt;clinit&gt;()</code> 不需要显式调用父类的初始化方法 <code>&lt;clinit&gt;()</code>。JVM会保证在子类的 <code>&lt;clinit&gt;()</code> 方法执行之前，父类的 <code>&lt;clinit&gt;()</code> 方法已经执行完毕。（接口不需要调用父接口的初始化方法，只有使用到父接口中的静态变量时才需要调用）</p>
<p>如果 <code>&lt;clinit&gt;()</code> 方法中触发了对象的初始化，也就是 <code>&lt;init&gt;()</code> 方法，那么会进入执行 <code>&lt;init&gt;()</code> 方法，执行 <code>&lt;init&gt;()</code> 方法完成之后，再回来继续执行 <code>&lt;clinit&gt;()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClinitTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClinitTest instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static Start&quot;</span>);</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">ClinitTest</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;Static Finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClinitTest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Constructor Start&quot;</span>);</span><br><span class="line">        <span class="comment">// 构造器可以访问声明于他们后面的静态变量</span></span><br><span class="line">        <span class="comment">// 因为静态变量在类加载的准备阶段就已经分配内存并初始化 0 值了</span></span><br><span class="line">        <span class="comment">// 此时 x = 0，y = 0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;x = &quot;</span> + x + <span class="string">&quot;; y = &quot;</span> + y);</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        System.out.println(<span class="string">&quot;x = &quot;</span> + x + <span class="string">&quot;; y = &quot;</span> + y);</span><br><span class="line">        System.out.println(<span class="string">&quot;Constructor Finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClinitTest <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">father</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">static</span>&#123;</span><br><span class="line">            father = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">son</span> <span class="operator">=</span> father;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClinitTest</span> <span class="variable">clinitTest</span> <span class="operator">=</span> ClinitTest.getInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;x = &quot;</span> + clinitTest.x);</span><br><span class="line">        System.out.println(<span class="string">&quot;y = &quot;</span> + clinitTest.y);</span><br><span class="line">        System.out.println(Son.son);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Static Start</span><br><span class="line">Constructor <span class="type">Start</span></span><br><span class="line"><span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; y = <span class="number">0</span></span><br><span class="line">x = <span class="number">1</span>; y = <span class="number">1</span></span><br><span class="line">Constructor Finish</span><br><span class="line">Static <span class="type">Finish</span></span><br><span class="line"><span class="variable">x</span> <span class="operator">=</span> <span class="number">6</span></span><br><span class="line">y = <span class="number">1</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，先执行 static 代码块，此时调用了构造器，构造器中对类变量 <code>x</code> 和 <code>y</code> 进行加 1 ，之后继续执行完 static 代码块。然后执行下面的 <code>public static int x = 6</code> 来重新给类变量 <code>x</code> 赋值为 6，因此最后输出的是 <code>x = 6, y = 1</code>。输出 <code>Son.son</code> 时结果为 20，这是因为父类的 <code>&lt;clinit&gt;()</code> 方法先执行，也就是说父类的静态代码块中的内容优于子类的赋值操作先执行。</p>
<p>虚拟机会保证一个类的 <code>&lt;clinit&gt;()</code> 方法在多线程环境中被正确地加锁同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 <code>&lt;clinit&gt;()</code> 方法，其他线程都需要阻塞等待，直到活动线程执行 <code>&lt;clinit&gt;()</code> 方法完毕。所以如果在一个类的 <code>&lt;clinit&gt;()</code> 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。</p>
</br>

<h3 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h3><h4 id="1-主动引用"><a href="#1-主动引用" class="headerlink" title="1. 主动引用"></a>1. 主动引用</h4><p>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列 5 种情况必须对类进行初始化(加载、验证、准备都会随之发生)：</p>
<ul>
<li>遇到 <code>new</code>、<code>getstatic</code>、<code>putstatic</code>、<code>invokestatic</code> 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 <code>new</code> 关键字实例化对象时；读取或设置一个类的静态字段（被 <code>final</code> 修饰、已在编译期把结果放入常量池的静态字段除外）时；以及调用一个类的静态方法时。</li>
<li>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时，如果类没有进行初始化则需要先触发其初始化。</li>
<li>当初始化一个类时如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时用户需要指定一个要执行的主类（包含 <code>main()</code> 方法的类），虚拟机会先初始化这个主类。</li>
<li>当使用 JDK1.7 的动态语言支持时，如果一个 <code>java.lang.invoke.MethodHandle</code> 实例最后的解析结果为 <code>REF_getStatic</code>, <code>REF_putStatic</code>, <code>REF_invokeStatic</code> 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li>
<li>当一个接口实现了 JDK1.8 中的默认方法时，如果这个接口的实现类被初始化则该接口要在其之前进行实例化。</li>
</ul>
<p>对于以上 6 种触发类的初始化条件，在 JVM 规范中有一个很强制的词：<code>if and only if</code> (有且只有)。这六种行为被称为<strong>对类进行主动引用</strong>，其他引用类的方式均不会触发类的初始化。</p>
<p>除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：</p>
<ol>
<li><p>通过子类引用父类的静态字段，不会导致子类初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(SubClass.value);  <span class="comment">// value 字段在 SuperClass 中定义</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 <code>Object</code> 的子类，其中包含了数组的属性和方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SuperClass[] sca = <span class="keyword">new</span> <span class="title class_">SuperClass</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ConstClass.HELLOWORLD);</span><br></pre></td></tr></table></figure></li>
</ol>
</br>

<h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>两个类相等需要类本身相等并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。</p>
<p>这里的相等，包括类的 Class 对象的 <code>equals()</code> 方法、<code>isAssignableFrom()</code> 方法、<code>isInstance()</code> 方法的返回结果为 <code>true</code>，也包括使用 <code>instanceof</code> 关键字做对象所属关系判定结果为 <code>true</code>。</p>
</br>

<h3 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h3><p>JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自 <code>java.lang.ClassLoader</code>：</p>
<ul>
<li><p><strong>BootstrapClassLoader (启动类加载器)</strong></p>
<p>负责加载 <code>JAVA_HOME/lib</code> 目录下的可以被虚拟机识别的字节码文件(如 <code>rt.jar</code>、<code>tools.jar</code>)。</p>
<p>与之对应的是 <code>java.lang.ClassLoader</code> 类</p>
</li>
<li><p><strong>ExtensionClassLoader (扩展类加载器)</strong></p>
<p>负责加载 <code>JAVA_HOME/lib/ext </code>目录下的的字节码文件。</p>
<p>对应 <code>sun.misc.Launcher</code> 类 此类继承于启动类加载器 <code>ClassLoader</code></p>
</li>
<li><p><strong>AppClassLoader (应用程序类加载器)</strong> </p>
<p>负责加载 <code>ClassPath</code> 路径下的字节码 也就是用户自己写的类。</p>
<p>对应于 <code>sun.misc.Launcher.AppClassLoader</code> 类 此类继承于扩展类加载器 <code>Launcher</code></p>
</li>
</ul>
<p>Java 默认类加载器只加载指定目录下的 class，如果需要动态加载类到内存，例如要从远程网络下来类的二进制，然后调用这个类中的方法实现我的业务逻辑，如此，就需要自定义 ClassLoader：</p>
<ul>
<li><strong>用户自定义加载器</strong></li>
</ul>
<p>​	需要继承系统类加载器<code>ClassLoader</code>，并重写<code>findClass</code>方法。负责加载指定位置的字节码文件。通过类中的path变量指定。</p>
<p><img data-src="https://s2.loli.net/2022/09/25/UEPkmR8qrM1xgZO.png" alt="image-20220925200249795"></p>
</br>

<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p> Java 虚拟机对 class 文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的 class 文件加载到内存生成的 class 对象。在加载某个类的 class 文件时，JVM 采用的是双亲委派模式。即把请求交由父类处理，它是一种任务委派模式。</p>
<p>它的工作流程如下：</p>
<ol>
<li>如果一个类加载器收到了类加载的请求，它并不会自己加载，而是先把请求委托给父类的加载器执行。</li>
<li>如果父类加载器还有父类，则进一步向上委托，依次递归，请求到达最顶层的引导类加载器。</li>
<li>如果顶层类的加载器加载成功，则成功返回。如果失败，则子加载器会尝试加载直到加载成功，否则抛出 <code>ClassNotFoundException</code>。</li>
</ol>
<p>这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。</p>
<p>双亲委派模型对于保证 Java 程序的稳定运作很重要，例如类 <code>java.lang.Object</code>，它存放在 rt.jar 之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 <code>Object</code> 类在程序的各种类加载器环境中都是同一个类。因此双亲委派模型使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。</p>
</br>

<h1 id="Java-并发"><a href="#Java-并发" class="headerlink" title="Java 并发"></a>Java 并发</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="什么是线程和进程"><a href="#什么是线程和进程" class="headerlink" title="什么是线程和进程"></a>什么是线程和进程</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个从进程从创建、运行到消亡的过程。</p>
<p>在 Java 中，当我们启动 <code>main</code> 函数时其实就是启动了一个 JVM 的进程，而 <code>main</code> 函数所在的线程就是这个进程中的一个线程，即主线程。</p>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>线程是进程中的一个执行单位，一个进程至少包含一个线程。同类的多个线程可以共享进程的堆和方法区资源，每个线程都有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程或在各个线程间切换消耗比进程小得多。</p>
<p>一个 Java 程序的运行是 <code>main</code> 线程和多个其他线程同时运行的。</p>
</br>

<h3 id="进程和线程的关系"><a href="#进程和线程的关系" class="headerlink" title="进程和线程的关系"></a>进程和线程的关系</h3><p>线程是进程划分成的更小的运行单位。线程与进程最大的不同在于各进程基本上都是相互独立的，而在同一进程中的线程则可能会相互影响。线程开销小，但不利于资源的管理和保护，而进程则相反。</p>
</br>

<h3 id="如何使用线程"><a href="#如何使用线程" class="headerlink" title="如何使用线程"></a>如何使用线程</h3><p>有三种使用线程的方法：</p>
<ul>
<li>实现 <code>Runnable</code> 接口；</li>
<li>实现 <code>Callable</code> 接口；</li>
<li>继承 <code>Thread</code> 类。</li>
</ul>
<p>实现 <code>Runnable</code> 和 <code>Callable</code> 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 <code>Thread</code> 来调用。可以理解为任务是通过线程驱动从而执行的。</p>
</br>

<h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><ul>
<li><strong>并发</strong>：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li>
<li><strong>并行</strong>：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li>
</ul>
</br>

<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><ul>
<li><strong>同步</strong> ： 发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</li>
<li><strong>异步</strong> ：调用在发出之后，不用等待返回结果，该调用直接返回。</li>
</ul>
</br>

<h3 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h3><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：</p>
<ul>
<li>NEW：初始状态，线程创建后尚未启动。</li>
<li>RUNNABLE：运行中状态，正在 Java 虚拟机中运行。但在操作系统层面，它可能处于运行状态，也可能在等待资源调度，资源调度完成就进入运行状态。</li>
<li>BLOCKED：阻塞状态，需要等待锁释放才能结束该状态。</li>
<li>WAITING：无限期等待状态，等待其它线程显式地唤醒。阻塞和等待的区别在于阻塞是被动的，它是在等待获取锁。而等待是主动的，通过调用 <code>Object.wait()</code> 等方法进入。</li>
<li>TIME_WAITING：限期等待状态，无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</li>
<li>TERMINATED：终止状态，可以是线程结束任务之后自己结束，或者产生了异常而结束。</li>
</ul>
<p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。</p>
<blockquote>
<p>在操作系统层面，线程有 READY 和 RUNNING 状态；而在 JVM 层面只能看到 RUNNABLE 状态，所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p>
<p><strong>为什么 JVM 没有区分这两种状态?</strong></p>
<p>现在的时分（time-sharing）多任务（multi-task）操作系统架构通常都是用所谓的“时间分片（time quantum or time slice）”方式进行抢占式（preemptive）轮转调度（round-robin 式）。这个时间分片通常是很小的，一个线程一次最多只能在 CPU 上运行比如 10-20ms 的时间（此时处于 running 状态），也即大概只有 0.01 秒这一量级，时间片用后就要被切换下来放入调度队列的末尾等待再次调度。（也即回到 ready 状态）。线程切换的如此之快，区分这两种状态就没什么意义了。</p>
</blockquote>
</br>

<h3 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换"></a>什么是上下文切换</h3><p>线程在执行过程中会有自己的运行条件和状态(也称上下文)，如上文程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出：</p>
<ul>
<li>主动让出 CPU，如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li>
<li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饥饿的现象。</li>
<li>调用了阻塞类型的系统中断，如请求 IO，线程被阻塞。</li>
<li>被终止或结束运行</li>
</ul>
<p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是<strong>上下文切换</strong>。</p>
<p>上下文切换是现代操作系统的基本功能，每次需要保存信息恢复信息都会占用 CPU、内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p>
</br>

<h3 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h3><p>死锁指的是两个或两个以上的线程在执行过程中因为争夺资源而造成的互相等待的现象。在无外力的情况下，这些线程一直会相互等待而无法继续进行工作。</p>
<p>产生死锁的四个必要条件：</p>
<ul>
<li>互斥：该资源任意一个时刻只由一个线程占用。</li>
<li>请求与保持：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li>循环等待：若干线程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
</br>

<h3 id="如何预防和避免线程死锁"><a href="#如何预防和避免线程死锁" class="headerlink" title="如何预防和避免线程死锁"></a>如何预防和避免线程死锁</h3><p>可以破坏产生死锁的四个必要条件来避免死锁：</p>
<ul>
<li>破坏请求与保持条件：一次性申请所有的资源。</li>
<li>破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li>破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>
</ul>
</br>

<h3 id="sleep-与-wait"><a href="#sleep-与-wait" class="headerlink" title="sleep() 与 wait()"></a>sleep() 与 wait()</h3><p>这两个方法都可以暂停线程的执行。</p>
<ul>
<li><code>sleep()</code> 方法不会释放锁，而 <code>wait()</code> 方法会释放所持有的锁。</li>
<li><code>wait()</code> 通常用于线程间交互&#x2F;通信，<code>sleep()</code> 通常用于暂停执行。</li>
<li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify() </code>或 <code>notifyAll()</code> 方法。<code>sleep()</code> 方法执行完成后，线程会自动苏醒，也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li>
<li><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法。</li>
</ul>
</br>

<h3 id="为什么-wait-方法不定义在-Thread-中"><a href="#为什么-wait-方法不定义在-Thread-中" class="headerlink" title="为什么 wait() 方法不定义在 Thread 中"></a>为什么 wait() 方法不定义在 Thread 中</h3><p><code>wait()</code> 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（<code>Object</code>）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（<code>Object</code>）而非当前的线程（<code>Thread</code>）。</p>
<p>类似的问题：<strong>为什么 <code>sleep()</code> 方法定义在 <code>Thread</code> 中？</strong></p>
<p>因为 <code>sleep()</code> 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。</p>
</br>

<h3 id="可以直接调用-Thread-类的-run-方法吗"><a href="#可以直接调用-Thread-类的-run-方法吗" class="headerlink" title="可以直接调用 Thread 类的 run 方法吗"></a>可以直接调用 Thread 类的 run 方法吗</h3><p><code>new</code> 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code> 方法会启动一个线程并使线程进入就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。但如果直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p><strong>总结：调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法不会以多线程的方式执行。</strong></p>
</br>

<h3 id="happens-before-规则"><a href="#happens-before-规则" class="headerlink" title="happens-before 规则"></a>happens-before 规则</h3><ul>
<li><strong>程序次序规则：</strong>一个线程中，按照程序的顺序，前面的操作 happens-before 后续的任何操作。</li>
<li><strong>监视器锁规则：</strong>对一个锁的解锁操作，happens-before 后续对这个锁的加锁操作。</li>
<li><strong>volatile 变量规则：</strong>对一个 volatile 变量的写操作 happens-before 后续对这个变量的读操作。</li>
<li><strong>线程启动规则：</strong>主线程 A 启动线程 B，线程 B 中可以看到主线程启动 B 之前的操作。</li>
<li><strong>线程加入规则：</strong>如果线程 A 执行操作 <code>join()</code> 线程 B 并成功返回，那么线程 B 中的任意操作 happens-before 线程 A <code>join()</code> 操作成功返回。</li>
<li><strong>传递性规则：</strong>如果 A happens-before B，B happens-before C，那么 A happens-before C。</li>
</ul>
</br>

<h2 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h2><h3 id="并发编程的特性"><a href="#并发编程的特性" class="headerlink" title="并发编程的特性"></a>并发编程的特性</h3><ul>
<li><p><strong>原子性</strong>：一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。</p>
<p>在 Java 中，可以借助<code>synchronized</code> 、各种 <code>Lock</code> 以及各种原子类实现原子性。<code>synchronized</code> 和各种 <code>Lock</code> 可以保证任一时刻只有一个线程访问该代码块，因此可以保障原子性。各种原子类是利用 CAS 操作（可能也会用到 <code>volatile</code>或者<code>final</code>关键字）来保证原子操作。</p>
</li>
<li><p><strong>可见性</strong>：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。</p>
<p>在 Java 中，可以借助 <code>synchronized</code> 、<code>volatile</code> 以及各种 <code>Lock</code> 实现可见性。</p>
</li>
<li><p><strong>有序性</strong>：即程序执行的顺序按照代码的先后顺序执行。由于指令重排序问题，代码的执行顺序未必就是编写代码时候的顺序。在 Java 中，<code>volatile</code> 关键字可以禁止指令进行重排序优化。</p>
</li>
</ul>
</br>

<h3 id="volatile-的特性"><a href="#volatile-的特性" class="headerlink" title="volatile 的特性"></a>volatile 的特性</h3><ul>
<li>保证可见性</li>
<li>不保证原子性</li>
<li>禁止指令重排</li>
</ul>
</br>

<h3 id="如何保证变量的可见性"><a href="#如何保证变量的可见性" class="headerlink" title="如何保证变量的可见性"></a>如何保证变量的可见性</h3><p>在 Java 中 <code>volatile</code> 关键字可以保证变量的可见性，如果将变量声明为 <code>volatile</code> ，这就指示 JVM 这个变量是共享且不稳定的，每次使用它都到主存中进行读取。<code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</p>
</br>

<h3 id="如何禁止指令重排序"><a href="#如何禁止指令重排序" class="headerlink" title="如何禁止指令重排序"></a>如何禁止指令重排序</h3><p><strong>在 Java 中，<code>volatile</code> 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。</strong>如果将变量声明为 <code>volatile</code>，在对这个变量进行读写操作时会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。</p>
<p>在 Java 中，<code>Unsafe</code> 类提供了三个开箱即用的内存屏障相关的方法，屏蔽了操作系统底层的差异：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">loadFence</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">storeFence</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">fullFence</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>理论上来说通过这个三个方法也可以实现和 <code>volatile</code> 禁止重排序一样的效果，只是会麻烦一些。</p>
</br>

<h3 id="volatile-可以保证原子性吗"><a href="#volatile-可以保证原子性吗" class="headerlink" title="volatile 可以保证原子性吗"></a>volatile 可以保证原子性吗</h3><p><strong><code>volatile</code> 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。</strong>要保证原子性可以使用 <code>sychronized</code>、<code>Lock</code> 或 <code>Atomic</code> 类。</p>
</br>

<h2 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h2><h3 id="对-synchronized-关键字的了解"><a href="#对-synchronized-关键字的了解" class="headerlink" title="对 synchronized 关键字的了解"></a>对 synchronized 关键字的了解</h3><p><code>synchronized</code> 译为同步，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>
<p>在 Java 早期版本中，<code>synchronized</code> 属于<strong>重量级锁</strong>，效率低下。因为监视器锁（monitor）是依赖于底层的操作系统的 <code>Mutex Lock</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p>
<p>不过，在 Java 6 之后，Java 官方对从 JVM 层面对 <code>synchronized</code> 较大优化，所以现在的 <code>synchronized</code> 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。所以，目前不论是各种开源框架还是 JDK 源码都大量使用了 <code>synchronized</code> 关键字。</p>
</br>

<h3 id="如何使用-synchronized-关键字"><a href="#如何使用-synchronized-关键字" class="headerlink" title="如何使用 synchronized 关键字"></a>如何使用 synchronized 关键字</h3><p><code>synchronized</code> 关键字最主要的三种使用方式：</p>
<ol>
<li><strong>修饰实例方法</strong>(锁当前对象实例)</li>
</ol>
<p>给当前对象实例加锁，进入同步代码块前要获得当前对象实例的锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>修饰静态方法</strong>(锁当前类)</li>
</ol>
<p>给当前类加锁，会作用于类的所有对象实例，进入同步代码块钱要获得当前 class 的锁。这是因为静态成员不属于任何一个实例对象，归整个类所有，不依赖于类的特定实例，被类的所有实例共享。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>静态 <code>synchronized</code> 方法和非静态 <code>synchronized</code> 方法之间的调用不互斥。如果一个线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法，而线程 B 需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，不会发生互斥现象，因为访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象锁。</p>
<ol start="3">
<li><strong>修饰代码块</strong>(锁指定对象&#x2F;类)</li>
</ol>
<p>对括号里指定的对象&#x2F;类加锁：</p>
<ul>
<li><code>synchronized(object)</code> 表示进入同步代码库前要获得<strong>给定对象的锁</strong>。</li>
<li><code>synchronized(类.class)</code> 表示进入同步代码前要获得<strong>给定 Class 的锁</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li><code>synchronized</code> 关键字加到 <code>static</code> 静态方法和 <code>synchronized(class)</code> 代码块上都是是给 Class 上锁.</li>
<li><code>synchronized</code> 关键字加到实例方法上是给对象实例上锁.</li>
<li>尽量不要使用 <code>synchronized(String a)</code>，因为 JVM 中字符串常量池具有缓存功能。</li>
</ul>
</br>

<h3 id="JVM-对-synchronized-的优化"><a href="#JVM-对-synchronized-的优化" class="headerlink" title="JVM 对 synchronized 的优化"></a>JVM 对 synchronized 的优化</h3><p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意<strong>锁可以升级不可降级</strong>，这种策略是为了提高获得锁和释放锁的效率。</p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p>
<p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。</p>
<p>在 JDK1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p>
</br>

<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p>
<p>对于一些看起来没有加锁的代码其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">concatString</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>String</code> 是一个不可变的类，编译器会对 <code>String</code> 的拼接自动优化。在 JDK1.5 之前，会转化为 <code>StringBuffer</code> 对象的连续 <code>append()</code> 操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">concatString</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个 <code>append()</code> 方法中都有一个同步块。虚拟机观察变量 <code>sb</code>，很快就会发现它的动态作用域被限制在 <code>concatString()</code> 方法内部。也就是说 <code>sb</code> 的所有引用永远不会逃逸到 <code>concatString()</code> 方法之外，其他线程无法访问到它，因此可以进行锁消除。</p>
</br>

<h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p>
<p>锁消除示例代码中连续的 <code>append()</code> 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 <code>append()</code> 操作之前直至最后一个 <code>append()</code> 操作之后，这样只需要加锁一次就可以了。</p>
</br>

<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>JDK1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态(unlocked)、偏向锁状态(biasble)、轻量级锁状态(lightweight locked)和重量级锁状态(inflated)。</p>
<p>以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 <code>Mark Word</code>。其中 <code>tag bits</code> 对应了五个状态，这些状态在右侧的 <code>state</code> 表格中给出。</p>
<p><img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/bb6a49be-00f2-4f27-a0ce-4ed764bc605c.png"></p>
<p>下图左侧是一个线程的虚拟机栈，其中有一部分称为 <code>Lock Record</code> 的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的 <code>Mark Word</code>。而右侧就是一个锁对象，包含了 <code>Mark Word</code> 和其它信息。</p>
<p><img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/051e436c-0e46-4c59-8f67-52d89d656182.png"></p>
<p>轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。</p>
<p>当尝试获取一个锁对象时，如果锁对象标记为 <code>0 01</code>，说明锁对象的锁未锁定(unlocked)状态。此时虚拟机在当前线程的虚拟机栈中创建 <code>Lock Record</code>，然后使用 CAS 操作将对象的 <code>Mark Word</code> 更新为 <code>Lock Record</code> 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 <code>Mark Word</code> 的锁标记变为 00，表示该对象处于轻量级锁状态。</p>
<p><img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/baaa681f-7c52-4198-a5ae-303b9386cf47.png"></p>
<p>如果 CAS 操作失败了，虚拟机首先会检查对象的 <code>Mark Word</code> 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。</p>
</br>

<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。</p>
<p>当锁对象第一次被线程获得的时候，进入偏向状态，标记为 <code>1 01</code>。同时使用 CAS 操作将线程 ID 记录到 <code>Mark Word</code> 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。</p>
<p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向(Revoke Bias)后恢复到未锁定状态或者轻量级锁状态。</p>
<p><img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/390c913b-5f31-444f-bbdb-2b88b688e7ce.jpg"></p>
</br>

<h3 id="synchronized-与-volatile"><a href="#synchronized-与-volatile" class="headerlink" title="synchronized 与 volatile"></a>synchronized 与 volatile</h3><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在。</p>
<ul>
<li><code>volatile</code> 关键字是线程同步的轻量级实现，所以 <code>volatile</code> 性能比 <code>synchronized</code> 关键字要好。但 <code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块。</li>
<li><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</li>
<li><code>volatile</code> 关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</li>
</ul>
</br>

<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="ThreadLocal-的作用"><a href="#ThreadLocal-的作用" class="headerlink" title="ThreadLocal 的作用"></a>ThreadLocal 的作用</h3><p><code>ThreadLocal</code> 主要功能就是给每个线程创建变量副本，这样就可以保证一个线程对某个变量的修改不会影响到其他线程对该变量的使用。也就是说，每个线程的ThreadLocal变量是自己专用的，其他线程是访问不到的。</p>
<p>如果创建了一个 <code>ThreadLocal</code> 变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是 <code>ThreadLocal</code> 变量名的由来。它们可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p>
<p>使用场景：</p>
<ol>
<li>每个线程都需要一个独享的对象（通常是工具类，如 <code>SimpleDateFormat</code> 和 <code>Random</code>）</li>
<li>每个线程内需要保存全局变量（如在拦截器中获取用户信息），可以让不同的方法直接使用，避免频繁的传递参数。</li>
</ol>
</br>

<h3 id="如何使用-ThreadLocal"><a href="#如何使用-ThreadLocal" class="headerlink" title="如何使用 ThreadLocal"></a>如何使用 ThreadLocal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalUsage6</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            executorService.submit(() -&gt; System.out.println(<span class="keyword">new</span> <span class="title class_">ThreadLocalUsage6</span>().date(finalI * <span class="number">10</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">date</span><span class="params">(<span class="type">int</span> seconds)</span>&#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(seconds * <span class="number">1000L</span>);</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> ThreadSafeFormat.simpleDateFormat.get();</span><br><span class="line">        <span class="keyword">return</span> sdf.format(date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadSafeFormat</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; simpleDateFormat = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h3 id="ThreadLocal-原理"><a href="#ThreadLocal-原理" class="headerlink" title="ThreadLocal 原理"></a>ThreadLocal 原理</h3><p> <code>Thread</code> 类源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 与此线程有关的 ThreadLocal 值。由 ThreadLocal 类维护</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与此线程有关的 InheritableThreadLocal 值。由 InheritableThreadLocal 类维护</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面 <code>Thread</code> 类源码可以看出 <code>Thread</code> 类中有一个 <code>threadLocals</code> 和一个 <code>inheritableThreadLocals</code> 变量，它们都是 <code>ThreadLocalMap</code> 类型的变量。<code>ThreadLocalMap</code> 是 <code>ThreadLocal</code> 的静态内部类，我们可以把 <code>ThreadLocalMap</code> 理解为 <code>ThreadLocal</code> 类实现的定制化的 <code>HashMap</code>。默认情况下这两个变量都是 <code>null</code>，只有当前线程调用 <code>ThreadLocal</code> 类的 <code>set()</code> 或 <code>get()</code> 方法时才创建它们，实际上调用这两个方法时调用的是 <code>ThreadLocalMap</code> 类对应的 <code>get()</code>、<code>set()</code> 方法。</p>
<p><code>ThreadLocal</code> 类的 <code>set()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前请求的线程    </span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 取出 Thread 类内部的 threadLocals 变量(哈希表结构)</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 将需要存储的值放入到这个哈希表中</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最终的变量存入了当前线程的 <code>ThreadLocalMap</code> 中而不是 <code>ThreadLocal</code> 中，<code>ThreadLocal</code> 可以理解为只是 <code>ThreadLocalMap</code> 的封装，传递了变量值。</strong> <code>ThrealLocal</code> 类中可以通过 <code>Thread.currentThread()</code> 获取到当前线程对象后，直接通过 <code>getMap(Thread t)</code> 可以访问到该线程的 <code>ThreadLocalMap</code> 对象。</p>
<p><strong>每个 <code>Thread</code> 中都具备一个 <code>ThreadLocalMap</code>，而 <code>ThreadLocalMap</code> 可以存储以 <code>ThreadLocal</code> 为 key ，<code>Object</code> 对象为 value 的键值对。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://s1.ax1x.com/2022/05/19/ObCXJ1.png" alt="ObCXJ1.png"></p>
<p>如果在同一个线程中声明了两个 <code>ThreadLocal</code> 对象的话，<code>Thread</code> 内部都是使用仅有的那个 <code>ThreadLocalMap</code> 存放数据的，<code>ThreadLocalMap</code> 的 key 就是 <code>ThreadLocal</code> 对象，value 就是 <code>ThreadLocal</code> 对象调用 <code>set()</code> 方法设置的值。</p>
</br>

<h3 id="ThreadLocal-内存泄漏问题"><a href="#ThreadLocal-内存泄漏问题" class="headerlink" title="ThreadLocal 内存泄漏问题"></a>ThreadLocal 内存泄漏问题</h3><p>内存泄漏，即已经申请的内存空间无法释放，就会造成内存泄漏，例如线程死循环、资源不关闭等，大量的内存泄漏堆积就会造成内存不够，从而发生内存溢出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">    <span class="built_in">super</span>(k);</span><br><span class="line">    value = v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在源码中可以看到 <code>Entry</code> 的构造方法并不是简单的赋值，还有利用了 <code>super()</code> 进行赋值的 <code>ThreadLocal</code> 对象 <code>k</code>。<code>Entry</code> 继承自 <code>WeakReference</code> 类，即弱引用类。</p>
<blockquote>
<p>弱引用是用来描述非必须的对象的，但它的强度比软引用更弱。</p>
<p>被弱引用关联的对象只能生存到下一次 GC 发生之前，也就是说下一次 GC 就会被回收。</p>
<p>JDK1.2 之后，提供了 <code>WeakReference</code> 来实现弱引用。</p>
</blockquote>
<p>因此，如果没有强引用去引用使用弱引用的构造方法进行赋值的 <code>ThreadLocal k</code>，那么 <code>k</code> 就会在下一次 GC 时被回收。若此时作为 Key 的 <code>k</code> 被 GC 回收，而 value 又是被 <code>Entry</code> 强引用因而无法被回收，那么其对应的 value 就无法被访问到了，只要线程还在运行，value 的内存就不会释放，这样发生了内存泄漏。即存在调用链：</p>
<p>Thread -&gt; ThreadLocalMap -&gt; Entry(Key &#x3D; null) -&gt; Value</p>
<p>单个线程的情况下，线程结束的时候，内存泄漏的 value 会被回收，不会有什么问题。但若使用的线程池则会一直运行下去，这样 value 内存会被一直占用，并且可能会不断增加而导致 OOM。</p>
<p>为了避免内存泄漏问题：</p>
<ul>
<li>使用完 <code>ThreadLocal</code> 后调用其 <code>remove()</code> 方法删除对应的 <code>Entry</code></li>
</ul>
<p>需要明确的是，内存泄漏与 Key 的弱引用之间没有直接关系。如果 <code>Entry</code> 节点将 <code>ThreadLocal</code> 对象作为一个成员变量而不是采用弱引用的方式，那么 <code>Entry</code> 节点会一直对 Key 和 value 保持着强引用关系。这样，即使 <code>Threadlocal</code> 对象在其它地方都不再使用了该对象也不会被回收。这就会导致 <code>Entry</code> 节点永远不会被回收(只要线程不终结)，而且也不能主动去判断是否能切断 <code>ThreadLocalMap</code> 中 <code>Threadlocal</code> 对象的引用（不知道是否还有其它地方引用到了）。</p>
<p>因为 <code>map</code> 是 <code>Thread</code> 对象的一个成员变量，只要线程不终结 <code>map</code> 也是不会被回收的。如果发生了内存泄露的问题，则可能会一直积累下去，最终导致程序 OOM。而 Key 采用弱引用加之主动的判断过时节点(key 是否为 null)并进行清除处理可以最大限度的减少内存泄露的发生。</p>
<br>

<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="线程池的作用"><a href="#线程池的作用" class="headerlink" title="线程池的作用"></a>线程池的作用</h3><p>线程池提供了一种限制和管理资源（包括执行一个任务）的方式。由于线程的创建和销毁对资源的开销很大，因此需要线程池来对线程进行统一分配，需要线程时从线程池中获取线程即可，这样就避免了反复的创建和销毁线程，实现了控制线程总数和线程复用。</p>
<p>线程池能够对线程进行统一分配、调优和监控:</p>
<ul>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性。</li>
</ul>
</br>

<h3 id="实现-Runnable-与-Callable-接口的区别"><a href="#实现-Runnable-与-Callable-接口的区别" class="headerlink" title="实现 Runnable 与 Callable 接口的区别"></a>实现 Runnable 与 Callable 接口的区别</h3><p><code>Runnable</code> 自 JDK1.0 以来一直存在，但 <code>Callable</code> 在 JDK1.5 中引入，目的就是为了来处理 <code>Runnable</code> 不支持的用例。<code>Runnable</code> 接口不会返回结果或抛出检查异常，但 <code>Callable</code> 接口可以。所以如果任务不需要返回结果或抛出异常推荐使用 <code>Runnable</code> 接口。</p>
<p>工具类 <code>Executors</code> 可以实现将 <code>Runnable</code> 对象转换成 <code>Callable</code> 对象。（<code>Executors.callable(Runnable task)</code> 或 <code>Executors.callable(Runnable task, Object result)</code>）。</p>
</br>

<h3 id="执行-execute-与-submit-的区别"><a href="#执行-execute-与-submit-的区别" class="headerlink" title="执行 execute() 与 submit() 的区别"></a>执行 execute() 与 submit() 的区别</h3><ol>
<li><code>execute()</code> 方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否。</li>
<li><code>submit()</code> 方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功，并且可以通过 <code>Future</code> 的 <code>get()</code> 方法来获取返回值，<code>get()</code> 方法会阻塞当前线程直到任务完成，而使用 <code>get(long timeout，TimeUnit unit)</code> 方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li>
</ol>
</br>

<h3 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h3><h4 id="通过构造方法创建。"><a href="#通过构造方法创建。" class="headerlink" title="通过构造方法创建。"></a>通过构造方法创建。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">参数名</th>
<th align="left">类型</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">corePoolSize</td>
<td align="left">int</td>
<td align="left">核心线程数</td>
</tr>
<tr>
<td align="left">maxPoolSize</td>
<td align="left">int</td>
<td align="left">最大线程数</td>
</tr>
<tr>
<td align="left">keepAliveTime</td>
<td align="left">long</td>
<td align="left">保持存活时间</td>
</tr>
<tr>
<td align="left">workQueue</td>
<td align="left">BlockingQueue</td>
<td align="left">任务存储队列</td>
</tr>
<tr>
<td align="left">threadFactory</td>
<td align="left">ThreadFactory</td>
<td align="left">当线程池需要新的线程时会使用 threadFactory 来生成新的线程</td>
</tr>
<tr>
<td align="left">Handler</td>
<td align="left">RejectedExecutionHandler</td>
<td align="left">线程池无法接受提交的任务时的拒绝策略</td>
</tr>
<tr>
<td align="left">unit</td>
<td align="left">TimeUnit</td>
<td align="left">keepAliveTime 的时间单位</td>
</tr>
</tbody></table>
<p>其中 <code>corePoolSize</code> 指的是核心线程数：线程池完成初始化后，默认情况下线程池中没有任何线程。线程池会等待有任务到来时再创建新线程去执行任务。在任务执行完后即使它们是空闲的也会保留下来。</p>
<p>同时线程池可能会在核心线程数的基础上额外增加一些线程，而总的线程数具有一个上限，即 <code>maxPoolSize</code>。</p>
<p><img data-src="https://s1.ax1x.com/2022/05/18/OoXzUU.png"></p>
<p>线程的添加规则如下：</p>
<ol>
<li>如果线程数小于 <code>corePoolSize</code>，即使其他工作线程都处于空闲状态也会创建一个新的线程来执行新任务。</li>
<li>如果线程数大于等于 <code>corePoolSize</code> 但少于 <code>maxPoolSize</code>，则将任务放入任务队列。</li>
<li>如果任务队列已满并且线程数小于 <code>maxPoolSize</code>，则创建一个新的线程来执行任务。</li>
<li>如果任务队列已满并且线程数大于等于 <code>maxPoolSize</code>，则拒绝该任务。</li>
</ol>
<p><img data-src="https://s1.ax1x.com/2022/05/18/Ooxi0x.png" alt="Ooxi0x.png"></p>
<p>由于线程池更倾向于使用更少的线程，因此若线程池当前线程数多余 <code>corePoolSize</code>，那么多余的线程在空闲 <code>keepAliveTime</code> 后将被终止，而 <code>keepAliveTime</code> 的单位就是通过 <code>unit</code> 参数来指定的。</p>
<p>新的线程是由 <code>ThreadFactory</code> 创建的，默认使用 <code>Executors.defaultThreadFactory()</code>。创建出来的线程都在同一个线程组，拥有同样的 NORM_PRIORITY 优先级并且都不是守护线程。如果指定使用某个<code>ThreadFactory</code> 就可以改变线程名、线程组、优先级、是否是守护线程等。通常情况下使用默认的 <code>ThreadFactory</code> 即可。</p>
<p>而 <code>workQueue</code> 就是工作队列，即线程等待队列，当线程池中无法分配线程执行任务时，就会将任务暂时存到等待队列中，直到有线程资源可用为止。有三种常见的队列：</p>
<ul>
<li><p>直接交接：<code>SynchronousQueue</code></p>
<p>它的 <code>capacity</code> 为 0，即当任务较少时可以用来简单地作为中转。</p>
</li>
<li><p>无界队列：<code>LinkedBlockingQueue</code></p>
<p>它不会被装满，<code>maxPoolSize</code> 对线程池不会产生影响。因此可以用来应对流量突增的情况。但可能对造成内存浪费或导致 OOM。</p>
</li>
<li><p>有界队列：<code>ArrayBlockingQueue</code></p>
<p>可以设置队列大小。</p>
</li>
</ul>
<p>另外还有个 <code>handle</code> 参数来指定线程池的拒绝策略。线程池的拒绝时机：</p>
<ol>
<li>当 <code>Executor</code> 关闭后，提交的新任务会被拒绝。</li>
<li>当 <code>Executor</code> 对最大线程和工作队列容量的使用有限制且已经饱和时提交的新任务会被拒绝。</li>
</ol>
<p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，可以采取的拒绝策略有：</p>
<ul>
<li><strong>AbortPolicy</strong>：当任务添加到线程池中被拒绝时，它将抛出 <code>RejectedExecutionException</code> 异常。（该策略下会直接丢弃任务并抛出 <code>RejectedExecutionException</code> 异常）。</li>
<li><strong>DiscardPolicy</strong>：当任务添加到线程池中被拒绝时，默认情况下它将丢弃被拒绝的任务。（即该策略下会直接丢弃任务，什么都不做）。</li>
<li><strong>DiscardOldestPolicy</strong>：当任务添加到线程池中被拒绝时，线程池会放弃等待队列中最旧的未处理任务，然后将被拒绝的任务添加到等待队列中（该策略下会抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列）。</li>
<li><strong>CallerRunsPolicy</strong>：不进入线程池执行，在这种方式中，任务将由调用者线程去执行。（用于被拒绝任务的处理程序，它直接在 <code>execute()</code> 方法的调用线程中运行被拒绝的任务。如果执行程序已关闭，则会丢弃该任务）。</li>
</ul>
</br>

<h4 id="通过-Executor-框架的工具类-Executors-来创建。"><a href="#通过-Executor-框架的工具类-Executors-来创建。" class="headerlink" title="通过 Executor 框架的工具类 Executors 来创建。"></a>通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来创建。</h4><p>手动创建线程池可以让我们更加明确线程池的运行规则，避免资源耗尽的风险。若自动创建（调用 JDK 封装好的构造函数）可能会带来一些问题。</p>
<blockquote>
<p>Executors 返回线程池对象的弊端如下：</p>
<ul>
<li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 <code>Integer.MAX_VALUE</code> ，可能堆积大量的请求，从而导致 OOM。</li>
<li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</li>
</ul>
</blockquote>
<ul>
<li><strong>FixedThreadPool</strong>：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li><strong>SingleThreadExecutor：</strong>该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li><strong>CachedThreadPool：</strong>该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li>
<li><strong>ScheduledThreadPool</strong>：该方法返回一个支持定时以及周期性地执行任务。</li>
<li><strong>WorkStealingPool</strong>： 与前四种线程池不同，通常来说，当这个任务可以产生子任务（如树的遍历、处理矩阵）时才适合使用这个线程池。这种线程池拥有一定的窃取能力，每一个线程之间会合作，任务会放在线程独有的队列而不是公共的队列中，线程之间会有互相帮助的现象。</li>
</ul>
</br>

<h3 id="如何停止线程池"><a href="#如何停止线程池" class="headerlink" title="如何停止线程池"></a>如何停止线程池</h3><ul>
<li><code>shutdown</code>：它可以安全地关闭一个线程池，调用 <code>shutdown()</code> 方法之后线程池并不是立刻就被关闭，因为这时线程池中可能还有很多任务正在被执行，或是任务队列中有大量正在等待被执行的任务。线程池会在执行完正在执行的任务和队列中等待的任务后才彻底关闭。调用 <code>shutdown()</code> 方法后如果还有新的任务被提交，线程池则会根据拒绝策略直接拒绝后续新提交的任务。</li>
<li><code>isShutdown</code>：可以使用 <code>isShutdown()</code> 方法返回 <code>true</code> 或 <code>false</code> 来判断线程池是否已经开始了关闭工作。注意：如果调用 <code>isShutdown()</code> 方法的返回的结果为 <code>true</code> 并不代表线程池此时已经彻底关闭了，这仅仅代表线程池开始了关闭的流程。也就是说，此时可能线程池中依然有线程在执行任务，队列里也可能有等待被执行的任务。</li>
<li><code>isTerminated</code>：要想得知整个线程池是否已经完全终止可以使用 <code>isTerminated()</code> 方法，当它返回 · 时不仅代表线程池已关闭，同时代表线程池中的所有任务都已经都执行完毕了。</li>
<li><code>shutdownNow</code>：在执行 <code>shutdownNow()</code> 方法之后，首先会给所有线程池中的线程发送 <code>interrupt</code> 中断信号，尝试中断这些任务的执行，然后会将任务队列中正在等待的所有任务转移到一个 <code>List</code> 中并返回，我们可以根据返回的任务 <code>List</code> 来进行一些补救的操作。</li>
<li><code>awaitTermination</code>：它本身并不是用来关闭线程池的，而是主要用来判断线程池状态的。调用 <code>awaitTermination</code> 方法后当前线程会尝试等待一段指定的时间，如果在等待时间内，线程池已关闭并且内部的任务都执行完毕了，也就是说线程池真正「终结」了，那么方法就返回 <code>true</code>，否则超时返回 <code>fasle</code>。</li>
</ul>
</br>

<h3 id="如何确定线程池的大小"><a href="#如何确定线程池的大小" class="headerlink" title="如何确定线程池的大小"></a>如何确定线程池的大小</h3><p>在前面我们使用 JDK 封装好的线程池的构造方法来创建线程池都会面临一些问题，为了尽量避免这些问题我们应该根据不同的业务场景自己设置线程池的参数。</p>
<p>最重要的是线程池大小的限定，合理地分配大小会使得线程池的执行效率事半功倍：</p>
<p>需要分析业务的类型</p>
<ul>
<li><p><strong>CPU 密集型：</strong>主要是执行计算任务，响应时间很快，CPU 一直在运行，这种任务 CPU 的利用率很高，线程数应该是根据 CPU 核心数来决定，最佳线程数为 CPU 核心数的 1-2 倍。</p>
</li>
<li><p><strong>IO 密集型：</strong>主要是进行 IO 操作，因为执行 IO 操作的时间比较长，如从硬盘读取数据等过程 CPU 会等待 IO 操作，很容易出现空闲状态而导致 CPU 的利用率不高。这种情况可以参考 Brain Goetz 推荐的计算方法：</p>
<p>线程数 &#x3D; CPU 核心数 * (1 + 平均等待时间&#x2F;平均工作时间)</p>
</li>
</ul>
</br>

<h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><h3 id="什么是原子类"><a href="#什么是原子类" class="headerlink" title="什么是原子类"></a>什么是原子类</h3><p>在 <code>java.util.concurrent.atomic</code> 包下，有一系列 <code>Atomic</code> 开头的类，统称为原子类。</p>
<p>原子类的作用和锁类似，是为了保证并发情况下线程安全。Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行时，一个操作一旦开始，就不会被其他线程干扰。所以，原子类就是具有原子&#x2F;原子操作特征的类。</p>
</br>

<h3 id="原子类类型"><a href="#原子类类型" class="headerlink" title="原子类类型"></a>原子类类型</h3><p><strong>基本类型原子类</strong></p>
<ul>
<li><code>AtomicInteger</code></li>
<li><code>AtomicLong</code></li>
<li><code>AtomicBoolean</code></li>
</ul>
<p><strong>数组类型原子类</strong></p>
<ul>
<li><code>AtomicIntegerArray</code></li>
<li><code>AtomicLongArray</code></li>
<li><code>AtomicReferenceArray</code></li>
</ul>
<p><strong>引用类型原子类</strong></p>
<ul>
<li><code>AtomicReference</code></li>
<li><code>AtomicStampedReference</code></li>
<li><code>AtomicMarkableReference</code></li>
</ul>
<p><strong>对象的属性修改类型原子类</strong></p>
<ul>
<li><code>AtomicIntegerFieldUpdater</code></li>
<li><code>AtomicLongFieldUpdater</code></li>
<li><code>AtomicReferenceFieldUpdater</code></li>
</ul>
<br>

<h3 id="原子类的使用"><a href="#原子类的使用" class="headerlink" title="原子类的使用"></a>原子类的使用</h3><p>以 <code>AtomicInteger</code> 为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">()</span>					<span class="comment">// 获取当前值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">()</span>				<span class="comment">// 获取当前值并设置新的值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span>		<span class="comment">// 获取当前值并自增</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span>		<span class="comment">// 获取当前值并自减</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span>	<span class="comment">// 获取当前值并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span>	<span class="comment">// 如果当前值与 expect 一致，则以原子的方式将该值更新为 update</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> newValue)</span>	<span class="comment">//最终设置为 newValue，使用后可能导致其他线程在之后的一小段时间内还是可以读到旧的值</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>AtomicInteger</code> 之后，不用对 <code>increment()</code> 方法加锁也可以保证线程安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicIntegerTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h3 id="什么是-CAS"><a href="#什么是-CAS" class="headerlink" title="什么是 CAS"></a>什么是 CAS</h3><p>CAS（Compare And Swap）是一种无锁算法，它并不会为对象加锁，而是在执行的时候，判断当前数据的值是否与预期的值相同。如果是就正常进行替换，如果不是就替换失败。</p>
<p>如有 2 个线程都需要修改变量 <code>i = 10</code> 的值。线程 1 要将其修改为 20，线程 2 要将其修改为 30。如果它们都使用 CAS 算法，那么就不会加锁访问 <code>i</code>，而是直接尝试修改 <code>i</code> 的值。但在修改时需要确认 <code>i</code> 还是不是 10，如果是则表示其他线程还没对其进行修改，如果不是则说明其他线程已经将其修改，此时不能完成修改任务，修改失败。</p>
<p><img data-src="https://s1.ax1x.com/2022/05/21/OjaKns.md.png" alt="OjaKns.md.png"></p>
<p>CAS 有三个操作数：内存值 V、预期值 A、要修改的值 B。当且仅当预期值 A 和内存值 V 相同时才将内存值修改为 B，否则放弃修改，最后返回现在的 V 值。</p>
<p>在 CPU 中，CAS 操作使用的是 <code>cmpxchg</code> 指令，能够从最底层硬件层面得到效率的提升。</p>
<br>

<h3 id="CAS-存在的问题"><a href="#CAS-存在的问题" class="headerlink" title="CAS 存在的问题"></a>CAS 存在的问题</h3><h4 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h4><p>ABA 问题是指在 CAS 操作时，其他线程将变量值 A 改为了 B，然后又被改回了 A。等到本线程使用期望值 A 与当前变量进行比较时，发现变量 A 没有变，于是 CAS 就将 A 值进行了交换操作，但是实际上该值已经被其他线程改变过。</p>
<p><img data-src="https://s2.loli.net/2022/03/25/hnHQdtLoxcOpUjE.png"></p>
<p>解决方案：</p>
<p>可以沿用 MySQL 中版本号的方法： 在变量前面加上版本号，每次变量更新的时候变量的版本号都 +1，即 A -&gt; B -&gt; A 就变成了 1A -&gt; 2B -&gt; 3A。只要变量被某一线程修改过，变量对应的版本号就会发生递增变化，从而解决了 ABA 问题。</p>
<p>同时 JUC 也提供了 <code>AtomicStampedReference\&lt;E&gt;</code> 来实现带版本号的引用类型，只需要每次操作都记录版本号且版本号不重复，就可以解决 ABA 问题。</p>
<br>

<h4 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h4><p>自旋 CAS 如果长时间不成功，会给 CPU 带来非常大的执行开销 。在 Java 中有很多的并发框架都使用了自旋 CAS 来获取相应的锁，会一直循环直到获取到相应的锁后，然后执行相应的操作。</p>
<br>

<h3 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h3><p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但从 JDK1.5 开始，提供了 <code>AtomicReference</code> 类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行 CAS 操作。所以我们可以使用锁或者利用 <code>AtomicReference</code> 类把多个共享变量合并成一个共享变量来操作。</p>
<br>

<h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><p>过时的并发容器 <code>Vector</code> 和 <code>Hashtable</code> 为了实现线程安全而在方法上都加上了 <code>synchronized</code>，这样就导致它们的性能不高，对于现在的高并发场景它们并不够用，因此被淘汰了。<code>Collections</code> 工具类也提供了如 <code>synchronizedList</code> 等工具来让线程不安全的集合变为线程安全，虽然它使用同步代码块的方式比直接对整个方法加锁更高效，但仍不能满足当前的高并发场景。现在的并发容器主要有： </p>
<ul>
<li>**<code>ConcurrentHashMap</code>**：线程安全的 <code>HashMap</code>。</li>
<li>**<code>CopyOnWriteArrayList</code>**：线程安全的 <code>List</code>。</li>
<li>**<code>BlockingQueue</code>**：接口，表示阻塞队列，非常适合作为数据共享的通道。</li>
<li><code>ConcurrentLinkedQueue</code>：高效的非阻塞并发队列，使用链表实现。可以看作是一个线程安全的 <code>LinkedList</code>。</li>
<li><code>ConcurrentSkipListMap</code>：是一个 <code>Map</code>，使用跳表的数据结构进行快速查找。</li>
</ul>
</br>

<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h3 id="AQS-组件"><a href="#AQS-组件" class="headerlink" title="AQS 组件"></a>AQS 组件</h3><p>线程默认是由线程调度器执行的，若要指定<strong>线程的执行顺序</strong>就需要使用控制并发流程的工具类，它能帮助我们让线程之间合作。让线程之间相互配合，来满足业务逻辑。</p>
<table>
<thead>
<tr>
<th>类</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Semaphore</td>
<td>信号量，可以通过“许可证”的数量来保证线程之间的配合。</td>
<td>线程只有在拿到”许可证“后才能继续运行。相较于其他同步器，更加灵活。</td>
</tr>
<tr>
<td>CyclicBarrier</td>
<td>线程会等待，直到足够多线程达到了事先规定的数目。一旦达到出发条件就可以进行下一步的动作。</td>
<td>适用于线程之间互相等待处理结果就绪的场景。</td>
</tr>
<tr>
<td>CountDownLatch</td>
<td>与 CyclicBarrier 类似，数量递减到 0 时触发动作。</td>
<td>不可重复使用</td>
</tr>
</tbody></table>
<br>

<p><code>CountDownLatch</code> 即倒数门闩。在构造 <code>CountDownLatch</code> 时需要传入一个整数 <code>n</code>，在这个整数倒数到 0 之前，主线程需要等待在门口，而这个倒数过程则是由各个执行线程驱动的，每个线程执行完一个任务倒数一次。<code>CountDownLatch</code> 的作用就是等待其他的线程都执行完任务，必要时可以对各个任务的执行结果进行汇总，然后主线程才继续往下执行。</p>
<p><code>Semaphore</code> 可以用来限制或管理数量有限的资源的使用情况。类似于许可证，获取到许可证才可以执行。信号量的作用是维护一个许可证的计数，线程获取许可证并使信号量剩余的许可证数量减 1，线程释放一个许可证则信号量许可证数量加 1。当信号量所拥有的许可证数量为 0 时，下一个获取许可证的线程就需要等待，直到有另外的线程释放许可证。</p>
<p><code>Condition</code> 又称为条件对象，<code>Condition</code> 接口是为了与 <code>Lock</code> 配合实现等待&#x2F;通知模式, 可以将 <code>Condition</code> 等待通知和 <code>Lock</code> 的关系与 Object<code> </code>的等待通知和 <code>synchronized</code> 的关系类比:</p>
<ul>
<li><code>synchronized</code> 是通过锁对象即 <code>Object</code> 的 <code>wait()</code> 和 <code>notify()</code> 实现等待通知</li>
<li><code>Lock</code> 则可以通过 <code>Condition</code> 的 <code>await()</code> 和 <code>signal()</code> 实现等待通知</li>
</ul>
<p>当线程 1 需要等待某个条件时就执行 <code>condition.await()</code> 方法，一旦执行了 <code>await()</code> 方法线程就会进入阻塞状态。当另一个线程 2 执行完对应的条件后会去执行 <code>condition.signal()</code> 方法，这时 JVM 就会从被阻塞的线程中找到等待该 <code>condition</code> 的线程，当线程 1 收到可执行信号时它的线程状态就会变成 Runnable 可执行状态。</p>
<p><code>CyclicBarrier</code> 与 <code>CountDownLatch</code> 类似，都可以阻塞一组线程。当有大量线程相互配合，分别计算不同任务，并且需要最后统一汇总时，可以使用 <code>CyclicBarrier</code> 。<code>CycliBarrier</code> 可以构造一个集结点，当某一个线程执行完毕它就会到集合点等待，直到所有线程都到了集结点，那么该栅栏就被撤销，所有线程统一出发，继续执行剩下的任务。</p>
</br>

<h3 id="什么是-AQS"><a href="#什么是-AQS" class="headerlink" title="什么是 AQS"></a>什么是 AQS</h3><p>AQS 全称是 <code>AbstractQueuedSynchronizer</code>，中文译为<strong>抽象队列式同步器</strong>。</p>
<p>之前的 <code>ReentantLock</code> 和 <code>Semaphore</code> 十分类似，它们都像是一个闸门，每次都只允许一定数量的线程通过，<code>ReentrantLock</code> 只允许一个而 <code>Semaphore</code> 可以允许规定数量的线程通过。同时当线程到达时，<code>ReentrantLock</code> 通过<code>lock()</code> 方法、<code>Semaphore</code> 通过 <code>acquire()</code> 方法让线程获取资源。AQS 对于 JUC 并发包非常重要， JUC 包中的 <code>ReentrantLock</code>、<code>Semaphore</code>、<code>ReentrantReadWriteLock</code>、<code>CountDownLatch</code> 等等几乎所有的类都是基于 AQS 实现的。</p>
<p>比如在 <code>Semaphore</code> 内部有一个 <code>Sync</code> 类，它继承自 AQS：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Semaphore</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3222578661600680210L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1192457210091910933L</span>;</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>CountDownLatch</code> 也是如此：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatch</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">4982264981922014374L</span>;</span><br><span class="line">      </span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AQS 就是一个用于构建锁、同步器、协作工具类的工具类（框架）。AQS 帮助实现了：</p>
<ul>
<li>同步状态的原子性管理</li>
<li>线程的阻塞与唤醒</li>
<li>队列的管理</li>
</ul>
<p>因此，AQS 将这些功能实现后，其他类只需要关心具体的业务逻辑而不需要每个类都单独实现这些功能了。AQS 的实现类有：</p>
<p><img data-src="https://s1.ax1x.com/2022/05/26/XELtXD.png" alt="XELtXD.png"></p>
<br>

<h3 id="AQS-内部原理"><a href="#AQS-内部原理" class="headerlink" title="AQS 内部原理"></a>AQS 内部原理</h3><p>AQS 最核心的三大部分：</p>
<ul>
<li><code>state</code> 状态</li>
<li>控制线程抢锁和配合的 FIFO 队列</li>
<li>期望协作工具类去实现的获取&#x2F;释放等重要方法</li>
</ul>
<h4 id="state-状态"><a href="#state-状态" class="headerlink" title="state 状态"></a>state 状态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>state</code> 的具体含义，会根据具体实现类的不同而不同。比如在 <code>Semaphore</code> 里它表示”剩余的许可证的数量“，而在 <code>CountDownLatch</code> 里，它表示”还需要倒数的数量”。</p>
<p><code>state</code> 是 <code>volatile</code> 修饰的，会被并发地修改，因此所有修改 <code>state</code> 的方法都需要保证线程安全，如 <code>getState</code>、<code>setState</code> 以及 <code>compareAndSetState</code> 操作来读取和更新这个状态。这些方法都依赖于 <code>Atomic</code> 包的支持：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>ReentrantLock</code> 中，<code>state</code> 用来表示锁的占有情况，包括可重入计数，当 <code>state</code> 的值为 0 时标识该 <code>Lock</code> 不被任何线程所占有。</p>
<br>

<h4 id="FIFO-队列"><a href="#FIFO-队列" class="headerlink" title="FIFO 队列"></a>FIFO 队列</h4><p>这个队列用来存放等待的线程。AQS 像是个排队管理器，当多个线程争用同一把锁时，必须有排队机制将没能获取到锁的线程串在一起。当锁释放时，锁管理器就会挑选一个合适的线程来占有这个刚刚释放的锁。</p>
<p>AQS 会维护一个等待的线程队列，把线程都放到这个队列里，且这个队列是双向链表的形式：</p>
<p><img data-src="https://s1.ax1x.com/2022/05/26/XEjFkd.png" alt="XEjFkd.png"></p>
<p>其中 <code>head</code> 是持有锁的线程，其余 <code>node</code> 即为等待队列中的其他线程。</p>
<br>

<h4 id="获取-x2F-释放的方法"><a href="#获取-x2F-释放的方法" class="headerlink" title="获取&#x2F;释放的方法"></a>获取&#x2F;释放的方法</h4><p>这里的获取和释放方法是利用 AQS 的协作工具类中最重要的方法，是由协作类实现的，并且含义各不相同。</p>
<ul>
<li><p>获取方法</p>
<p>获取操作依赖 <code>state</code> 变量，经常会阻塞(如获取不到锁时)，在 <code>Semaphore</code> 中获取就是 <code>acquire()</code> 方法，作用是获取一个许可证，能否获取到取决于 <code>state</code> 的值。而在 <code>CountDownLatch</code> 中获取是 <code>await()</code> 方法，作用是等待直到倒数结束。</p>
</li>
<li><p>释放方法</p>
<p>释放操作不会阻塞，在 <code>Semaphore</code> 中，释放就是 <code>release()</code> 方法，作用是释放一个许可证。在 <code>CountDownLatch</code> 中，释放是 <code>countDown()</code> 方法，作用是倒数 1 个数。</p>
</li>
</ul>
<br>

<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="MySQL-基础概念"><a href="#MySQL-基础概念" class="headerlink" title="MySQL 基础概念"></a>MySQL 基础概念</h2><h3 id="什么是关系型数据库"><a href="#什么是关系型数据库" class="headerlink" title="什么是关系型数据库"></a>什么是关系型数据库</h3><p>关系型数据库就是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系。在关系型数据库中，数据都被存放在了各种表中，表中的每一行就存放着一条数据。大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且大部分关系型数据库都支持事务的四大特性(ACID)。</p>
</br>

<h2 id="MySQL-存储引擎"><a href="#MySQL-存储引擎" class="headerlink" title="MySQL 存储引擎"></a>MySQL 存储引擎</h2><p>MySQL 的核心就是存储引擎。InnoDB 事务型数据库的首选引擎，支持事务、支持行锁定和外键。</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>MylSAM</th>
<th>MEMORY</th>
<th>InnoDB</th>
<th>Archive</th>
</tr>
</thead>
<tbody><tr>
<td>存储限制</td>
<td>256TB</td>
<td>RAM</td>
<td>64TB</td>
<td>None</td>
</tr>
<tr>
<td>支持事务</td>
<td>No</td>
<td>No</td>
<td><strong>Yes</strong></td>
<td>No</td>
</tr>
<tr>
<td>支持全文索引</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>支持树索引</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>支持哈希索引</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>支持数据缓存</td>
<td>No</td>
<td>N&#x2F;A</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>支持外键</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
</tbody></table>
</br>

<h3 id="MyISAM-与-InnoDB-的区别"><a href="#MyISAM-与-InnoDB-的区别" class="headerlink" title="MyISAM 与 InnoDB 的区别"></a>MyISAM 与 InnoDB 的区别</h3><ul>
<li>MyISAM 只有表级锁，而 InnoDB 支持行级锁和表级锁，默认为行级锁。</li>
<li>MyISAM 不提供事务支持，InnoDB 提供事务支持。</li>
<li>MyISAM 不支持外键，而 InnoDB 支持。</li>
<li>MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。</li>
<li>MyISAM 不支持 MVCC，而 InnoDB 支持。</li>
<li>InnoDB 中数据文件本身就是索引文件，而 MyISAM 索引文件和数据文件是分离的。</li>
</ul>
</br>

<h2 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="MySQL 事务"></a>MySQL 事务</h2><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong>数据库事务可以保证多个对数据库的操作构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：<strong>要么全部执行成功,要么全部不执行</strong>。</p>
<p>关系型数据库事务都有 <strong>ACID</strong> 特性：</p>
<ul>
<li>原子性(Atomicity)：事务中包含的各项操作在一次执行过程中要么都成功，要么都失败。</li>
<li>一致性(Consistency)：事务的执行不能破坏数据库数据的一致性，一个事务在执行前后数据库都必须处以一致性状态。</li>
<li>隔离性(Isolation)：在并发环境中并发的事务是互相隔离的，一个事务的执行不能被其它事务干扰。</li>
<li>持久性(Duration)：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
<p><strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的</strong>。</p>
</br>

<h3 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h3><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题：</p>
<ul>
<li><strong>脏读(Dirty read):</strong> 脏读指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</li>
<li><strong>丢失修改(Lost to modify):</strong> 丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。</li>
<li><strong>不可重复读(Unrepeatable read):</strong> 不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一个事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</li>
<li><strong>幻读(Phantom read):</strong> 幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</li>
</ul>
<p>产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p>
</br>

<h3 id="不可重复读和幻读的区别"><a href="#不可重复读和幻读的区别" class="headerlink" title="不可重复读和幻读的区别"></a>不可重复读和幻读的区别</h3><ul>
<li>不可重复读的重点是内容修改或者记录减少，如多次读取一条记录发现其中某些记录的值被修改。</li>
<li>幻读的重点在于记录新增，如多次执行同一条查询语句时发现查到的记录增加了。</li>
</ul>
<p>幻读其实可以看作是不可重复读的一种特殊情况，单独区分幻读的原因是解决幻读和不可重复读的方案不一样。</p>
</br>

<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><ul>
<li>**READ-UNCOMMITTED(读未提交)**：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>
<li>**READ-COMMITTED(读提交)**：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li>
<li>**REPEATABLE-READ(可重复读)**：读取数据时只会读取到本事务开始时的数据状态，可以阻止脏读和不可重复读，但幻读仍有可能发生。可重复读是 MySQL 默认的隔离级别。</li>
<li>**SERIALIZABLE(串行化)**：对于一条数据，同时只能有一个事务进行写操作。串行化事务的隔离性最高，性能最差，因此很少采用。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">READ-UNCOMMITTED</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">READ-COMMITTED</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">REPEATABLE-READ</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">SERIALIZABLE</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
</br>

<h2 id="MySQL-锁"><a href="#MySQL-锁" class="headerlink" title="MySQL 锁"></a>MySQL 锁</h2><h3 id="表级锁和行级锁的区别"><a href="#表级锁和行级锁的区别" class="headerlink" title="表级锁和行级锁的区别"></a>表级锁和行级锁的区别</h3><p>MyISAM 仅支持表级锁，一锁就锁整张表，这在并发写的情况下性非常差。</p>
<p>InnoDB 支持表级锁和行级锁，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。</p>
<p><strong>表级锁和行级锁对比</strong>：</p>
<ul>
<li><strong>表级锁：</strong> MySQL 中锁定粒度最大的一种锁，是针对非索引字段加的锁，对当前操作的整张表加锁，开销小加锁快，不会出现死锁。其锁定粒度大，发生锁冲突的概率最高，并发度最低。MyISAM 和 InnoDB 都支持表级锁。</li>
<li><strong>行级锁：</strong> MySQL 中锁定粒度最小的一种锁，是针对索引字段加的锁，只针对当前操作的行记录进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li>
</ul>
</br>

<h3 id="共享锁和排他锁"><a href="#共享锁和排他锁" class="headerlink" title="共享锁和排他锁"></a>共享锁和排他锁</h3><p>无论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类：</p>
<ul>
<li>**共享锁(S 锁)**：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li>
<li>**排他锁(X 锁)**：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。</li>
</ul>
<p>排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">S 锁</th>
<th align="left">X 锁</th>
</tr>
</thead>
<tbody><tr>
<td align="left">S 锁</td>
<td align="left">不冲突</td>
<td align="left">冲突</td>
</tr>
<tr>
<td align="left">X 锁</td>
<td align="left">冲突</td>
<td align="left">冲突</td>
</tr>
</tbody></table>
<p>由于 MVCC 的存在，对于一般的 <code>SELECT</code> 语句 InnoDB 不会加任何锁。</p>
</br>

<h3 id="InnoDB-的行锁"><a href="#InnoDB-的行锁" class="headerlink" title="InnoDB 的行锁"></a>InnoDB 的行锁</h3><p>MySQL InnoDB 支持三种行锁定方式：</p>
<ul>
<li>**记录锁(Record Lock)**：也被称为记录锁，属于单个行记录上的锁。</li>
<li>**间隙锁(Gap Lock)**：锁定一个范围，不包括记录本身。</li>
<li>**临键锁(Next-key Lock)**：Record Lock + Gap Lock，锁定一个范围，包含记录本身。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li>
</ul>
</br>

<h2 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h2><h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h3><p>索引（Index）是数据库中对某一列或多个列的值进行<strong>预排序</strong>的数据结构。索引可以理解为数据的“目录”。在 InnoDB 中，主键是一个特殊的索引。ID 是主键不是主索引，主索引是主键排序后组成的索引。</p>
</br>

<h3 id="索引算法"><a href="#索引算法" class="headerlink" title="索引算法"></a>索引算法</h3><ul>
<li>线性查找(Linear Search)</li>
</ul>
<p><img data-src="https://s1.ax1x.com/2022/05/13/ODF3Pf.png" alt="ODF3Pf.png"></p>
<p>线性查找的时间复杂度为 <code>O(N)</code>。由于线性查找是从第一个数据开始逐个匹配，因此线性查找的效率比较低。</p>
<ul>
<li>二分查找(Binary Search)</li>
</ul>
<p><img data-src="https://s1.ax1x.com/2022/05/13/ODF2L9.png" alt="ODF2L9.png"></p>
<p>二分查找的时间复杂度为 <code>O(logN)</code>。二分查找取出有序数列的中点位置作为比较对象，根据中点位置数据的大小选取一半数据作为新的数列，这样每次可以减少一半数据量。</p>
<p>但二分查找需要在有序的前提且必须知道数列的中点的位置。实际情况中，表中的数据在磁盘中是随机读写的并不是连续读写的，我们无从得知中点的位置。</p>
<ul>
<li>二叉查找树(Binary Search Tree)</li>
</ul>
<p><img data-src="https://s1.ax1x.com/2022/05/13/ODkfXQ.png"></p>
<p>二叉查找树的时间复杂度为 <code>O(logN)</code>。二叉查找树与二分查找相似，根据当前结点与被查找的数的大小选取左或右子树。使用了经典的二叉树数据结构，从根节点开始查找。当二分查找树为满树时，查找的效率与二分查找相同，且不会出现找不到中点的情况。</p>
<p>但考虑下面这种情况：</p>
<p><img data-src="https://s1.ax1x.com/2022/05/13/ODAl38.png"></p>
<p>当数据大小递增时，二分查找树就会退化成线性查找。此时最坏情况的时间复杂度为 <code>O(N)</code>。</p>
<ul>
<li>平衡二叉树(AVL Tree)</li>
</ul>
<p><img data-src="https://s1.ax1x.com/2022/05/13/ODA03T.png"></p>
<p>平衡二叉树的时间复杂度为 <code>O(logN)</code>。在查找时，平衡二叉树与二叉查找树相同。在增删改时，平衡二叉树会通过旋转操作来维护树的平衡，AVL 树可以保证不会退化成线性查找。</p>
<p>但平衡二叉树一个结点所包含但数据量太少，会造成磁盘空间的浪费且读写效率低。</p>
<ul>
<li>B-Tree</li>
</ul>
<p><img data-src="https://s1.ax1x.com/2022/05/13/ODEyz8.png"></p>
<p>B 树是线性数据结构和树的结合。在节点内部的查找为线性查找，在节点外部的查找为树结果查找。B 树通过多数据结点大大降低了树的高度，且 B 树不需要旋转就可以保证树的平衡。</p>
<p>但 B 树对于范围查找的效率是非常低的，每次查找都需要从根节点开始一层层查找。</p>
<ul>
<li>B+ Tree</li>
</ul>
<p><img data-src="https://s1.ax1x.com/2022/05/13/ODZYHH.png" alt="ODZYHH.png"></p>
<p>B+ 树是由 B 树发展而来的一种数据结构。B+ 树的所有数据均在叶子结点，且这些数据形成了一个线性表。非叶子节点并不存储真正的数据而是作为了索引。</p>
<p><strong>B+ 树是目前最主流的数据库索引算法</strong>，它由线性表、二叉树、B 树发展而来，集成了线性表、平衡二叉树、B 树的优势。</p>
</br>

<h3 id="InnoDB-索引即数据"><a href="#InnoDB-索引即数据" class="headerlink" title="InnoDB 索引即数据"></a>InnoDB 索引即数据</h3><h4 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+ 树索引"></a>B+ 树索引</h4><p>InnoDB 使用 B+ 树作为索引的数据结构。B+ 树索引在数据库中有一个特点就是高扇出，树的高度一般是 2<del>4 层，即查找某一个记录最多只需要 2</del>4 次 IO。</p>
<p>InnoDB 中 B+ 树索引可以分为聚簇索引（主索引）和辅助索引。但不管聚集索引还是辅助索引，其内部都是 B+ 树，即高度平衡的。不同的是，聚集索引叶子节点存放着所有的数据，辅助索引叶子节点存放的只是一个指向聚集索引的指针。</p>
<br>

<h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>InnoDB 存储引擎是索引组织表，即表中的数据按照主键顺序存放。而聚簇索引（Clustered Index）就是按照每张表的<strong>主键</strong>构造一棵 B+ 树，同时<strong>叶子节点中的存放的即为整张表的行记录数据</strong>，<strong>每张表只有一个聚集索引</strong>，也将聚簇索引的叶子节点称为数据页（Page）。聚簇索引的这个特性决定了索引组织表中数据也是索引的一部分。同 B+ 树数据结构一样，每个数据页都通过一个双向链表来连接。</p>
<p><img data-src="https://s1.ax1x.com/2022/05/13/OrUdQU.png" alt="OrUdQU.png"></p>
<p>InnoDB 使用 B+ 树实现的聚簇索引与 B+ 树不太相同，每个结点都具有下限指针和上限指针，在叶子结点的上层结点之间还有双向链表结构，结点之内数据条目之间为单向链表。并且非叶子结点中两个数据只有两个指针。</p>
<p>当需要查询时，会从根节点根据范围找到下一步需要查询的页号，再从该页的下限指针开始继续查询，直到到达叶子结点并查询成功。</p>
<p><strong>所谓索引即数据，是把数据直接记录在了主索引中。</strong></p>
<br>

<h4 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h4><p>辅助索引（Secondary Index）即非聚集索引，其相较于聚集索引，辅助索引叶子节点并不包含行记录的全部数据。叶子节点除列包含键值以外，每个叶子节点中的索引行中还包含了一个书签。该书签用来告诉 InnoDB 存储引擎哪里可以找到与索引相对应的行数据。由于 InnoDB 存储引擎是索引组织表，因此 InnoDB 存储引擎的辅助索引的书签就是相应行数据的聚集索引键。</p>
<p>使用辅助索引查找数据需要两个步骤：</p>
<ol>
<li>找到辅助索引的位置，辅助索引给出目标数据的聚集索引的位置</li>
<li>根据这个聚簇索引来找到对应数据行（回表）</li>
</ol>
<br>

<h3 id="索引的“左侧用法”"><a href="#索引的“左侧用法”" class="headerlink" title="索引的“左侧用法”"></a>索引的“左侧用法”</h3><p><strong>带头大哥不能死，中间兄都不能断，索引列上无操作，范围右边全失效，like百分加右边，字符串中有引号</strong></p>
<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>联合索引指使用两个及以上字段生成的索引。对于联合索引，MySQL 从左到右地使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。联合索引可以加速“最左前缀”的查询，可以替代最左侧字段的单独索引。</p>
<p><img data-src="https://s1.ax1x.com/2022/05/13/Oslk7V.png" alt="Oslk7V.png"></p>
<p>联合索引首先按最左侧字段排序，因此可以替代最左侧字段的单独索引。在联合索引匹配过程中，首先会将联合索引中的第一个索引条件和节点中的第一个索引列进行匹配。如果匹配成功，那么接着匹配第二个索引条件和第二个索引列。依次类推，直到所有的索引条件都完成匹配。</p>
<br>

<h4 id="字符串的前缀索引"><a href="#字符串的前缀索引" class="headerlink" title="字符串的前缀索引"></a>字符串的前缀索引</h4><p>前缀索引指定义字符串的一部分当做索引，而不是把整个字符串当做索引，这样可以节省空间。如使用邮箱作为索引则可以省略邮箱的后缀。如果前缀区分度太小，可以考虑两种办法：</p>
<ul>
<li>倒序存储</li>
<li>新建 Hash 字段</li>
</ul>
<p><code>ALTER TABLE USER ADD INDEX email_index(email(6))</code></p>
<br>

<h4 id="字符串-Like"><a href="#字符串-Like" class="headerlink" title="字符串 Like"></a>字符串 Like</h4><p>字符串的左或者左右模糊匹配会使索引失效（<code>%xxx%</code>、<code>%xxx</code>）。这是<strong>因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。</strong></p>
<br>

<h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><ul>
<li><p>在 MySQL 中对索引字段做函数操作，优化器会放弃索引。</p>
</li>
<li><p>以 <code>%</code> 开头的 <code>like</code> 模糊查询。因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。</p>
</li>
<li><p>字符串不加单引号。MySQL 中若出现字符串与数字比较，会将字符串转换为数字。</p>
</li>
<li><p>隐式字符编码转换。在 MySQL 中，utf8 与 utf8mb4 字段比较时会把 utf8 转换为 utf8mb4 编码。</p>
</li>
<li><p>用 <code>or</code> 分隔的条件，如果 <code>or</code> 前的条件中的列有索引，而后面的列中没有索引。</p>
</li>
</ul>
<br>

<h2 id="MySQL-日志"><a href="#MySQL-日志" class="headerlink" title="MySQL 日志"></a>MySQL 日志</h2><h3 id="日志体系"><a href="#日志体系" class="headerlink" title="日志体系"></a>日志体系</h3><p>MySQL 为了满足主从复制、事务等功能实现了复杂的日志体系。如 Server 层产生的 binlog，主要用于实现数据的复制。InnoDB 产生的 undo log、redo log 主要用于实现事务的 ACID。MySQL 的日志体系主要不是用来看的，而是运行时必要的资源。</p>
<ul>
<li>binlog：Server 层产生的逻辑日志（更新记录）</li>
<li>redo log：InnoDB 产生的物理日志，用来保证持久化（D）</li>
<li>undo log：InnoDB 产生的逻辑日志，用来保证原子性、隔离性（A、I）</li>
</ul>
</br>

<h3 id="binlog-归档日志"><a href="#binlog-归档日志" class="headerlink" title="binlog 归档日志"></a>binlog 归档日志</h3><p>binlog <strong>主要记录数据库的操作变化情况</strong>，内容包括数据库所有的更新操作。所有涉及数据变动的操作，都要记录进 binlog 日志中，binlog 被记录在专门的文件中。</p>
<p>因此，有了 binlog 就可以很方便的对数据进行复制和备份，因而也<strong>常用作主从库的同步</strong>。主数据库将所有涉及数据变动记录到 binlog，从数据库读取 binlog 更新。同时由于 binlog 完整地记录了数据库每次的数据操作，因此也可作为数据闪回的手段。</p>
<br>

<h3 id="undo-log-回滚日志"><a href="#undo-log-回滚日志" class="headerlink" title="undo log 回滚日志"></a>undo log 回滚日志</h3><p>undo log 日志的作用是对数据进行回滚，位于表空间的 undo segment 中。当事务对数据库进行修改时，InnoDB 会生成对应的 undo log 日志。如果事务执行失败或调用了 rollback，导致事务需要回滚时就可以利用 undo log 中的信息将数据回滚到修改之前的样子。</p>
<p>undo log 记录的是回滚时需要执行的具体操作而不是当前事务执行了什么操作。当发生回滚时，InnoDB 会根据undo log 日志中的记录做与之前相反的工作。比如对于每个数据插入操作（insert），回滚时会执行数据删除操作（delete）；对于每个数据删除操作（delete），回滚时会执行数据插入操作（insert）；对于每个数据更新操作（update），回滚时会执行一个相反的数据更新操作（update），把数据改回去。</p>
<br>

<h3 id="redo-log-重做日志"><a href="#redo-log-重做日志" class="headerlink" title="redo log 重做日志"></a>redo log 重做日志</h3><p>redo log 是 InnoDB 产生的物理日志，用于记录数据页的变化。当修改数据页时，内存中的数据更新后 redo log 会记录数据页的具体变化，之后再根据 redo log 中记录的变化来将数据写入磁盘中持久化。因此，记录 redo log 即可视为数据已经更新。</p>
<p>redo log 存放在 4 个 1GB 文件中并且是循环写入的：</p>
<p><img data-src="https://s1.ax1x.com/2022/05/14/O627TI.png"></p>
<ul>
<li><code>write pos</code>：当前日志写入点</li>
<li><code>check point</code>：擦除点，当数据更新到硬盘时擦除</li>
</ul>
<p><code>write pos</code> 到 <code>check point</code> 之间的部分是 redo log 空余部分，用于记录新的记录。<code>check point</code> 到 <code>write pos</code> 之间是 redo log 待落盘的数据页更改记录。</p>
<p>当 <code>write pos</code> 追上 <code>check point</code> 时，会先推动 <code>check point</code> 向前移动，空出位置再记录新的日志。</p>
<p>启动 InnoDB 时，不管上次是正常关闭还是异常关闭，总是会进行恢复操作。因为 redo log 记录的是数据页的物理变化，因此恢复的时候速度比逻辑日志(如 binlog)要快很多。</p>
<p>重启 InnoDB 时，首先会检查磁盘中数据页的 LSN ，如果数据页的 LSN 小于日志中的 LSN ，则会从 <code>check point</code> 开始恢复。如果在宕机前正处于 <code>checkpoint</code> 的刷盘过程，且数据页的刷盘进度超过了日志页的刷盘进度，此时会出现数据页中记录的 LSN 大于日志中的 LSN，这时超出日志进度的部分将不会重做，因为这本身就表示已经做过的事情，无需再重做。 </p>
<br>

<h3 id="redo-log-与-binlog-区别"><a href="#redo-log-与-binlog-区别" class="headerlink" title="redo log 与 binlog 区别"></a>redo log 与 binlog 区别</h3><ol>
<li>redo log 是 InnoDB 引擎特有的，提供了系统 crash-safe 恢复能力。binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li>
<li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”。binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID&#x3D;2 这一行的 c 字段加 1 ”。</li>
<li>redo log 是循环写的，空间固定会用完。binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>
</ol>
<br>

<h3 id="数据更新流程"><a href="#数据更新流程" class="headerlink" title="数据更新流程"></a>数据更新流程</h3><p><img data-src="https://s1.ax1x.com/2022/05/14/O6fYTA.png" alt="O6fYTA.png"></p>
<p>比如执行 <code>update T set c=c+1 where ID = 2</code> 语句：</p>
<ol>
<li>执行器先找引擎取 <code>ID=2</code> 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 <code>ID=2</code> 这一行所在的数据页本来就在内存中，就直接返回给执行器。否则需要先从磁盘将 <code>ID=2</code> 这一行所在的数据页读入内存，然后从页中取出行数据。 注意加载缓存的单位是 page 而非行。</li>
<li>修改行数据。</li>
<li>记录 undo-log 日志回滚链。</li>
<li>调用执行引擎更新内存数据。</li>
<li>发起写 redo log 日志，将修改操作写到 redo log buffer 中。日志属于 prepare 状态，此时就告诉执行器可以递交事务了。此时整个事务处于非 commit 状态。</li>
<li>执行器生成这个操作的 binlog，并把 binlog 写入内存。</li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成(可能日志未持久化到磁盘)。</li>
</ol>
<p>可以发现这里的 redo log 和 binlog 都是写入的内存而未进行持久化。如果此时断电内存丢失，那么数据就丢失了，这需要刷盘机制来保证数据不丢失。</p>
</br>

<h2 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h2><p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现读提交和可重复读这两种隔离级别。而读未提交隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p>
</br>

<h3 id="快照读（一致性非锁定读）"><a href="#快照读（一致性非锁定读）" class="headerlink" title="快照读（一致性非锁定读）"></a>快照读（一致性非锁定读）</h3><p>一致性的非锁定读是指 InnoDB 存储引擎通过行多版本控制（MVCC）的方式来读取当前数据库中的数据。</p>
<p>即若待读取的数据正在执行 <code>DELETE</code> 或 <code>UPDATE</code> 操作，那么读取操作不会阻塞等待锁的释放，而是读取该行的一个历史快照。</p>
<p>当事务需要读取正在被锁定的数据时，不会等待，而是去读取数据的一个历史版本，具体的实现方式是基于行数据的 undo log，undo log 主要用于事务的回滚，读取历史版本的数据无需上锁，因为历史数据是只读的（不会有事务修改历史数据）。</p>
<p>非锁定读机制大大提高了数据的并发性，InnoDB 默认支持非锁定的读。但在不同的事务隔离级别下，并非都采取相同一致性非锁定读：</p>
<ul>
<li>读已提交：根据每次 <code>SELECT</code> 时其他事务的提交情况 undo 到最新已提交的快照数据。</li>
<li>可重复读：根据事务开始时其他事务的提交情况 undo 到 begin 时已提交到数据。</li>
</ul>
<br>

<h3 id="当前读（一致性锁定读）"><a href="#当前读（一致性锁定读）" class="headerlink" title="当前读（一致性锁定读）"></a>当前读（一致性锁定读）</h3><p>在默认情况下，InnoDB 存储引擎对数据采用的是一致性非锁定读。但有些情况下为了保证数据逻辑的一致性，需要对 <code>SELECT</code> 的操作加锁。InnoDB 存储引擎对于 <code>SELECT</code> 语句支持两种一致性的锁定读（Locking Read）操作。</p>
<ol>
<li><p><code>SELECT … FOR UPDATE</code></p>
</li>
<li><p><code>SELECT … LOCK IN SHARE MODE</code></p>
</li>
</ol>
<p>其中 <code>SELECT … FOR UPDATE</code> 对读取的记录加一个写锁，其他事务不能对已锁定的行加任何锁。</p>
<p>而 <code>SELECT … LOCK IN SHARE MODE</code> 是对读取的记录加一个读锁，其他事物可以向被锁定的行加读锁，如果加写锁则会被阻塞。</p>
<br>

<h3 id="当前读与快照读读区别？"><a href="#当前读与快照读读区别？" class="headerlink" title="当前读与快照读读区别？"></a>当前读与快照读读区别？</h3><p><strong>快照读</strong>（一致性非锁定读）就是单纯的 <code>SELECT</code> 语句。快照即记录的历史版本，每行记录可能存在多个历史版本（多版本技术）。</p>
<p>快照读的情况下，如果读取的记录正在执行 <code>UPDATE/DELETE</code> 操作，读取操作不会因此去等待记录上 X 锁的释放，而是会去读取行的一个快照。</p>
<p>只有在事务隔离级别 RC(读取已提交) 和 RR（可重读）下，InnoDB 才会使用一致性非锁定读：</p>
<ul>
<li>在 RC 级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。</li>
<li>在 RR 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本。</li>
</ul>
<p>快照读比较适合对于数据一致性要求不是特别高且追求极致性能的业务场景。</p>
<p><strong>当前读</strong> （一致性锁定读）就是给行记录加 X 锁或 S 锁。</p>
</br>

<h3 id="如何解决幻读问题"><a href="#如何解决幻读问题" class="headerlink" title="如何解决幻读问题"></a>如何解决幻读问题</h3><p>InnoDB 的默认隔离级别 RR（可重读）是可以解决幻读问题发生的，主要有下面两种情况：</p>
<ul>
<li><strong>快照读</strong>（一致性非锁定读）：由 MVCC 机制来保证不出现幻读。</li>
<li><strong>当前读</strong>（一致性锁定读）：使用 Next-Key Lock 进行加锁来保证不出现幻读。</li>
</ul>
</br>

<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis-基础"><a href="#Redis-基础" class="headerlink" title="Redis 基础"></a>Redis 基础</h2><h3 id="什么是-Redis"><a href="#什么是-Redis" class="headerlink" title="什么是 Redis"></a>什么是 Redis</h3><p>Redis 是一个基于 C 语言开发的开源数据库，与传统数据库不同的是 Redis 的数据是存在内存中的，读写速度非常快，被广泛应用于缓存方向。并且 Redis 存储的是 KV 键值对数据。</p>
<p>为了满足不同的业务场景，Redis 内置了多种数据类型实现。并且，Redis 还支持事务 、持久化、Lua 脚本、多种开箱即用的集群方案。</p>
</br>

<h3 id="Redis-为什么这么快"><a href="#Redis-为什么这么快" class="headerlink" title="Redis 为什么这么快"></a>Redis 为什么这么快</h3><p>Redis 内部做了非常多的性能优化，比较重要的主要有下面 3 点：</p>
<ul>
<li>Redis 基于内存，内存的访问速度是磁盘的上千倍。</li>
<li>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用。</li>
<li>Redis 内置了多种优化过后的数据结构实现，性能非常高。</li>
</ul>
</br>

<h3 id="为什么要用-Redis-x2F-为什么要用缓存？"><a href="#为什么要用-Redis-x2F-为什么要用缓存？" class="headerlink" title="为什么要用 Redis&#x2F;为什么要用缓存？"></a>为什么要用 Redis&#x2F;为什么要用缓存？</h3><p>直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以可以把数据库中的部分数据转移到缓存中去，这样一部分请求会直接到缓存这里而不用经过数据库。进而也就提高了系统整体的并发。</p>
</br>

<h3 id="Redis-除了做缓存还能做什么"><a href="#Redis-除了做缓存还能做什么" class="headerlink" title="Redis 除了做缓存还能做什么"></a>Redis 除了做缓存还能做什么</h3><ul>
<li><strong>分布式锁</strong> ： 通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下都是基于 Redisson 来实现分布式锁。</li>
<li><strong>限流</strong> ：一般是通过 Redis + Lua 脚本的方式来实现限流。</li>
<li><strong>消息队列</strong> ：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</li>
<li><strong>复杂业务场景</strong> ：通过 Redis 以及 Redis 扩展提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。</li>
</ul>
</br>

<h2 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h2><h3 id="Redis-常用的数据结构"><a href="#Redis-常用的数据结构" class="headerlink" title="Redis 常用的数据结构"></a>Redis 常用的数据结构</h3><ul>
<li><strong>5 种基础数据结构</strong> ：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</li>
<li><strong>3 种特殊数据结构</strong> ：HyperLogLogs（基数统计）、Bitmap （位存储）、Geospatial (地理位置)。</li>
</ul>
</br>

<h3 id="String-与-Hash"><a href="#String-与-Hash" class="headerlink" title="String 与 Hash"></a>String 与 Hash</h3><ul>
<li>String 存储的是序列化后的对象数据，存放的是整个对象。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。</li>
<li>String 存储相对来说更加节省内存，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，String 就非常适合。</li>
</ul>
<p>在绝大部分情况，建议使用 String 来存储对象数据即可。</p>
</br>

<h3 id="String-的应用场景有哪些？"><a href="#String-的应用场景有哪些？" class="headerlink" title="String 的应用场景有哪些？"></a>String 的应用场景有哪些？</h3><ul>
<li>常规数据（如 session、token、序列化后的对象）的缓存。</li>
<li>计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数。</li>
<li>分布式锁(利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁)。</li>
</ul>
</br>

<h2 id="Redis-线程模型"><a href="#Redis-线程模型" class="headerlink" title="Redis 线程模型"></a>Redis 线程模型</h2><p>对于读写命令来说，Redis 一直是单线程模型。</p>
<h3 id="Redis-单线程模型"><a href="#Redis-单线程模型" class="headerlink" title="Redis 单线程模型"></a>Redis 单线程模型</h3><p><strong>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型</strong>，这套事件处理模型对应的是 Redis 中的文件事件处理器。由于文件事件处理器是单线程方式运行的，所以一般说 Redis 是单线程模型。</p>
<p>Redis 通过 <strong>IO 多路复用程序</strong>来监听来自客户端的大量连接，它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。</p>
<p>这样的好处非常明显：<strong>I&#x2F;O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>。</p>
<p>文件事件处理器（file event handler）主要是包含 4 个部分：</p>
<ul>
<li>多个 socket（客户端连接）</li>
<li>IO 多路复用程序（支持多个客户端连接的关键）</li>
<li>文件事件分派器（将 socket 关联到相应的事件处理器）</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<p><img data-src="https://s1.ax1x.com/2022/09/28/xmE4uF.png" alt="xmE4uF.png"></p>
</br>

<h3 id="Redis-为什么不使用多线程"><a href="#Redis-为什么不使用多线程" class="headerlink" title="Redis 为什么不使用多线程"></a>Redis 为什么不使用多线程</h3><p>主要原因有 3 点：</p>
<ul>
<li>单线程编程容易并且更容易维护。</li>
<li>Redis 的性能瓶颈不在 CPU，主要在内存和网络。</li>
<li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li>
</ul>
</br>

<h3 id="Redis6-0-之后为何引入了多线程"><a href="#Redis6-0-之后为何引入了多线程" class="headerlink" title="Redis6.0 之后为何引入了多线程"></a>Redis6.0 之后为何引入了多线程</h3><p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。</p>
<p>虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此也不需要担心线程安全问题。</p>
</br>

<h2 id="Redis-持久化机制"><a href="#Redis-持久化机制" class="headerlink" title="Redis 持久化机制"></a>Redis 持久化机制</h2><p>Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。</p>
<h3 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a>RDB 持久化</h3><p>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p>
<p>快照持久化是 Redis 默认采用的持久化方式，在 <code>redis.conf</code> 配置文件中默认有此下配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save 900 1           <span class="comment"># 在 900 秒后，如果至少有 1 个 key 发生变化，Redis 就会自动触发 bgsave 命令创建快照。</span></span><br><span class="line"></span><br><span class="line">save 300 10          <span class="comment"># 在 300 秒后，如果至少有 10 个 key 发生变化，Redis 就会自动触发 bgsave 命令创建快照。</span></span><br><span class="line"></span><br><span class="line">save 60 10000        <span class="comment"># 在 60 秒后，如果至少有 10000 个 key 发生变化，Redis 就会自动触发 bgsave 命令创建快照。</span></span><br></pre></td></tr></table></figure>

</br>

<h3 id="RDB-创建快照时会阻塞主线程吗"><a href="#RDB-创建快照时会阻塞主线程吗" class="headerlink" title="RDB 创建快照时会阻塞主线程吗"></a>RDB 创建快照时会阻塞主线程吗</h3><p>Redis 提供了两个命令来生成 RDB 快照文件：</p>
<ul>
<li><code>save</code> : 主线程执行，会阻塞主线程；</li>
<li><code>bgsave</code> : 子线程执行，不会阻塞主线程，默认选项。</li>
</ul>
</br>

<h3 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h3><p>与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

<p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 <code>server.aof_buf</code> 中，然后再根据 <code>appendfsync</code> 配置来决定何时将其同步到硬盘中的 AOF 文件。</p>
<p>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 <code>appendonly.aof</code>。</p>
<p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always    <span class="comment"># 每次有数据修改发生时都会写入 AOF 文件,这样会严重降低 Redis 的速度</span></span><br><span class="line">appendfsync everysec  <span class="comment"># 每秒钟同步一次，显式地将多个写命令同步到硬盘</span></span><br><span class="line">appendfsync no        <span class="comment"># 让操作系统决定何时进行同步</span></span><br></pre></td></tr></table></figure>

<p>为了兼顾数据和写入性能，用户可以考虑 <code>appendfsync everysec</code> 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p>
</br>

<h2 id="Redis-性能优化"><a href="#Redis-性能优化" class="headerlink" title="Redis 性能优化"></a>Redis 性能优化</h2><h3 id="Redis-bigkey"><a href="#Redis-bigkey" class="headerlink" title="Redis bigkey"></a>Redis bigkey</h3><h4 id="什么是-bigkey"><a href="#什么是-bigkey" class="headerlink" title="什么是 bigkey"></a>什么是 bigkey</h4><p>如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。</p>
<p>一个不精确的参考标准：string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个（对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）。</p>
<p>除了会消耗更多的内存空间，bigkey 对性能也会有比较大的影响。因此应该尽量避免写入 bigkey。</p>
</br>

<h4 id="如何发现-bigkey"><a href="#如何发现-bigkey" class="headerlink" title="如何发现 bigkey"></a>如何发现 bigkey</h4><ol>
<li>使用 Redis 自带的 <code>--bigkeys</code> 参数来查找。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis-cli -p 6379 --bigkeys</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Scanning the entire keyspace to find biggest keys as well as</span></span><br><span class="line"><span class="comment"># average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec</span></span><br><span class="line"><span class="comment"># per 100 SCAN commands (not usually needed).</span></span><br><span class="line"></span><br><span class="line">[00.00%] Biggest string found so far <span class="string">&#x27;&quot;ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20&quot;&#x27;</span> with 4437 bytes</span><br><span class="line">[00.00%] Biggest list   found so far <span class="string">&#x27;&quot;my-list&quot;&#x27;</span> with 17 items</span><br><span class="line"></span><br><span class="line">-------- summary -------</span><br><span class="line"></span><br><span class="line">Sampled 5 keys <span class="keyword">in</span> the keyspace!</span><br><span class="line">Total key length <span class="keyword">in</span> bytes is 264 (avg len 52.80)</span><br><span class="line"></span><br><span class="line">Biggest   list found <span class="string">&#x27;&quot;my-list&quot;&#x27;</span> has 17 items</span><br><span class="line">Biggest string found <span class="string">&#x27;&quot;ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20&quot;&#x27;</span> has 4437 bytes</span><br><span class="line"></span><br><span class="line">1 lists with 17 items (20.00% of keys, avg size 17.00)</span><br><span class="line">0 hashs with 0 fields (00.00% of keys, avg size 0.00)</span><br><span class="line">4 strings with 4831 bytes (80.00% of keys, avg size 1207.75)</span><br><span class="line">0 streams with 0 entries (00.00% of keys, avg size 0.00)</span><br><span class="line">0 sets with 0 members (00.00% of keys, avg size 0.00)</span><br><span class="line">0 zsets with 0 members (00.00% of keys, avg size 0.00</span><br></pre></td></tr></table></figure>

<p>从这个命令的运行结果，我们可以看出：这个命令会扫描(Scan) Redis 中的所有 key ，会对 Redis 的性能有一点影响。并且，这种方式只能找出每种数据结构 top 1 bigkey（占用内存最大的 string 数据类型，包含元素最多的复合数据类型）。</p>
<ol start="2">
<li>分析 RDB 文件</li>
</ol>
<p>通过分析 RDB 文件来找出 big key。这种方案的前提是 Redis 采用的是 RDB 持久化。</p>
</br>

<h3 id="大量-key-集中过期问题"><a href="#大量-key-集中过期问题" class="headerlink" title="大量 key 集中过期问题"></a>大量 key 集中过期问题</h3><p>对于过期 key，Redis 采用的是 <strong>定期删除 + 惰性&#x2F;懒汉式删除</strong> 策略。</p>
<p>定期删除执行过程中，如果突然遇到大量过期 key 的话，客户端请求必须等待定期清理过期 key 任务线程执行完成，因为这个这个定期任务线程是在 Redis 主线程中执行的。这就导致客户端请求没办法被及时处理，响应速度会比较慢。</p>
<p>两种常见的解决方法：</p>
<ol>
<li>给 key 设置随机过期时间。</li>
<li>开启 lazy-free（惰性删除&#x2F;延迟释放） 。lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</li>
</ol>
<p>建议不管是否开启 lazy-free，都尽量给 key 设置随机过期时间。</p>
</br>

<h2 id="Redis-生产问题"><a href="#Redis-生产问题" class="headerlink" title="Redis 生产问题"></a>Redis 生产问题</h2><p>Redis 经常用于系统中的缓存，这样可以解决目前 IO 设备无法满足互联网应用海量的读写请求的问题。但缓存存在一些潜在的问题。Redis 生产问题</p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>请求的 key 在缓存及数据库中都不存在。数据库查询不存在，不进行缓存设置，导致每次请求都落地到数据库。如果是恶意的请求，将造成数据库压力过大。如发起 id 为 -1 的数据或者特别大的不存在的数据。有可能是黑客利用漏洞攻击从而去压垮应用的数据库。</p>
<p><img data-src="https://s1.imagehub.cc/images/2022/04/18/QQ20220418194935.png" alt="QQ20220418194935.png"></p>
<br/>

<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol>
<li>缓存空数据</li>
</ol>
<p>当数据库查询到的数据为空时，也将这条数据进行缓存，但缓存的有效性设置得要较短，以免影响正常数据的缓存。但当数据库出现新的 id，且之前缓存已经被设置为空值，那么过期时间内无法访问新增的数据</p>
<ol start="2">
<li>布隆过滤器</li>
</ol>
<p>布隆过滤器是一种数据结构，对所有可能查询的参数以 hash 形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的压力。</p>
<p>将所有可能存在的 id 存储在一个 bitmap，请求前先经过过滤器判断是否存在。但有误判的可能</p>
<blockquote>
<p>布隆过滤器是一种比较特殊的数据结构，有点类似于 HashMap，在业务中我们可能会通过使用 HashMap 来判断一个值是否存在，它可以在 <code>O(1)</code> 时间复杂度内返回结果，效率极高，但是受限于存储容量，如果可能需要去判断的值超过亿级别，那么 HashMap 所占的内存就很可观了。</p>
<p>而 <code>BloomFilter</code> 解决这个问题的方案很简单。首先用多个 bit 位去代替 HashMap 中的数组，这样的话储存空间就下来了，之后就是对 Key 进行多次哈希，将 Key 哈希后的值所对应的 bit 位置为1。</p>
<p>当判断一个元素是否存在时，就去判断这个值哈希出来的比特位是否都为 1，如果都为 1，那么可能存在，也可能不存在（如下图 F）。但是如果有一个 bit 位不为 1，那么这个 Key 就肯定不存在。</p>
</blockquote>
<img data-src="https://s1.imagehub.cc/images/2022/04/18/1614350-20201209082514905-1720451943.png" alt="1614350-20201209082514905-1720451943.png" style="zoom: 80%;" />



<p>注意：<code>BloomFilter</code> 并不支持删除操作，只支持添加操作。这一点很容易理解，因为你如果要删除数据，就得将对应的 bit 位置为0，但是这个 Key 对应的 bit 位可能其他的 Key 也对应着。</p>
<br/>

<h4 id="缓存空数据与布隆过滤器的比较"><a href="#缓存空数据与布隆过滤器的比较" class="headerlink" title="缓存空数据与布隆过滤器的比较"></a>缓存空数据与布隆过滤器的比较</h4><p>缓存空数据与布隆过滤器都能有效解决缓存穿透问题，但使用场景有着些许不同；</p>
<ul>
<li>当一些恶意攻击查询查询的 key 各不相同，而且数量巨多，此时缓存空数据不是一个好的解决方案。因为它需要存储所有的 Key，内存空间占用高。并且在这种情况下，很多 key 可能只用一次，所以存储下来没有意义。所以对于这种情况而言，使用布隆过滤器是个不错的选择；</li>
<li>而对与空数据的 Key 数量有限、Key 重复请求效率较高的场景而言，可以选择缓存空数据的方案。</li>
</ul>
<br/>

<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>缓存击穿是指当前热点数据存储到期时，多个线程同时并发访问热点数据。因为缓存刚过期，所有并发请求都会到数据库中查询数据。</p>
<p><img data-src="https://s1.imagehub.cc/images/2022/04/18/QQ20220418195434.png" alt="QQ20220418195434.png"></p>
<br/>

<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><ol>
<li><p>将热点数据设置为永不过期；</p>
</li>
<li><p>加互斥锁：互斥锁可以控制查询数据库的线程访问，但这种方案会导致系统的吞吐量下降，需要根据实际情况使用。</p>
</li>
</ol>
<br/>

<p>缓存雪崩</p>
<h4 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h4><p>缓存雪崩发生有几种情况，比如大量缓存集中在或者缓存同时在大范围中失效，出现了大量请求去访问数据库，从而导致CPU和内存过载，甚至停机。</p>
<p>一个简单的雪崩过程：</p>
<ol>
<li>Redis 集群产生了大面积故障；</li>
<li>缓存失败，此时仍有大量请求去访问 Redis 缓存服务器；</li>
<li>在大量 Redis 请求失败后，这些请求将会去访问数据库；</li>
<li>由于应用的设计依赖于数据库和 Redis 服务，很快就会造成服务器集群的雪崩，最终导致整个系统的瘫痪。</li>
</ol>
<p><img data-src="https://s1.imagehub.cc/images/2022/04/18/QQ20220418195601.png" alt="QQ20220418195601.png"></p>
<br/>

<h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><ol>
<li><p>「事前」高可用缓存：高可用缓存是防止出现整个缓存故障。即使个别节点，机器甚至机房都关闭，系统仍然可以提供服务，Redis 哨兵(Sentinel) 和 Redis 集群(Cluster) 都可以做到高可用。</p>
</li>
<li><p>「事中」缓存降级（临时支持）：当访问次数急剧增加导致服务出现问题时，我们如何确保服务仍然可用。在国内使用比较多的是 Hystrix，它通过熔断、降级、限流三个手段来降低雪崩发生后的损失。只要确保数据库不死，系统总可以响应请求。</p>
</li>
<li><p>「事后」Redis 备份和快速预热：Redis 数据备份和恢复、快速缓存预热。</p>
</li>
</ol>
<br/>

<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h2><h3 id="什么是-Spring-IoC"><a href="#什么是-Spring-IoC" class="headerlink" title="什么是 Spring IoC"></a>什么是 Spring IoC</h3><p><strong>IoC（Inverse of Control）控制反转</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权交由 Spring 框架来管理。</p>
<ul>
<li><strong>控制</strong>：指的是对象创建（实例化、管理）的权力。</li>
<li><strong>反转</strong>：控制权交给外部环境（Spring 框架、IoC 容器）。</li>
</ul>
<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。IoC 容器就像一个工厂，当需要创建一个对象时只需要配置好配置文件&#x2F;注解即可，完全不用考虑对象是如何被创建出来的。</p>
<p>在 Spring 中，IoC 容器是 Spring 用来实现 IoC 的载体，IoC 容器实际上就是个 Map(key，value)，其中存放的是就各种对象。</p>
</br>

<h3 id="什么是-Spring-Bean"><a href="#什么是-Spring-Bean" class="headerlink" title="什么是 Spring Bean"></a>什么是 Spring Bean</h3><p>Bean 代指的就是那些被 IoC 容器所管理的对象。我们需要告诉 IoC 容器帮助管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。</p>
</br>

<h3 id="Autowired-和-Resource-的区别"><a href="#Autowired-和-Resource-的区别" class="headerlink" title="@Autowired 和 @Resource 的区别"></a>@Autowired 和 @Resource 的区别</h3><p><code>Autowired</code> 属于 Spring 内置的注解，默认的注入方式为 <code>byType</code>（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入 Bean （接口的实现类）。</p>
<p>若一个接口存在多个实现类 <code>byType </code>这种方式就无法正确注入对象了。这时 Spring 会同时找到多个满足条件的选择。这种情况下，注入方式会变为 <code>byName</code>（根据名称进行匹配），这个名称通常就是类名（首字母小写）。可以通过 <code>@Qualifier</code> 注解来显示指定名称。</p>
<p><code>@Resource</code> 属于 JDK 提供的注解，默认注入方式为 <code>byName</code>。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为 <code>byType</code>。</p>
<p><code>@Resource</code> 有两个比较重要且日常开发常用的属性：<code>name</code>（名称）、<code>type</code>（类型）。如果仅指定 <code>name</code> 属性则注入方式为 <code>byName</code>，如果仅指定 <code>type</code> 属性则注入方式为 <code>byType</code>。</p>
<p>总结：</p>
<ul>
<li><code>@Autowired</code> 是 Spring 提供的注解，<code>@Resource</code> 是 JDK 提供的注解。</li>
<li><code>Autowired</code> 默认的注入方式为 <code>byType</code>（根据类型进行匹配），<code>@Resource </code>默认注入方式为 <code>byName</code>（根据名称进行匹配）。</li>
<li>当一个接口存在多个实现类的情况下，<code>@Autowired</code> 和 <code>@Resource</code> 都需要通过名称才能正确匹配到对应的  Bean。<code>Autowired</code> 可以通过 <code>@Qualifier</code> 注解来显示指定名称，<code>@Resource </code>可以通过 <code>name</code> 属性来显示指定名称。</li>
</ul>
</br>

<h3 id="Bean-的作用域"><a href="#Bean-的作用域" class="headerlink" title="Bean 的作用域"></a>Bean 的作用域</h3><p>Spring 中 Bean 的作用域通常有下面几种：</p>
<ul>
<li><strong>singleton</strong>: IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</li>
<li><strong>prototype</strong>: 每次获取都会创建一个新的 bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</li>
<li><strong>request</strong>(仅 Web 应用): 每一次 HTTP 请求都会产生一个新的 bean(请求 bean)，该 bean 仅在当前 HTTP request 内有效。</li>
<li><strong>session</strong>(仅 Web 应用): 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean(会话 bean)，该 bean 仅在当前 HTTP session 内有效。</li>
<li><strong>application&#x2F;global-session</strong>(仅 Web 应用)：每个 Web 应用在启动时创建一个 Bean(应用 Bean)， bean 仅在当前应用启动时间内有效。</li>
<li><strong>websocket</strong>(仅 Web 应用)：每一次 WebSocket 会话产生一个新的 bean。</li>
</ul>
<p>可以通过 Spring xml 的 <code>scope</code> 属性或 SpringBoot 的 <code>@Scope(value = ConfigurableBeanFactory)</code> 来配置</p>
</br>

<h3 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h3><p><code>构造</code> -&gt; <code>注入属性 满足依赖</code> -&gt; <code>后处理器前置过程</code> -&gt; <code>初始化</code> -&gt; <code>后处理器后置过程</code> -&gt; <code>销毁</code></p>
</br>

<h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><h3 id="什么是-AOP"><a href="#什么是-AOP" class="headerlink" title="什么是 AOP"></a>什么是 AOP</h3><p><strong>AOP（Aspect-Oriented Programming）面向切面编程</strong>能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>
<p>Spring AOP 是基于动态代理的。如果要代理的对象实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong> 去创建代理对象，而对于没有实现接口的对象 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理。</p>
<p>AOP 切面编程设计到的一些专业术语：</p>
<table>
<thead>
<tr>
<th align="left">术语</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">目标(Target)</td>
<td align="center">被通知的对象</td>
</tr>
<tr>
<td align="left">代理(Proxy)</td>
<td align="center">向目标对象应用通知之后创建的代理对象</td>
</tr>
<tr>
<td align="left">连接点(JoinPoint)</td>
<td align="center">目标对象的所属类中，定义的所有方法均为连接点</td>
</tr>
<tr>
<td align="left">切入点(Pointcut)</td>
<td align="center">被切面拦截 &#x2F; 增强的连接点（切入点一定是连接点，连接点不一定是切入点）</td>
</tr>
<tr>
<td align="left">通知(Advice)</td>
<td align="center">增强的逻辑 &#x2F; 代码，也即拦截到目标对象的连接点之后要做的事情</td>
</tr>
<tr>
<td align="left">切面(Aspect)</td>
<td align="center">切入点(Pointcut) + 通知(Advice)</td>
</tr>
<tr>
<td align="left">织入(Weaving)</td>
<td align="center">将通知应用到目标对象，进而生成代理对象的过程动作</td>
</tr>
</tbody></table>
</br>

<h3 id="Spring-AOP-于和-AspectJ-AOP-的区别"><a href="#Spring-AOP-于和-AspectJ-AOP-的区别" class="headerlink" title="Spring AOP 于和 AspectJ AOP 的区别"></a>Spring AOP 于和 AspectJ AOP 的区别</h3><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p>
<p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单。</p>
<p>如果切面较少，那么两者性能差异不大。但当切面较多时最好选择 AspectJ ，它比 Spring AOP 快很多。</p>
</br>

<h3 id="AspectJ-定义的通知类型"><a href="#AspectJ-定义的通知类型" class="headerlink" title="AspectJ 定义的通知类型"></a>AspectJ 定义的通知类型</h3><ul>
<li><strong>Before</strong>（前置通知）：目标对象的方法调用之前触发</li>
<li><strong>After</strong> （后置通知）：目标对象的方法调用之后触发</li>
<li><strong>AfterReturning</strong>（返回通知）：目标对象的方法调用完成，在返回结果值之后触发</li>
<li><strong>AfterThrowing</strong>（异常通知） ：目标对象的方法运行中抛出 &#x2F; 触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。</li>
<li><strong>Around</strong>： （环绕通知）编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法</li>
</ul>
</br>

<h3 id="如何控制多个切面的执行顺序"><a href="#如何控制多个切面的执行顺序" class="headerlink" title="如何控制多个切面的执行顺序"></a>如何控制多个切面的执行顺序</h3><ol>
<li>通常使用 <code>@Order</code> 注解直接定义切面顺序</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值越小优先级越高</span></span><br><span class="line"><span class="meta">@Order(3)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> <span class="keyword">implements</span> <span class="title class_">Ordered</span> &#123;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>实现 <code>Ordered</code> 接口重写 <code>getOrder</code> 方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> <span class="keyword">implements</span> <span class="title class_">Ordered</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 返回值越小优先级越高</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><h3 id="什么是-Spring-MVC"><a href="#什么是-Spring-MVC" class="headerlink" title="什么是 Spring MVC"></a>什么是 Spring MVC</h3><p>MVC 是一种设计模式，Spring MVC 是一款优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的 Web 层的开发，并且它天生与 Spring 框架集成。Spring MVC 下一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)。</p>
</br>

<h3 id="Spring-MVC-的核心组件"><a href="#Spring-MVC-的核心组件" class="headerlink" title="Spring MVC 的核心组件"></a>Spring MVC 的核心组件</h3><ul>
<li><strong><code>DispatcherServlet</code></strong> ：<strong>核心的中央处理器</strong>，负责接收请求、分发，并给予客户端响应。</li>
<li><strong><code>HandlerMapping</code></strong> ：<strong>处理器映射器</strong>，根据 uri 去匹配查找能处理的 <code>Handler</code>，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li>
<li><strong><code>HandlerAdapter</code></strong> ：<strong>处理器适配器</strong>，根据 <code>HandlerMapping</code> 找到的 <code>Handler</code>，适配执行对应的 <code>Handler</code>。</li>
<li><strong><code>Handler</code></strong> ：<strong>请求处理器</strong>，处理实际请求的处理器。</li>
<li><strong><code>ViewResolver</code></strong> ：<strong>视图解析器</strong>，根据 <code>Handler</code> 返回的逻辑视图 &#x2F; 视图，解析并渲染真正的视图，并传递给 <code>DispatcherServlet</code> 响应客户端。</li>
</ul>
</br>

<h3 id="SpringMVC-工作原理"><a href="#SpringMVC-工作原理" class="headerlink" title="SpringMVC 工作原理"></a>SpringMVC 工作原理</h3><p><img data-src="https://img-blog.csdnimg.cn/img_convert/de6d2b213f112297298f3e223bf08f28.png"></p>
<p><strong>流程说明：</strong></p>
<ol>
<li>客户端（浏览器）发送请求， <code>DispatcherServlet </code>拦截请求。</li>
<li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>。<code>HandlerMapping</code> 根据 uri 去匹配查找能处理的 <code>Handler</code>（<code>Controller</code> 控制器），并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li>
<li><code>DispatcherServlet</code> 调用 <code>HandlerAdapter</code>适配执行 <code>Handler</code>。</li>
<li><code>Handler</code> 完成对用户请求的处理后，会返回一个 <code>ModelAndView</code> 对象给 <code>DispatcherServlet</code>，<code>ModelAndView</code> 包含了数据模型以及相应的视图的信息。<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li>
<li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li>
<li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li>
<li>把 <code>View</code> 返回给请求者（浏览器）。</li>
</ol>
</br>

<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>排序算法可以分为：</p>
<ul>
<li><strong>内部排序</strong> ：数据记录在内存中进行排序。</li>
<li>外部排序：因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。</li>
</ul>
<p>常见的内部排序算法有：<strong>插入排序</strong>、<strong>希尔排序</strong>、<strong>选择排序</strong>、<strong>冒泡排序</strong>、<strong>归并排序</strong>、<strong>快速排序</strong>、<strong>堆排序</strong>、<strong>基数排序</strong>等。</p>
<p><img data-src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/sort1.png"></p>
<p><strong>图片名词解释：</strong></p>
<ul>
<li><strong>n</strong>：数据规模</li>
<li><strong>k</strong>：“桶” 的个数</li>
<li><strong>In-place</strong>：占用常数内存，不占用额外内存</li>
<li><strong>Out-place</strong>：占用额外内存</li>
</ul>
<p><strong>术语说明</strong>：</p>
<ul>
<li><strong>稳定</strong>：如果 <code>A</code> 原本在 <code>B</code> 前面，而 <code>A = B</code>，排序之后 <code>A</code> 仍然在 <code>B</code> 的前面。</li>
<li><strong>不稳定</strong>：如果 <code>A</code> 原本在 <code>B</code> 的前面，而 <code>A = B</code>，排序之后 <code>A</code> 可能会出现在 <code>B</code> 的后面。</li>
<li><strong>内排序</strong>：所有排序操作都在内存中完成。</li>
<li><strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行。</li>
<li><strong>时间复杂度</strong>： 定性描述一个算法执行所耗费的时间。</li>
<li><strong>空间复杂度</strong>：定性描述一个算法执行所需内存的大小。</li>
</ul>
</br>

<h2 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序 (Bubble Sort)"></a>冒泡排序 (Bubble Sort)</h2><p>冒泡排序是一种简单的排序算法。它重复地遍历要排序的序列，依次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历序列的工作是重复地进行直到没有再需要交换为止，此时说明该序列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢 “浮” 到数列的顶端。</p>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>重复步骤 1~3，直到排序完成。</li>
</ol>
</br>

<h3 id="图解算法"><a href="#图解算法" class="headerlink" title="图解算法"></a>图解算法</h3><p><img data-src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/bubble_sort.gif"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] bubbleSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSorted</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                isSorted = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>此处对代码做了一个优化，加入了 <code>isSorted</code> 标记，目的是将算法的最佳时间复杂度优化为 <code>O(n)</code>，即当原输入序列就是排序好的情况下，该算法的时间复杂度就是 <code>O(n)</code>。</strong></p>
</br>

<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>稳定性</strong>：稳定</li>
<li><strong>时间复杂度</strong> ：最佳：<code>O(n)</code> ，最差：<code>O(n²)</code>， 平均：<code>O(n²)</code></li>
<li><strong>空间复杂度</strong> ：<code>O(1)</code></li>
<li><strong>排序方式</strong> ：In-place</li>
</ul>
</br>

<h2 id="选择排序-Selection-Sort"><a href="#选择排序-Selection-Sort" class="headerlink" title="选择排序 (Selection Sort)"></a>选择排序 (Selection Sort)</h2><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 <code>O(n²)</code> 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<h3 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>重复第 2 步，直到所有元素均排序完毕。</li>
</ol>
</br>

<h3 id="图解算法-1"><a href="#图解算法-1" class="headerlink" title="图解算法"></a>图解算法</h3><p><img data-src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/selection_sort.gif" alt="Selection Sort"></p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] selectionSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i] = arr[minIndex];</span><br><span class="line">            arr[minIndex] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>稳定性</strong>：不稳定</li>
<li><strong>时间复杂度</strong> ：最佳：<code>O(n²)</code> ，最差：<code>O(n²)</code>， 平均：<code>O(n²)</code></li>
<li><strong>空间复杂度</strong> ：<code>O(1)</code></li>
<li><strong>排序方式</strong> ：In-place</li>
</ul>
</br>

<h2 id="插入排序-Insertion-Sort"><a href="#插入排序-Insertion-Sort" class="headerlink" title="插入排序 (Insertion Sort)"></a>插入排序 (Insertion Sort)</h2><p>插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用 in-place 排序（即只需用到 <code>O(1)</code> 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。</p>
<h3 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li>从第一个元素开始，该元素可以认为已经被排序。</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描。</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置。</li>
<li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置。</li>
<li>将新元素插入到该位置后。</li>
<li>重复步骤 2~5。</li>
</ol>
</br>

<h3 id="图解算法-2"><a href="#图解算法-2" class="headerlink" title="图解算法"></a>图解算法</h3><p><img data-src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/insertion_sort.gif" alt="insertion_sort"></p>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] insertionSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preIndex</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; current &lt; arr[preIndex]) &#123;</span><br><span class="line">            arr[preIndex + <span class="number">1</span>] = arr[preIndex];</span><br><span class="line">            preIndex -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h3 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>稳定性</strong>：稳定</li>
<li><strong>时间复杂度</strong> ：最佳：<code>O(n)</code> ，最差：<code>O(n²)</code>， 平均：<code>O(n²)</code></li>
<li><strong>空间复杂度</strong> ：<code>O(1)</code></li>
<li><strong>排序方式</strong> ：In-place</li>
</ul>
</br>

<h2 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序 (Quick Sort)"></a>快速排序 (Quick Sort)</h2><p>快速排序用到了分治思想，同样的还有归并排序。乍看起来快速排序和归并排序非常相似，都是将问题变小，先排序子串，最后合并。不同的是快速排序在划分子问题的时候经过多一步处理，将划分的两组数据划分为一大一小，这样在最后合并的时候就不必像归并排序那样再进行比较。但也正因为如此，划分的不定性使得快速排序的时间复杂度并不稳定。</p>
<p>快速排序的基本思想：通过一趟排序将待排序列分隔成独立的两部分，其中一部分记录的元素均比另一部分的元素小，则可分别对这两部分子序列继续进行排序，以达到整个序列有序。</p>
<h3 id="算法步骤-3"><a href="#算法步骤-3" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>快速排序使用分治法（Divide and conquer）策略来把一个序列分为较小和较大的 2 个子序列，然后递回地排序两个子序列。具体算法描述如下：</p>
<ol>
<li>从序列中<strong>随机</strong>挑出一个元素，做为「基准」(<code>pivot</code>)。</li>
<li>重新排列序列，将所有比基准值小的元素摆放在基准前面，所有比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个操作结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li>
<li>递归地把小于基准值元素的子序列和大于基准值元素的子序列进行快速排序。</li>
</ol>
</br>

<h3 id="图解算法-3"><a href="#图解算法-3" class="headerlink" title="图解算法"></a>图解算法</h3><p><img data-src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/random_quick_sort.gif" alt="RandomQuickSort"></p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> array[high];</span><br><span class="line">    <span class="type">int</span> <span class="variable">pointer</span> <span class="operator">=</span> low;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low; i &lt; high; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &lt;= pivot) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[i];</span><br><span class="line">            array[i] = array[pointer];</span><br><span class="line">            array[pointer] = temp;</span><br><span class="line">            pointer++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[pointer];</span><br><span class="line">    array[pointer] = array[high];</span><br><span class="line">    array[high] = temp;</span><br><span class="line">    <span class="keyword">return</span> pointer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> partition(array, low, high);</span><br><span class="line">        quickSort(array, low, position - <span class="number">1</span>);</span><br><span class="line">        quickSort(array, position + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h3 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><strong>稳定性</strong> ：不稳定</li>
<li><strong>时间复杂度</strong> ：最佳：<code>O(nlogn)</code>， 最差：<code>O(nlogn)</code>，平均：<code>O(nlogn)</code></li>
<li><strong>空间复杂度</strong> ：<code>O(nlogn)</code></li>
</ul>
</br>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>Buy me a coffee</div>
  <button onclick="document.querySelector('.post-reward').classList.toggle('active');">
    Donate
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="Ssssv11 WeChat Pay">
        <span>WeChat Pay</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"><i class="fa fa-tag"></i> 面试</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/07/06/%E7%AE%97%E6%B3%95/" rel="prev" title="算法">
                  <i class="fa fa-chevron-left"></i> 算法
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ssssv</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script size="90" alpha="0.6" zIndex="-1" src="/js/ribbon/ribbon.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/local-search.js"></script>






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'none'
      },
      options: {
        renderActions: {
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>



</body>
</html>

<script src="/js/cursor/fireworks.js"></script>

