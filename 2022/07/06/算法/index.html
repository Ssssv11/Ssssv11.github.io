<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="baidu-site-verification" content="code-jbS6cVmQ2r">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.lug.ustc.edu.cn/css?family=Helvetica:300,300italic,400,400italic,700,700italic%7CMenlo:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ssssv11.github.io","root":"/","images":"/images","scheme":"Pisces","version":"8.2.2","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="LeetCode 刷题笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="算法笔记">
<meta property="og:url" content="https://ssssv11.github.io/2022/07/06/%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Ssssv">
<meta property="og:description" content="LeetCode 刷题笔记">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/11/j6jdt1.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/11/j6jN79.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/11/j6jakR.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/11/j6jt0J.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/11/j6jYm4.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/11/j6jBp6.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/11/j6jwfx.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/12/jgopFK.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/12/jgo9JO.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/12/jgoiSe.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/12/jgIxdx.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/12/jgIzo6.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/12/jgoCWD.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/12/jgoFQH.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/12/jgokyd.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/12/jgoAOA.png">
<meta property="og:image" content="https://files.catbox.moe/6eu9q1.png#crop=0&crop=0&crop=1&crop=1&id=YBUqQ&originHeight=1228&originWidth=1468&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://files.catbox.moe/dhbbub.png#crop=0&crop=0&crop=1&crop=1&id=YOt8K&originHeight=1234&originWidth=1460&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://files.catbox.moe/po3nwl.png#crop=0&crop=0&crop=1&crop=1&id=oeX9v&originHeight=736&originWidth=1142&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://files.catbox.moe/gcezr2.png#crop=0&crop=0&crop=1&crop=1&id=yEZdr&originHeight=768&originWidth=980&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://s2.loli.net/2022/07/14/Q84MnoJvxsPpeZW.png#crop=0&crop=0&crop=1&crop=1&id=xJBUU&originHeight=648&originWidth=1186&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s2.loli.net/2022/07/14/fi5Cq8gJ9banuwZ.png#crop=0&crop=0&crop=1&crop=1&id=QFF7q&originHeight=1020&originWidth=1450&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/14/jfM4Xt.png#crop=0&crop=0&crop=1&crop=1&id=VIdLS&originHeight=1110&originWidth=1462&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/14/jflmxs.png#crop=0&crop=0&crop=1&crop=1&id=hSuJi&originHeight=1116&originWidth=1468&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/14/jf1o0x.png#crop=0&crop=0&crop=1&crop=1&id=S0eJz&originHeight=1372&originWidth=1460&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/14/jf83If.png#crop=0&crop=0&crop=1&crop=1&id=Kb7Jh&originHeight=1262&originWidth=1462&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/14/jfY2Qg.png#crop=0&crop=0&crop=1&crop=1&id=y52JL&originHeight=1192&originWidth=1432&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/14/jftTHA.png#crop=0&crop=0&crop=1&crop=1&id=bHZZT&originHeight=335&originWidth=640&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/14/jftoBd.png#crop=0&crop=0&crop=1&crop=1&id=Ntqko&originHeight=181&originWidth=397&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/16/j4XVQs.jpg#crop=0&crop=0&crop=1&crop=1&id=p1vFh&originHeight=301&originWidth=423&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/16/j4ji0x.png#crop=0&crop=0&crop=1&crop=1&id=Zu0Z5&originHeight=718&originWidth=1194&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/16/ce98179a2c5048b1.png#crop=0&crop=0&crop=1&crop=1&id=HkyLU&originHeight=301&originWidth=423&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://i.bmp.ovh/imgs/2022/07/16/93d0535f299a3f84.png#crop=0&crop=0&crop=1&crop=1&id=llY6T&originHeight=1152&originWidth=1438&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://i.bmp.ovh/imgs/2022/07/16/fc7f1a7787d947d1.png#crop=0&crop=0&crop=1&crop=1&id=WCmtw&originHeight=770&originWidth=1462&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://i.bmp.ovh/imgs/2022/07/16/d982dfeffc93194d.png#crop=0&crop=0&crop=1&crop=1&id=X0XWi&originHeight=746&originWidth=1450&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://i.bmp.ovh/imgs/2022/07/16/c72d2bb208786b4d.png#crop=0&crop=0&crop=1&crop=1&id=n6sqn&originHeight=674&originWidth=1494&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://i.bmp.ovh/imgs/2022/07/17/8cff726790465c70.png#crop=0&crop=0&crop=1&crop=1&id=pgD7S&originHeight=922&originWidth=960&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://i.bmp.ovh/imgs/2022/07/17/f70c199ad17d839d.png#crop=0&crop=0&crop=1&crop=1&id=oQkMq&originHeight=642&originWidth=1114&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://i.bmp.ovh/imgs/2022/07/17/9009c2c644e1cb1e.png#crop=0&crop=0&crop=1&crop=1&id=Yrwd3&originHeight=1360&originWidth=1432&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://i.bmp.ovh/imgs/2022/07/17/0bf7a7e4dcfa0edf.png#crop=0&crop=0&crop=1&crop=1&id=hFvS5&originHeight=1110&originWidth=1460&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://i.bmp.ovh/imgs/2022/07/17/f728d0b913a522eb.png#crop=0&crop=0&crop=1&crop=1&id=dQJAc&originHeight=744&originWidth=854&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/17/c0dc0dfc657d0867.png#crop=0&crop=0&crop=1&crop=1&id=ojq3K&originHeight=736&originWidth=840&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/17/a63c386fe86d030e.png#crop=0&crop=0&crop=1&crop=1&id=WIHzU&originHeight=310&originWidth=916&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/17/e4470285be9e73a5.png#crop=0&crop=0&crop=1&crop=1&id=zgTLF&originHeight=862&originWidth=2188&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/17/623924a23a7430b2.png">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/17/ce502110e6817313.png#crop=0&crop=0&crop=1&crop=1&id=ike3X&originHeight=1028&originWidth=1226&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/17/6d93bfc2a8d5292c.png#crop=0&crop=0&crop=1&crop=1&id=mJjPQ&originHeight=366&originWidth=1458&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/17/0e8193deed942bfd.png">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/17/b74a073b1f32239f.png#crop=0&crop=0&crop=1&crop=1&id=wnIQO&originHeight=1068&originWidth=1460&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/17/d9305aef676d77d3.png#crop=0&crop=0&crop=1&crop=1&id=rzot8&originHeight=1146&originWidth=1432&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/17/55715f2b73aa74f7.png#crop=0&crop=0&crop=1&crop=1&id=HvjrS&originHeight=696&originWidth=1070&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/17/6c03e9cdcc2194b5.png#crop=0&crop=0&crop=1&crop=1&id=nHKU5&originHeight=688&originWidth=1442&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/18/18535749842df6e7.png#crop=0&crop=0&crop=1&crop=1&id=ZRRHj&originHeight=852&originWidth=1600&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/18/ca072fae878171be.png#crop=0&crop=0&crop=1&crop=1&id=Fy6uB&originHeight=1238&originWidth=1468&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/18/e66cbfae5bdca68e.png#crop=0&crop=0&crop=1&crop=1&id=R7n6V&originHeight=774&originWidth=1016&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/18/8c26352433834ce8.png#crop=0&crop=0&crop=1&crop=1&id=k4JBv&originHeight=736&originWidth=866&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/18/033fb0b903539914.png#crop=0&crop=0&crop=1&crop=1&id=eUO9O&originHeight=1078&originWidth=1442&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/18/6c3978acf2f44ffc.png#crop=0&crop=0&crop=1&crop=1&id=z62rK&originHeight=1450&originWidth=1470&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/18/5492fc440959c00f.png#crop=0&crop=0&crop=1&crop=1&id=H3r1r&originHeight=874&originWidth=940&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/18/906a8d1ed6db4003.png#crop=0&crop=0&crop=1&crop=1&id=At2dn&originHeight=794&originWidth=930&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/18/c7c815f135c0f0a8.png#crop=0&crop=0&crop=1&crop=1&id=Fpw4s&originHeight=840&originWidth=1086&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/18/6fc27f6545f30cef.png#crop=0&crop=0&crop=1&crop=1&id=UGkl3&originHeight=854&originWidth=1020&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/18/e5f75dfe19510824.png#crop=0&crop=0&crop=1&crop=1&id=oUnxF&originHeight=824&originWidth=918&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/18/06adffe6276d276f.png#crop=0&crop=0&crop=1&crop=1&id=HQL29&originHeight=876&originWidth=940&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/18/8615a8301d802cbf.png#crop=0&crop=0&crop=1&crop=1&id=bT0yi&originHeight=800&originWidth=898&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/18/7c109ee58a621b13.png#crop=0&crop=0&crop=1&crop=1&id=akw2q&originHeight=818&originWidth=938&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/18/06adffe6276d276f.png#crop=0&crop=0&crop=1&crop=1&id=HD54V&originHeight=876&originWidth=940&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/18/a161da6f239d332e.png#crop=0&crop=0&crop=1&crop=1&id=xS0SO&originHeight=676&originWidth=1690&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/19/34f09e0720835bbf.png#crop=0&crop=0&crop=1&crop=1&id=q6ZVV&originHeight=1234&originWidth=1448&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/19/6d8cf26e89926337.png#crop=0&crop=0&crop=1&crop=1&id=bdM7U&originHeight=666&originWidth=1678&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/19/0e447d0e49a9fc87.png#crop=0&crop=0&crop=1&crop=1&id=JOemb&originHeight=970&originWidth=1446&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/19/76610c47f983f840.png#crop=0&crop=0&crop=1&crop=1&id=Bdf8k&originHeight=301&originWidth=423&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/16/j4ji0x.png#crop=0&crop=0&crop=1&crop=1&id=cKgo3&originHeight=718&originWidth=1194&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/19/6d8cf26e89926337.png#crop=0&crop=0&crop=1&crop=1&id=tiGdy&originHeight=666&originWidth=1678&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/19/ca619432420f26ee.png#crop=0&crop=0&crop=1&crop=1&id=NVA4e&originHeight=468&originWidth=668&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/19/817c4fb6b00ff29e.png#crop=0&crop=0&crop=1&crop=1&id=vC3ki&originHeight=450&originWidth=1148&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/19/552858884eac2cba.png#crop=0&crop=0&crop=1&crop=1&id=EZwso&originHeight=880&originWidth=1494&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/19/38ef0b9e0e99c0e7.png#crop=0&crop=0&crop=1&crop=1&id=mG2OL&originHeight=1150&originWidth=1444&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/19/5d94ff12b40ae024.png#crop=0&crop=0&crop=1&crop=1&id=HDbpw&originHeight=1402&originWidth=1446&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/19/202b6128a20a118e.png#crop=0&crop=0&crop=1&crop=1&id=nDEol&originHeight=1112&originWidth=1466&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/20/c8fb511179a25999.png#crop=0&crop=0&crop=1&crop=1&id=pY4u2&originHeight=1386&originWidth=1442&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/20/08ffeaba0e8600be.png#crop=0&crop=0&crop=1&crop=1&id=oncku&originHeight=958&originWidth=1608&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/20/a75fcba3cc6f46ab.png#crop=0&crop=0&crop=1&crop=1&id=HknCP&originHeight=980&originWidth=1452&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/20/63519fa54826011e.png#crop=0&crop=0&crop=1&crop=1&id=WOBwI&originHeight=1450&originWidth=1460&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/20/01f57ee4ab018b3f.png#crop=0&crop=0&crop=1&crop=1&id=mRskt&originHeight=976&originWidth=1492&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/20/c437418baee0ab8d.png">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/20/1bf101ef2c1d3ccb.png">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/20/31932608faf0d171.png">
<meta property="og:image" content="https://labuladong.github.io/algo/images/%e8%ae%be%e8%ae%a1Twitter/merge.gif">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/21/42ae8f27d056f5d4.png">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/21/52073fda17f7e8b2.png">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/21/6855db9918e34ab8.png">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/21/513cac8fe97f601e.png">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/21/b6dd7cc2877a77cd.png">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/21/df21251abd234070.png">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/21/40e71b8a0943206f.png">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/21/45426aae419cc007.png">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/21/13a39f5626b8b74f.png">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/21/c0b6621db903d1c8.png">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/21/7432871a0c5dc392.png">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/22/6152a56df1837b8e.png">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/22/ed461f444ea0ada1.png">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/22/608e329dffe43942.png">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/22/2f04aa61fc3195cd.png">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/22/322a026beeb1b1a5.png">
<meta property="article:published_time" content="2022-07-06T08:26:01.683Z">
<meta property="article:modified_time" content="2022-07-22T06:50:26.753Z">
<meta property="article:author" content="Ssssv11">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s1.ax1x.com/2022/07/11/j6jdt1.png">


<link rel="canonical" href="https://ssssv11.github.io/2022/07/06/%E7%AE%97%E6%B3%95/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>
<title>算法笔记 | Ssssv</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Ssssv</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">26</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">43</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">2.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C%E3%80%81%E5%89%8D%E7%BC%80%E7%A7%AF"><span class="nav-number">2.1.</span> <span class="nav-text">前缀和、前缀积</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84"><span class="nav-number">2.2.</span> <span class="nav-text">差分数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">2.3.</span> <span class="nav-text">双指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="nav-number">2.3.1.</span> <span class="nav-text">快慢指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A6%E5%8F%B3%E6%8C%87%E9%92%88"><span class="nav-number">2.3.2.</span> <span class="nav-text">左右指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86%E9%97%AE%E9%A2%98"><span class="nav-number">2.4.</span> <span class="nav-text">二维数组的遍历问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-number">2.5.</span> <span class="nav-text">滑动窗口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">2.6.</span> <span class="nav-text">二分查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E4%B8%80%E4%B8%AA%E6%95%B0"><span class="nav-number">2.6.1.</span> <span class="nav-text">查找一个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E8%BE%B9%E7%95%8C%E7%9A%84%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2"><span class="nav-number">2.6.2.</span> <span class="nav-text">寻找边界的二分搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E9%97%AE%E9%A2%98%E7%9A%84%E6%B3%9B%E5%8C%96"><span class="nav-number">2.6.3.</span> <span class="nav-text">二分查找问题的泛化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">3.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88-1"><span class="nav-number">3.1.</span> <span class="nav-text">双指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E3%80%81%E5%88%86%E8%A7%A3%E9%93%BE%E8%A1%A8"><span class="nav-number">3.1.1.</span> <span class="nav-text">合并、分解链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">3.1.2.</span> <span class="nav-text">单链表的倒数第 k 个节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E7%82%B9"><span class="nav-number">3.1.3.</span> <span class="nav-text">单链表的中点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E7%8E%AF"><span class="nav-number">3.1.4.</span> <span class="nav-text">判断链表是否包含环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4"><span class="nav-number">3.1.5.</span> <span class="nav-text">两个链表是否相交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">3.1.6.</span> <span class="nav-text">反转链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="nav-number">3.1.7.</span> <span class="nav-text">回文链表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">4.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%B2%E9%A2%86"><span class="nav-number">5.1.</span> <span class="nav-text">纲领</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF"><span class="nav-number">5.2.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.3.</span> <span class="nav-text">构造二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">5.4.</span> <span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">5.5.</span> <span class="nav-text">二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%80%A7"><span class="nav-number">5.5.1.</span> <span class="nav-text">特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C"><span class="nav-number">5.5.2.</span> <span class="nav-text">基础操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0"><span class="nav-number">5.5.3.</span> <span class="nav-text">构造</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">5.6.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">5.7.</span> <span class="nav-text">最近公共祖先</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="nav-number">5.7.1.</span> <span class="nav-text">寻找一个元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">5.7.2.</span> <span class="nav-text">二叉树的最近公共祖先</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0"><span class="nav-number">5.8.</span> <span class="nav-text">完全二叉树的节点数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE"><span class="nav-number">6.</span> <span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E5%92%8C%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.1.</span> <span class="nav-text">图的逻辑结构和具体实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">6.2.</span> <span class="nav-text">图的遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">6.3.</span> <span class="nav-text">拓扑排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95-DFS"><span class="nav-number">6.3.1.</span> <span class="nav-text">环检测算法(DFS)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-DFS"><span class="nav-number">6.3.2.</span> <span class="nav-text">拓扑排序算法(DFS)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95-BFS"><span class="nav-number">6.3.3.</span> <span class="nav-text">环检测算法(BFS)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-BFS"><span class="nav-number">6.3.4.</span> <span class="nav-text">拓扑排序(BFS)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE%E5%88%A4%E5%AE%9A"><span class="nav-number">6.4.</span> <span class="nav-text">二分图判定</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE%E7%AE%80%E4%BB%8B"><span class="nav-number">6.4.1.</span> <span class="nav-text">二分图简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE%E5%88%A4%E5%AE%9A%E6%80%9D%E8%B7%AF"><span class="nav-number">6.4.2.</span> <span class="nav-text">二分图判定思路</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86-UNION-FIND-%E7%AE%97%E6%B3%95"><span class="nav-number">6.5.</span> <span class="nav-text">并查集(UNION-FIND)算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="nav-number">6.5.1.</span> <span class="nav-text">基本思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E6%80%A7%E4%BC%98%E5%8C%96"><span class="nav-number">6.5.2.</span> <span class="nav-text">平衡性优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9"><span class="nav-number">6.5.3.</span> <span class="nav-text">路径压缩</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kruskal-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95"><span class="nav-number">6.6.</span> <span class="nav-text">Kruskal 最小生成树算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">6.6.1.</span> <span class="nav-text">最小生成树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Union-Find-%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-number">6.6.2.</span> <span class="nav-text">Union-Find 并查集算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kruskal-%E7%AE%97%E6%B3%95"><span class="nav-number">6.6.3.</span> <span class="nav-text">Kruskal 算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Prim-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95"><span class="nav-number">6.7.</span> <span class="nav-text">Prim 最小生成树算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94-Kruskal-%E7%AE%97%E6%B3%95"><span class="nav-number">6.7.1.</span> <span class="nav-text">对比 Kruskal 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%87%E5%88%86%E5%AE%9A%E7%90%86"><span class="nav-number">6.7.2.</span> <span class="nav-text">切分定理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Prim-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.7.3.</span> <span class="nav-text">Prim 算法实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BFS-%E7%AE%97%E6%B3%95"><span class="nav-number">6.8.</span> <span class="nav-text">BFS 算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dijkstra-%E7%AE%97%E6%B3%95"><span class="nav-number">6.9.</span> <span class="nav-text">Dijkstra 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E6%8A%BD%E8%B1%A1"><span class="nav-number">6.9.1.</span> <span class="nav-text">图的抽象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E7%BA%A7%E9%81%8D%E5%8E%86%E5%92%8C-BFS-%E7%AE%97%E6%B3%95"><span class="nav-number">6.9.2.</span> <span class="nav-text">二叉树层级遍历和 BFS 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dijkstra-%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6"><span class="nav-number">6.9.3.</span> <span class="nav-text">Dijkstra 算法框架</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">7.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#LRU-%E7%AE%97%E6%B3%95"><span class="nav-number">7.1.</span> <span class="nav-text">LRU 算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LFU-%E7%AE%97%E6%B3%95"><span class="nav-number">7.2.</span> <span class="nav-text">LFU 算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%9C%8B%E5%8F%8B%E5%9C%88%E6%97%B6%E9%97%B4%E7%BA%BF"><span class="nav-number">7.3.</span> <span class="nav-text">设计朋友圈时间线</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E6%A0%91%E7%AE%97%E6%B3%95"><span class="nav-number">7.4.</span> <span class="nav-text">前缀树算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Trie-%E6%A0%91%E5%8E%9F%E7%90%86"><span class="nav-number">7.4.1.</span> <span class="nav-text">Trie 树原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TrieMap-x2F-TrieSet-API-%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.4.2.</span> <span class="nav-text">TrieMap&#x2F;TrieSet API 实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88%E7%BB%93%E6%9E%84"><span class="nav-number">7.5.</span> <span class="nav-text">单调栈结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88%E6%A8%A1%E7%89%88"><span class="nav-number">7.5.1.</span> <span class="nav-text">单调栈模版</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E7%8E%AF%E5%BD%A2%E6%95%B0%E7%BB%84"><span class="nav-number">7.5.2.</span> <span class="nav-text">处理环形数组</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ssssv11"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">Ssssv11</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTE=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Ssssv11"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ssssv11.github.io/2022/07/06/%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="Ssssv11">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ssssv">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          算法笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-07-06 16:26:01" itemprop="dateCreated datePublished" datetime="2022-07-06T16:26:01+08:00">2022-07-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-07-22 14:50:26" itemprop="dateModified" datetime="2022-07-22T14:50:26+08:00">2022-07-22</time>
      </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <center>LeetCode 刷题笔记</center>

<span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>算法学习的记录，LeetCode 刷题中…</p>
<p>感谢 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xhYnVsYWRvbmcvZnVja2luZy1hbGdvcml0aG0=">Labuladong<i class="fa fa-external-link-alt"></i></span> 、<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lvdW5neWFuZ3lhbmcwNC9sZWV0Y29kZS1tYXN0ZXI=">Carl<i class="fa fa-external-link-alt"></i></span> 等大佬免费的学习资料</p>
<p>Github: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZQ==">https://github.com/Ssssv11/AlgorithmNote<i class="fa fa-external-link-alt"></i></span></p>
<p>Gitee : <span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vU3Nzc3YxMS9BbGdvcml0aG1Ob3Rl">https://gitee.com/Ssssv11/AlgorithmNote<i class="fa fa-external-link-alt"></i></span></p>
<p>Blog : <a href="https://ssssv11.github.io/2022/07/06/%E7%AE%97%E6%B3%95/">https://ssssv11.github.io/2022/07/06/%E7%AE%97%E6%B3%95/</a></p>
</br>


<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="前缀和、前缀积"><a href="#前缀和、前缀积" class="headerlink" title="前缀和、前缀积"></a>前缀和、前缀积</h2><p><strong>前缀和技巧适用于快速、频繁地计算一个索引区间内的元素之和，它不会修改原始数组。</strong></p>
<p>核⼼思路是创建⼀个数组 <code>preSum</code>， <code>preSum[i]</code> 记录 <code>nums[0..i-1]</code> 的累加和(<code>preSum[0] = 0</code>)。若需要计算某个索引区间 <code>[i, j]</code> 内的元素之和，只需要计算 <code>preSum[j+1] - preSum[i]</code> 的值即可。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8zMDMuJUU1JThDJUJBJUU1JTlGJTlGJUU1JTkyJThDJUU2JUEzJTgwJUU3JUI0JUEyLSVFNiU5NSVCMCVFNyVCQiU4NCVFNCVCOCU4RCVFNSU4RiVBRiVFNSU4RiU5OC5qYXZh">303.区域和检索-数组不可变<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yYW5nZS1zdW0tcXVlcnktaW1tdXRhYmxlLw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8zMDQuJUU0JUJBJThDJUU3JUJCJUI0JUU1JThDJUJBJUU1JTlGJTlGJUU1JTkyJThDJUU2JUEzJTgwJUU3JUI0JUEyLSVFNyU5RiVBOSVFOSU5OCVCNSVFNCVCOCU4RCVFNSU4RiVBRiVFNSU4RiU5OC5qYXZh">304.二维区域和检索-矩阵不可变<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yYW5nZS1zdW0tcXVlcnktMmQtaW1tdXRhYmxlLw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<blockquote>
<p>具体解释见代码内注释</p>
</blockquote>
<p>这两道基础题分别从一维和二维层面运用前缀和来解决问题。主要需要弄清楚该计算从哪儿到哪儿的和以及其中任意索引区间内的元素之和该如何表示。<br />若使用前缀和(积)方法且前缀和(积)数组为了方便计算而将首位置为0(或1)，则需要时刻注意其起始索引为 1。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8yMzguJUU5JTk5JUE0JUU4JTg3JUFBJUU4JUJBJUFCJUU0JUJCJUE1JUU1JUE0JTk2JUU2JTk1JUIwJUU3JUJCJTg0JUU3JTlBJTg0JUU0JUI5JTk4JUU3JUE3JUFGLmphdmE=">238.除自身以外数组的乘积<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wcm9kdWN0LW9mLWFycmF5LWV4Y2VwdC1zZWxmLw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8xMzUyLiVFNiU5QyU4MCVFNSU5MCU4RS1rLSVFNCVCOCVBQSVFNiU5NSVCMCVFNyU5QSU4NCVFNCVCOSU5OCVFNyVBNyVBRi5qYXZh">1352.最后-k-个数的乘积<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wcm9kdWN0LW9mLXRoZS1sYXN0LWstbnVtYmVycy8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>与前缀和思想相似，这两道求积的问题也可以通过先求前缀积再根据具体情况考虑特殊之处。如 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8yMzguJUU5JTk5JUE0JUU4JTg3JUFBJUU4JUJBJUFCJUU0JUJCJUE1JUU1JUE0JTk2JUU2JTk1JUIwJUU3JUJCJTg0JUU3JTlBJTg0JUU0JUI5JTk4JUU3JUE3JUFGLmphdmE=">#238<i class="fa fa-external-link-alt"></i></span> 可以使用 <em>前缀积+后缀积</em> 的方式来实现不使用除法解答；<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8xMzUyLiVFNiU5QyU4MCVFNSU5MCU4RS1rLSVFNCVCOCVBQSVFNiU5NSVCMCVFNyU5QSU4NCVFNCVCOSU5OCVFNyVBNyVBRi5qYXZh">#1352<i class="fa fa-external-link-alt"></i></span> 需要在插入 0 后清空当前前缀积重新开始计算。</p>
</br>


<h2 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h2><p><strong>差分数组的主要适⽤场景是频繁对原始数组的某个区间的元素进⾏增减。</strong><br />若需要对数组 <code>nums[i..j]</code> 全部加 1，再给 <code>nums[k..l]</code> 全部减 2 等等一系列增减操作，最后返回增减后的数组。常规思路就是使用 for 循环对指定区间内的元素进行加减，但这样对 <code>nums</code> 的修改非常频繁且效率低下，时间复杂度为 <code>O(N)</code>。<br />使用差分数组与前缀和构造的 <code>preSum</code> 数组相似，可以为 <code>nums</code> 数组构造⼀个差分数组 <code>diff</code>， <code>diff[i]</code> 就是 <code>nums[i]</code> 和 <code>nums[i-1]</code> 的差：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nums[] = &#123;5, 7, 9, 2, 3&#125;</span></span><br><span class="line"><span class="comment">// diff[] = &#123;5, 2, 2, -7, 1&#125;</span></span><br><span class="line"><span class="type">int</span>[] diff = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line"><span class="comment">// 构造差分数组</span></span><br><span class="line">diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，如果需要通过 <code>diff</code> 数组构造结果数组 <code>nums</code>，只需要:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[diff.length];</span><br><span class="line"><span class="comment">// 根据差分数组构造结果数组</span></span><br><span class="line">res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; diff.length; i++) &#123;</span><br><span class="line">    res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过构造差分数组 <code>diff</code> 就可以快速地对指定区间内的元素进行增减操作。如果需要将区间 <code>nums[i..j]</code> 内的元素全部加 2，那么只需要让 <code>diff[i] += 2</code>，然后再让 <code>diff[j+1] -= 2</code> 即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nums[] = &#123;5, 7, 9, 2, 3&#125;</span></span><br><span class="line"><span class="comment">// diff[] = &#123;5, 4, 2, -7, -1&#125;</span></span><br><span class="line">                i      j</span><br><span class="line"><span class="comment">// res[] = &#123;5, 9, 11, 4, 3&#125;</span></span><br></pre></td></tr></table></figure>

<p>这是因为 <code>diff[i] += 2</code> 后就相当于为 <code>nums[i..]</code> 的所有元素都进行了加 2 操作，<code>diff[j+1] -= 2</code> 就相当于为 <code>nums[j+1..]</code> 的所有元素进行了减 2 操作，因此这样就相当于只对区间 <code>nums[i..j]</code> 进行了加 2 操作。<br />只需要花费 <code>O(1)</code> 的时间修改 <code>diff</code> 数组，就给 <code>nums</code> 的整个区间做了修改。多次修改 <code>diff</code> 后再通过计算就可以得到 <code>nums</code> 修改后的结果。</p>
<hr>
<p>考虑到差分数组代码的复用性，可以将其抽象为一个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Diff</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] diff;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create the diff array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Diff</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">assert</span> nums.length &gt; <span class="number">0</span>;</span><br><span class="line">        diff = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        diff[i] += val;</span><br><span class="line">        <span class="comment">// 若 j+1 &lt; diff.length 则表示修改是从 i 到最后</span></span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt; diff.length) &#123;</span><br><span class="line">            diff[j + <span class="number">1</span>] -= val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the result of the origin array by diff[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] result() &#123;</span><br><span class="line">        <span class="type">int</span> res[] = <span class="keyword">new</span> <span class="title class_">int</span>[diff.length];</span><br><span class="line">        res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; diff.length; i++) &#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8zNzAuJUU1JThDJUJBJUU5JTk3JUI0JUU1JThBJUEwJUU2JUIzJTk1LmphdmE=">370.区间加法<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yYW5nZS1hZGRpdGlvbi8=">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8xMTA5LiVFOCU4OCVBQSVFNyU4RiVBRCVFOSVBMiU4NCVFOCVBRSVBMiVFNyVCQiU5RiVFOCVBRSVBMS5qYXZh">1109.航班预订统计<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3Jwb3JhdGUtZmxpZ2h0LWJvb2tpbmdzLw==">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8xMDk0LiVFNiU4QiVCQyVFOCVCRCVBNi5qYXZh">1094.拼车<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jYXItcG9vbGluZy8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>这三道题都是典型的需要使用差分数组进行解答的题目，可以抽象出一个 <code>Diff</code> 差分数组工具类来提升代码的复用性。需要注意在初始化 <code>nums[]</code> 时其长度的选择：进行增减操作次数的最大值。</p>
</br>


<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p><strong>双指针技巧主要分为两类：左右指针和快慢指针。</strong></p>
<ul>
<li>左右指针：两个指针相向而行或者相背而行，一左一右。</li>
<li>快慢指针：两个指针同向而行，一快一慢。</li>
</ul>
<p>在数组中并没有真正意义上的指针，但可以把索引当做数组中的指针，这样也可以在数组中施展双指针技巧。</p>
</br>

<h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p><strong>快慢指针常用在数组问题中要求原地修改数组。</strong></p>
<p>原地修改即不允许 <code>new</code> 新数组，只能在原数组上操作，返回一个长度，通过返回的长度和原始数组得到结果。<br />快慢指针通过慢指针指向需要修改的元素，快指针遍历数组，当快指针找到符合条件的元素时，将慢指针指向的元素修改为新值，然后慢指针向后移动一位，快指针向后移动一位，继续遍历。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8yNi4lRTUlODglQTAlRTklOTklQTQlRTYlOUMlODklRTUlQkElOEYlRTYlOTUlQjAlRTclQkIlODQlRTQlQjglQUQlRTclOUElODQlRTklODclOEQlRTUlQTQlOEQlRTklQTElQjkuamF2YQ==">26.删除有序数组中的重复项<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtZHVwbGljYXRlcy1mcm9tLXNvcnRlZC1odHRwczovL2dpdGh1Yi5jb20vU3Nzc3YxMS9BbGdvcml0aG1Ob3RlL2Jsb2IvbWFzdGVyL0FycmF5Lw==">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8yNy4lRTclQTclQkIlRTklOTklQTQlRTUlODUlODMlRTclQjQlQTAuamF2YQ==">27.移除元素<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtZWxlbWVudC8=">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8yODMuJUU3JUE3JUJCJUU1JThBJUE4JUU5JTlCJUI2LmphdmE=">283.移动零<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tb3ZlLXplcm9lcy8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>这三道题非常相似，都使用快慢指针来实现原地修改。</p>
<br>


<h3 id="左右指针"><a href="#左右指针" class="headerlink" title="左右指针"></a>左右指针</h3><p><strong>左右指针常用在有序数组和字符串问题中。</strong></p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS81LiVFNiU5QyU4MCVFOSU5NSVCRiVFNSU5QiU5RSVFNiU5NiU4NyVFNSVBRCU5MCVFNCVCOCVCMi5qYXZh">5.最长回文子串<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXBhbGluZHJvbWljLXN1YnN0cmluZy8=">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8xMjUuJUU5JUFBJThDJUU4JUFGJTgxJUU1JTlCJTlFJUU2JTk2JTg3JUU0JUI4JUIyLmphdmE=">125.验证回文串<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZC1wYWxpbmRyb21lLw==">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8xNjcuJUU0JUI4JUE0JUU2JTk1JUIwJUU0JUI5JThCJUU1JTkyJThDLWlpLSVFOCVCRSU5MyVFNSU4NSVBNSVFNiU5QyU4OSVFNSVCQSU4RiVFNiU5NSVCMCVFNyVCQiU4NC5qYXZh">167.两数之和 II - 输入有序数组<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90d28tc3VtLWlpLWlucHV0LWFycmF5LWlzLXNvcnRlZC8=">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8zNDQuJUU1JThGJThEJUU4JUJEJUFDJUU1JUFEJTk3JUU3JUFDJUE2JUU0JUI4JUIyLmphdmE=">344.反转字符串<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLXN0cmluZy8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>左右指针比较简单，根据题意进行相应操作即可。在二分查找中也有体现左右指针的特性。</p>
<br>


<h2 id="二维数组的遍历问题"><a href="#二维数组的遍历问题" class="headerlink" title="二维数组的遍历问题"></a>二维数组的遍历问题</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS80OC4lRTYlOTclOEIlRTglQkQlQUMlRTUlOUIlQkUlRTUlODMlOEYuamF2YQ==">48.旋转图像<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yb3RhdGUtaW1hZ2Uv">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS81NC4lRTglOUUlQkElRTYlOTclOEIlRTclOUYlQTklRTklOTglQjUuamF2YQ==">54.螺旋矩阵<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zcGlyYWwtbWF0cml4Lw==">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS81OS4lRTglOUUlQkElRTYlOTclOEIlRTclOUYlQTklRTklOTglQjUtaWkuamF2YQ==">59.螺旋矩阵 II<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zcGlyYWwtbWF0cml4LWlpLw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>对于矩阵的各种遍历需要多归纳总结规律，如矩阵的逆时针旋转可以按副对角线进行镜像对称，这与 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS80OC4lRTYlOTclOEIlRTglQkQlQUMlRTUlOUIlQkUlRTUlODMlOEYuamF2YQ==">#48<i class="fa fa-external-link-alt"></i></span> 题相反。</p>
</br>


<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p><strong>滑动窗口常用于解决子串问题。</strong></p>
<p>滑动窗口也是利用双指针来实现的，一个用于延伸现有窗口的 <code>right</code> 指针，和一个用于收缩窗口的 <code>left</code> 指针。在任意时刻，只有一个指针运动，而另一个保持静止。</p>
<hr>
<p>对于解决滑动窗口问题的代码框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> String <span class="title function_">slidingWindow</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    HashMap&lt;Character, Integer&gt; window = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 左右指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.length()) &#123;</span><br><span class="line">        <span class="comment">// 移入窗口的字符</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">        <span class="comment">// 扩大窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 数据操作</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// debug 输出</span></span><br><span class="line">        System.out.println(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左窗口是否需要收缩</span></span><br><span class="line">        <span class="keyword">while</span>(window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// 移出窗口的字符</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">            <span class="comment">// 收缩窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 数据操作</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中两处 <code>...</code> 表示的更新窗口数据的地方</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS83Ni4lRTYlOUMlODAlRTUlQjAlOEYlRTglQTYlODYlRTclOUIlOTYlRTUlQUQlOTAlRTQlQjglQjIuamF2YQ==">76.最小覆盖子串<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLXdpbmRvdy1zdWJzdHJpbmcv">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS80MzguJUU2JTg5JUJFJUU1JTg4JUIwJUU1JUFEJTk3JUU3JUFDJUE2JUU0JUI4JUIyJUU0JUI4JUFEJUU2JTg5JTgwJUU2JTlDJTg5JUU1JUFEJTk3JUU2JUFGJThEJUU1JUJDJTgyJUU0JUJEJThEJUU4JUFGJThELmphdmE=">438.找到字符串中所有字母异位词<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWFsbC1hbmFncmFtcy1pbi1hLXN0cmluZy8=">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS81NjcuJUU1JUFEJTk3JUU3JUFDJUE2JUU0JUI4JUIyJUU3JTlBJTg0JUU2JThFJTkyJUU1JTg4JTk3LmphdmE=">567.字符串的排列<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wZXJtdXRhdGlvbi1pbi1zdHJpbmcv">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>通过滑动窗口的代码框架可以很容易地写出这三题，思路都基本相似。主要需要考虑三个问题：</p>
<ol>
<li>什么时候应该扩大窗口？ </li>
<li>什么时候应该缩小窗口？ </li>
<li>什么时候得到一个合法的答案？</li>
</ol>
<br>


<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</p>
<hr>
<p>二分查找代码框架（<strong>在有序数组中搜索指定元素</strong>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = ...;</span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8yNzguJUU3JUFDJUFDJUU0JUI4JTgwJUU0JUI4JUFBJUU5JTk0JTk5JUU4JUFGJUFGJUU3JTlBJTg0JUU3JTg5JTg4JUU2JTlDJUFDLmphdmE=">278.第一个错误的版本<i class="fa fa-external-link-alt"></i></span> &amp;emsp;<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maXJzdC1iYWQtdmVyc2lvbi8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>分析二分查找的一个技巧是：不要出现 <code>else</code>，而是把所有情况用 <code>else if</code> 写清楚，这样可以清楚地展现所有细节。</p>
<p>其中 <code>...</code> 标记的部分，就是可能出现细节问题的地方，当见到一个二分查找的代码时，首先注意这几个地方。</p>
<p><strong>计算 <code>mid</code> 时需要防止溢出，代码中 <code>left + (right - left) / 2</code>与 <code>(left + right) / 2</code> 等价，但是有效防止了 <code>left</code> 和 <code>right</code> 太大，直接相加导致溢出的情况。</strong></p>
<br>


<h3 id="查找一个数"><a href="#查找一个数" class="headerlink" title="查找一个数"></a>查找一个数</h3><p>二分查找最普通的用法，即搜索一个数，如果存在，返回其索引，否则返回 -1。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS83MDQuJUU0JUJBJThDJUU1JTg4JTg2JUU2JTlGJUE1JUU2JTg5JUJFLmphdmE=">704.二分查找<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktc2VhcmNoLw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>代码中的细节：</p>
<ol>
<li>为什么 while 循环的条件中是 &lt;&#x3D;，而不是 &lt; ？</li>
</ol>
<p>因为初始化 <code>right</code> 时赋值为 <code>nums.length - 1</code>，即最后一个元素的索引，而不是 <code>nums.length</code>。</p>
<p>这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 <code>[left, right]</code>，后者相当于左闭右开区间 [<code>left, right)</code>（索引大小为 <code>nums.length</code> 越界）。</p>
<p>这里使用的是前者 <code>[left, right]</code> 闭区间。这个区间就是每次进行搜索的区间。</p>
<p>而 <code>while(left &lt;= right)</code> 的终止条件是 <code>left == right + 1</code>，即 <code>[right + 1, right]</code>，这时区间为空。所以 while 循环终止是正确的，直接返回 -1。</p>
<p><code>while(left &lt; right)</code> 的终止条件是 <code>left == right</code>，即 <code>[right, right]</code>，区间中还有 <code>right</code>，但此时 while 循环终止了。也就是说此时区间中索引 <code>right</code> 没有被搜索，如果这时候直接返回 -1 就是错误的。</p>
<p>若需使用 <code>while(left &lt; right)</code>，也可以在返回时再次搜索 <code>right</code> 处值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>为什么 <code>left = mid + 1</code>，<code>right = mid - 1</code> ？</li>
</ol>
<p>当查到 <code>mid &gt; target</code> 时，说明 <code>target</code> 在 <code>mid</code> 右边，所以 <code>left = mid + 1</code>，即搜索右半部分。同理，当查到 <code>mid &lt; target</code> 时，说明 <code>target</code> 在 <code>mid</code> 左边，所以 <code>right = mid - 1</code>，即搜索左半部分。</p>
<ol start="3">
<li>此算法的缺陷 ？</li>
</ol>
<p>如有序数组 <code>nums = [1,2,2,2,3]</code>，<code>target</code> 为 2，此算法返回的索引为 2。但如果想得到 <code>target</code> 的左侧边界，即索引 1，或者 <code>target</code> 的右侧边界，即索引 3 的话此算法是无法处理的。</p>
<p>但是如果当找到一个 <code>target</code>，然后向左或向右线性搜索又难以保证二分查找对数级的复杂度。</p>
<br>


<h3 id="寻找边界的二分搜索"><a href="#寻找边界的二分搜索" class="headerlink" title="寻找边界的二分搜索"></a>寻找边界的二分搜索</h3><p>对普通二分查找算法稍加改动就可以实现寻找边界的二分查找。重点是在查找到 <code>target</code> 时并不马上返回，而是继续缩小范围继续查找左边或右边是否还有 <code>target。</code></p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8zNC4lRTUlOUMlQTglRTYlOEUlOTIlRTUlQkElOEYlRTYlOTUlQjAlRTclQkIlODQlRTQlQjglQUQlRTYlOUYlQTUlRTYlODklQkUlRTUlODUlODMlRTclQjQlQTAlRTclOUElODQlRTclQUMlQUMlRTQlQjglODAlRTQlQjglQUElRTUlOTIlOEMlRTYlOUMlODAlRTUlOTAlOEUlRTQlQjglODAlRTQlQjglQUElRTQlQkQlOEQlRTclQkQlQUUuamF2YQ==">34.在排序数组中查找元素的第一个和最后一个位置<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWZpcnN0LWFuZC1sYXN0LXBvc2l0aW9uLW9mLWVsZW1lbnQtaW4tc29ydGVkLWh0dHBzOi8vZ2l0aHViLmNvbS9Tc3NzdjExL0FsZ29yaXRobU5vdGUvYmxvYi9tYXN0ZXIvQXJyYXkv">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><strong>二分思维的精髓就是：通过已知信息尽可能多地收缩（折半）搜索空间，从而增加穷举效率，快速找到目标。</strong></p>
<br>


<h3 id="二分查找问题的泛化"><a href="#二分查找问题的泛化" class="headerlink" title="二分查找问题的泛化"></a>二分查找问题的泛化</h3><p>什么问题可以运用二分搜索算法技巧？</p>
<p>首先要从题目中抽象出一个自变量 <code>x</code>，一个关于 <code>x</code> 的函数 <code>f(x)</code>，以及一个目标值 <code>target</code>。</p>
<p>同时，<code>x</code>, <code>f(x)</code>, <code>target</code> 还要满足以下条件：</p>
<ol>
<li><code>f(x)</code> 必须是在 <code>x</code> 上的单调函数。 </li>
<li>题目要求计算满足约束条件 <code>f(x) == target</code> 时的 <code>x</code> 的值。</li>
</ol>
<hr>
<p>二分查找代码框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数 f 是关于自变量 x 的单调函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数，在 f(x) == target 的约束下求 x 的最值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> ...;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> ... + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (f(mid) == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f(mid) &lt; target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f(mid) &gt; target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>...</code> 根据具体业务编写代码。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS84NzUuJUU3JTg4JUIxJUU1JTkwJTgzJUU5JUE2JTk5JUU4JTk1JTg5JUU3JTlBJTg0JUU3JThGJTgyJUU3JThGJTgyLmphdmE=">875.爱吃香蕉的珂珂<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9rb2tvLWVhdGluZy1iYW5hbmFzLw==">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS80MTAuJUU1JTg4JTg2JUU1JTg5JUIyJUU2JTk1JUIwJUU3JUJCJTg0JUU3JTlBJTg0JUU2JTlDJTgwJUU1JUE0JUE3JUU1JTgwJUJDLmphdmE=">410.分割数组的最大值<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zcGxpdC1hcnJheS1sYXJnZXN0LXN1bS8=">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8xMDExLiVFNSU5QyVBOEQlRTUlQTQlQTklRTUlODYlODUlRTklODAlODElRTglQkUlQkUlRTUlOEMlODUlRTglQTMlQjklRTclOUElODQlRTglODMlQkQlRTUlOEElOUIuamF2YQ==">1011.在D天内送达包裹的能力<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jYXBhY2l0eS10by1zaGlwLXBhY2thZ2VzLXdpdGhpbi1kLWRheXMv">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>最重要的是从题目中抽象出满足使用二分查找的自变量 <code>x</code>，以及关于 <code>x</code> 的函数 <code>f(x)</code>，以及目标值 <code>target</code>。其次是考虑如何编写 <code>f(x)</code> 以满足题目需求。</p>
<br>


<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h2><h3 id="合并、分解链表"><a href="#合并、分解链表" class="headerlink" title="合并、分解链表"></a>合并、分解链表</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9MaW5rZWRMaXN0LzIxLiVFNSU5MCU4OCVFNSVCOSVCNiVFNCVCOCVBNCVFNCVCOCVBQSVFNiU5QyU4OSVFNSVCQSU4RiVFOSU5MyVCRSVFOCVBMSVBOC5qYXZh">21.合并两个有序链表<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS10d28tc29ydGVkLWxpc3RzLw==">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9MaW5rZWRMaXN0LzIzLiVFNSU5MCU4OCVFNSVCOSVCNmslRTQlQjglQUElRTUlOEQlODclRTUlQkElOEYlRTklOTMlQkUlRTglQTElQTguamF2YQ==">23.合并k个升序链表<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS1rLXNvcnRlZC1saXN0cy8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>主要是要弄清楚如何找到最小的节点，合并两个有序链表时可以使用双指针来对比哪个更小，合并 k 个时使用优先队列来让更小的节点先出队。</p>
<p>另外，代码中还用到一个链表的算法题中是很常见的<strong>虚拟头结点技巧</strong>，也就是 <code>dummy</code> 节点。如果不使用 <code>dummy</code> 虚拟节点，代码会复杂很多，而有了 <code>dummy</code> 节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9MaW5rZWRMaXN0Lzg2LiVFNSU4OCU4NiVFOSU5QSU5NCVFOSU5MyVCRSVFOCVBMSVBOC5qYXZh">86.分隔链表<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXJ0aXRpb24tbGlzdC8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<br>


<h3 id="单链表的倒数第-k-个节点"><a href="#单链表的倒数第-k-个节点" class="headerlink" title="单链表的倒数第 k 个节点"></a>单链表的倒数第 k 个节点</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9MaW5rZWRMaXN0LzE5LiVFNSU4OCVBMCVFOSU5OSVBNCVFOSU5MyVCRSVFOCVBMSVBOCVFNyU5QSU4NCVFNSU4MCU5MiVFNiU5NSVCMCVFNyVBQyVBQy1uLSVFNCVCOCVBQSVFNyVCQiU5MyVFNyU4MiVCOS5qYXZh">19.删除链表的倒数第n个结点<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtbnRoLW5vZGUtZnJvbS1lbmQtb2YtbGlzdC8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>如何找到链表的倒数第 <code>k</code> 个节点是本题的重点，一般可以先遍历一次计算出链表的长度，第二次遍历删除第 <code>n - k</code> 个节点即可。但这样需要遍历两次链表。若使用两个指针 <code>p1</code>、<code>p2</code>，先让 <code>p1</code> 前进 <code>k</code> 步，再让 <code>p2</code> 与 <code>p1</code> 一起前进，那么当 <code>p1</code> 到达链表末端时 <code>p2</code> 所处的位置就是第 <code>n - k</code> 个节点处，即倒数第 <code>k</code> 个节点处。这样只需要一次遍历就能找到倒数第 <code>k</code> 个节点了。</p>
<br>


<h3 id="单链表的中点"><a href="#单链表的中点" class="headerlink" title="单链表的中点"></a>单链表的中点</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9MaW5rZWRMaXN0Lzg3Ni4lRTklOTMlQkUlRTglQTElQTglRTclOUElODQlRTQlQjglQUQlRTklOTclQjQlRTclQkIlOTMlRTclODIlQjkuamF2YQ==">876.链表的中间结点<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taWRkbGUtb2YtdGhlLWxpbmtlZC1saXN0Lw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>常规方法是先遍历链表得到 <code>n</code>，再遍历一次得到 <code>n / 2</code> 个节点。如果想一次遍历得到中间节点，可以使用<code>快慢指针</code>。让两个指针 <code>slow</code> 和 <code>fast</code> 同时从 <code>head</code> 出发，每当慢指针 <code>slow</code> 前进一步，快指针 <code>fast</code> 就前进两步。这样，当 <code>fast</code> 到达链表末尾时，<code>slow</code> 刚好指向了链表的中点。</p>
<br>


<h3 id="判断链表是否包含环"><a href="#判断链表是否包含环" class="headerlink" title="判断链表是否包含环"></a>判断链表是否包含环</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9MaW5rZWRMaXN0LzE0MS4lRTclOEUlQUYlRTUlQkQlQTIlRTklOTMlQkUlRTglQTElQTguamF2YQ==">141.环形链表<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9saW5rZWQtbGlzdC1jeWNsZS8=">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9MaW5rZWRMaXN0LzE0Mi4lRTclOEUlQUYlRTUlQkQlQTIlRTklOTMlQkUlRTglQTElQTgtSUkuamF2YQ==">142.环形链表 II<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9saW5rZWQtbGlzdC1jeWNsZS1paS8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>判断链表是否有环的问题也需要使用到寻找链表中点的思想。每当慢指针 <code>slow</code> 前进一步，快指针 <code>fast</code> 就前进两步，如果 <code>fast</code> 最终为 <code>null</code>，说明链表中没有环；如果最终 <code>fast</code> 和 <code>slow</code> 相遇，说明链表中有环。</p>
<p>若需要计算环的起点，可以在当快慢指针相遇时，让其中任一个指针指向头节点，然后让它们以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。</p>
<blockquote>
<p>假设指针相遇时，慢指针 <code>slow</code> 走了 <code>k</code> 步，那么快指针 <code>fast</code> 一定走了 <code>2k</code> 步。<code>fast</code> 一定比 <code>slow</code> 多走了 <code>k</code> 步，这多走的 <code>k</code> 步就是 <code>fast</code> 指针在环里转圈，所以 <code>k</code> 的值就是环长度的「整数倍」。<br />假设相遇点距环起点的距离为 <code>m</code>，那么环起点距头结点 <code>head</code> 的距离为 <code>k - m</code>，也就是说如果从 <code>head</code> 前进 <code>k - m</code> 步就能到达环起点。<br />如果从相遇点继续前进 <code>k - m</code> 步，也恰好到达环起点。因为 <code>fast</code> 指针从相遇点开始走 <code>k</code> 步可以转回到相遇点，那走 <code>k - m</code> 步肯定就走到环起点了。<br />所以，只要把快慢指针中的任一个重新指向 <code>head</code>，然后两个指针同速前进，<code>k - m</code> 步后一定会相遇，相遇之处就是环的起点了。</p>
</blockquote>
<br>

<h3 id="两个链表是否相交"><a href="#两个链表是否相交" class="headerlink" title="两个链表是否相交"></a>两个链表是否相交</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9MaW5rZWRMaXN0LzE2MC4lRTclOUIlQjglRTQlQkElQTQlRTklOTMlQkUlRTglQTElQTguamF2YQ==">160.相交链表<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnRlcnNlY3Rpb24tb2YtdHdvLWxpbmtlZC1saXN0cy8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>这个题直接的想法可能是用 <code>HashSet</code> 记录一个链表的所有节点，然后和另一条链表对比，但这就需要额外的空间。</p>
<p>若不使用额外空间而使用双指针 <code>p1</code>、<code>p2</code>，主要需要解决它们分别在两条链表上前进而不能同时走到公共节点，也就无法得到相交节点的问题，即如何让 <code>p1</code> 和 <code>p2</code> 两个指针能够同时到达相交节点。<br />因此可以让 <code>p1</code>、<code>p2</code> 遍历完当前链表后继续遍历对方的链表。这样就相当于两条链表在逻辑上连接在了一起，<code>p1</code>、<code>p2</code> 就可以同时进入相交节点。</p>
<hr>
<p>另外，也可以使两个指针到达尾部的距离相同来保证两个指针能够同时到达相交节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lenA</span> <span class="operator">=</span> <span class="number">0</span>, lenB = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算两条链表的长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> headA; p1 != <span class="literal">null</span>; p1 = p1.next) &#123;</span><br><span class="line">        lenA++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> headB; p2 != <span class="literal">null</span>; p2 = p2.next) &#123;</span><br><span class="line">        lenB++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 让 p1 和 p2 到达尾部的距离相同</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> headA, p2 = headB;</span><br><span class="line">    <span class="keyword">if</span> (lenA &gt; lenB) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lenA - lenB; i++) &#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lenB - lenA; i++) &#123;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 看两个指针是否会相同，p1 == p2 时有两种情况：</span></span><br><span class="line">    <span class="comment">// 1. 两条链表不相交，同时走到尾部空指针</span></span><br><span class="line">    <span class="comment">// 2. 两条链表相交，走到两条链表的相交点</span></span><br><span class="line">    <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><ol>
<li>递归反转整个链表</li>
</ol>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9MaW5rZWRMaXN0LzIwNi4lRTUlOEYlOEQlRTglQkQlQUMlRTklOTMlQkUlRTglQTElQTguamF2YQ==">206.反转链表<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLWxpbmtlZC1saXN0Lw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>反转单链表的迭代实现非常简单，而递归实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：输入一个单链表头结点，将该链表反转，返回新的头结点</span></span><br><span class="line">ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> reverse(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先 <code>reverse(head.next)</code> 执行完成后，整个链表除了头节点，其他节点都进行了反转且尾节点指向了 <code>null</code>，剩下只需要将尾节点指向头节点，头节点指向 <code>null</code> 即可。</p>
<ol start="2">
<li>反转链表的前 N 个节点</li>
</ol>
<p>若要实现如下函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将链表的前 n 个节点反转（n &lt;= 链表长度）</span></span><br><span class="line">ListNode <span class="title function_">reverseN</span><span class="params">(ListNode head, <span class="type">int</span> n)</span></span><br></pre></td></tr></table></figure>

<p>解决思路和反转整个链表差不多：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ListNode</span> <span class="variable">successor</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 后驱节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转以 head 为起点的 n 个节点，返回新的头结点</span></span><br><span class="line">ListNode <span class="title function_">reverseN</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 记录第 n + 1 个节点</span></span><br><span class="line">        successor = head.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以 head.next 为起点，需要反转前 n - 1 个节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> reverseN(head.next, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    head.next.next = head;</span><br><span class="line">    <span class="comment">// 让反转之后的 head 节点和后面的节点连起来</span></span><br><span class="line">    head.next = successor;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刚才直接把 <code>head.next</code> 设置为 <code>null</code>，因为整个链表反转后原来的 <code>head</code> 变成了整个链表的最后一个节点。但现在 <code>head</code> 节点在递归反转之后不一定是最后一个节点了，所以要记录后驱 <code>successor</code>（第 n + 1 个节点），反转之后将 <code>head</code> 连接上。</p>
<ol start="3">
<li>反转链表的一部分</li>
</ol>
<p>给一个索引区间 <code>[m, n]</code>（索引从 1 开始），仅仅反转区间中的链表元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> m, <span class="type">int</span> n)</span></span><br></pre></td></tr></table></figure>

<p>如果 <code>m == 1</code>，就相当于反转链表开头的 n 个元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 相当于反转前 n 个元素</span></span><br><span class="line">        <span class="keyword">return</span> reverseN(head, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <code>m != 1</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> reverseN(head, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前进到反转的起点触发 base case</span></span><br><span class="line">    head.next = reverseBetween(head.next, m - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9MaW5rZWRMaXN0LzkyLiVFNSU4RiU4RCVFOCVCRCVBQyVFOSU5MyVCRSVFOCVBMSVBOC1paS5qYXZh">92.反转链表 II<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLWxpbmtlZC1saXN0LWlpLw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>虽然迭代实现的时间复杂度与递归实现的时间复杂度相同，且递归实现的空间复杂度更高，但递归的思想很值得学习。</p>
<ol start="4">
<li>K 个一组反转链表</li>
</ol>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9MaW5rZWRMaXN0LzI1LmstJUU0JUI4JUFBJUU0JUI4JTgwJUU3JUJCJTg0JUU3JUJGJUJCJUU4JUJEJUFDJUU5JTkzJUJFJUU4JUExJUE4LmphdmE=">25.K 个一组反转链表<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLW5vZGVzLWluLWstZ3JvdXAv">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>由于对链表每次都进行 K 个一组的反转后，剩下的节点同样是一条链表，且规模较原链表小，因此递归同样适用于这个问题。先反转以 <code>head</code> 为头节点的 K 个节点，之后将第 <code>K + 1</code> 个节点作为 <code>head</code> 继续递归反转再将结果拼接即可。</p>
<p>迭代地反转一个区间内的节点：首先若反转整个链表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反转以 a 为头结点的链表</span></span><br><span class="line">ListNode <span class="title function_">reverse</span><span class="params">(ListNode a)</span> &#123;</span><br><span class="line">    ListNode pre, cur, nxt;</span><br><span class="line">    pre = <span class="literal">null</span>; cur = a; nxt = a;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        nxt = cur.next;</span><br><span class="line">        <span class="comment">// 逐个结点反转</span></span><br><span class="line">        cur.next = pre;</span><br><span class="line">        <span class="comment">// 更新指针位置</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = nxt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回反转后的头结点</span></span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反转以 a 为头结点的链表其实就是反转 a 到 <code>null</code> 之间的结点，同理，反转 a 到 b 之间的结点只需要：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (cur != b) &#123;</span><br><span class="line">        nxt = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = nxt;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对于 <code>reverseKGroup</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 区间 [a, b) 包含 k 个待反转元素</span></span><br><span class="line">    ListNode a, b;</span><br><span class="line">    a = b = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="comment">// 不足 k 个，不需要反转，base case</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        b = b.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反转前 k 个元素</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverse(a, b);</span><br><span class="line">    <span class="comment">// 递归反转后续链表并连接起来</span></span><br><span class="line">    a.next = reverseKGroup(b, k);</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9MaW5rZWRMaXN0LzIzNC4lRTUlOUIlOUUlRTYlOTYlODclRTklOTMlQkUlRTglQTElQTguamF2YQ==">234.回文链表<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYWxpbmRyb21lLWxpbmtlZC1saXN0Lw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>与二叉树遍历相似，链表也可以用递归的方式遍历，这里使用后序遍历就可以倒叙遍历链表，再与从头节点开始遍历比较是否相同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左侧指针</span></span><br><span class="line">ListNode left;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    left = head;</span><br><span class="line">    <span class="keyword">return</span> traverse(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">traverse</span><span class="params">(ListNode right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> traverse(right.next);</span><br><span class="line">    <span class="comment">// 后序遍历代码</span></span><br><span class="line">    res = res &amp;&amp; (right.val == left.val);</span><br><span class="line">    left = left.next;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这养做的核心逻辑就是把链表节点放入一个栈，然后再拿出来，这时候元素顺序就是反的。</p>
<p>但是这样的空间复杂度为 <code>O(N)</code>。若要不使用额外空间，可以先通过双指针中的快慢指针找到链表的中点，再从 <code>slow</code> 开始反转后面的链表，然后进行比较。</p>
<p>需要注意的是，若链表长度为奇数即 <code>fast</code> 指针没有指向 <code>null</code>，<code>slow</code> 还需要再前进一步。且此方法需要修改原链表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    ListNode slow, fast;</span><br><span class="line">    slow = fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (fast != <span class="literal">null</span>)</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    </span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> reverse(slow);</span><br><span class="line">    <span class="keyword">while</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left.val != right.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        left = left.next;</span><br><span class="line">        right = right.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9TdHJpbmcvNy4lRTYlOTUlQjQlRTYlOTUlQjAlRTUlOEYlOEQlRTglQkQlQUMuamF2YQ==">7.整数反转<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLWludGVnZXIv">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9TdHJpbmcvOC4lRTUlQUQlOTclRTclQUMlQTYlRTQlQjglQjIlRTglQkQlQUMlRTYlOEQlQTIlRTYlOTUlQjQlRTYlOTUlQjAtYXRvaS5qYXZh">8.字符串转换整数<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdHJpbmctdG8taW50ZWdlci1hdG9pLw==">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9TdHJpbmcvMTQuJUU2JTlDJTgwJUU5JTk1JUJGJUU1JTg1JUFDJUU1JTg1JUIxJUU1JTg5JThEJUU3JUJDJTgwLmphdmE=">14.最长公共前缀<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LWNvbW1vbi1wcmVmaXgv">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9TdHJpbmcvMjguJUU1JUFFJTlFJUU3JThFJUIwLXN0ci1zdHIuamF2YQ==">28.实现strStr()<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbXBsZW1lbnQtc3Ryc3RyLw==">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9TdHJpbmcvMzguJUU1JUE0JTk2JUU4JUE3JTgyJUU2JTk1JUIwJUU1JTg4JTk3LmphdmE=">38.外观数列<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3VudC1hbmQtc2F5Lw==">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9TdHJpbmcvMjQyLiVFNiU5QyU4OSVFNiU5NSU4OCVFNyU5QSU4NCVFNSVBRCU5NyVFNiVBRiU4RCVFNSVCQyU4MiVFNCVCRCU4RCVFOCVBRiU4RC5qYXZh">242.有效的字母异位词<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZC1hbmFncmFtLw==">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8zNDQuJUU1JThGJThEJUU4JUJEJUFDJUU1JUFEJTk3JUU3JUFDJUE2JUU0JUI4JUIyLmphdmE=">344.反转字符串<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLXN0cmluZy8=">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9TdHJpbmcvMzg3LiVFNSVBRCU5NyVFNyVBQyVBNiVFNCVCOCVCMiVFNCVCOCVBRCVFNyU5QSU4NCVFNyVBQyVBQyVFNCVCOCU4MCVFNCVCOCVBQSVFNSU5NCVBRiVFNCVCOCU4MCVFNSVBRCU5NyVFNyVBQyVBNi5qYXZh">387.字符串中的第一个唯一字符<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maXJzdC11bmlxdWUtY2hhcmFjdGVyLWluLWEtc3RyaW5nLw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>其中 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9TdHJpbmcvMjQyLiVFNiU5QyU4OSVFNiU5NSU4OCVFNyU5QSU4NCVFNSVBRCU5NyVFNiVBRiU4RCVFNSVCQyU4MiVFNCVCRCU4RCVFOCVBRiU4RC5qYXZh">#242<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9TdHJpbmcvMzg3LiVFNSVBRCU5NyVFNyVBQyVBNiVFNCVCOCVCMiVFNCVCOCVBRCVFNyU5QSU4NCVFNyVBQyVBQyVFNCVCOCU4MCVFNCVCOCVBQSVFNSU5NCVBRiVFNCVCOCU4MCVFNSVBRCU5NyVFNyVBQyVBNi5qYXZh">#387<i class="fa fa-external-link-alt"></i></span> 很相似，都是通过 Hash 映射比较异同，遇到这类题首先可以考虑使用 Hash。而 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9TdHJpbmcvNy4lRTYlOTUlQjQlRTYlOTUlQjAlRTUlOEYlOEQlRTglQkQlQUMuamF2YQ==">#7<i class="fa fa-external-link-alt"></i></span> 与 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9TdHJpbmcvOC4lRTUlQUQlOTclRTclQUMlQTYlRTQlQjglQjIlRTglQkQlQUMlRTYlOEQlQTIlRTYlOTUlQjQlRTYlOTUlQjAtYXRvaS5qYXZh">#8<i class="fa fa-external-link-alt"></i></span> 需要仔细考虑溢出问题。</p>
<br>

<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="纲领"><a href="#纲领" class="headerlink" title="纲领"></a>纲领</h2><p>二叉树解题的思维模式分两类：</p>
<ol>
<li><p>是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 <code>traverse</code> 函数配合外部变量来实现，这叫「遍历」的思维模式。</p>
</li>
<li><p>是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。</p>
</li>
</ol>
<p>无论使用哪种思维模式，都需要思考：</p>
<p>如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前&#x2F;中&#x2F;后序位置）做？递归函数会在所有节点上执行相同的操作，因此只需考虑一个节点。</p>
<p>前序位置，就是刚进入一个节点（元素）的时候，后序位置就是即将离开一个节点（元素）的时候，把代码写在不同位置，代码执行的时机也不同。</p>
<p><strong>前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点</strong>，绝不仅仅是三个顺序不同的 <code>List</code>。</p>
<p><strong>二叉树的所有问题，就是在前中后序位置注入巧妙的代码逻辑，去达到自己的目的。我们只需要单独思考每一个节点应该做什么，其他的交给二叉树遍历框架，递归会在所有节点上做相同的操作。</strong></p>
<ul>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzEwMS4lRTUlQUYlQjklRTclQTclQjAlRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTEuamF2YQ==">101.对称二叉树<i class="fa fa-external-link-alt"></i></span> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zeW1tZXRyaWMtdHJlZS8=">🔗<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzEwNC4lRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTElRTclOUElODQlRTYlOUMlODAlRTUlQTQlQTclRTYlQjclQjElRTUlQkElQTYuamF2YQ==">104.二叉树的最大深度<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWRlcHRoLW9mLWJpbmFyeS10cmVlLw==">🔗<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzEwMi4lRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTElRTclOUElODQlRTUlQjElODIlRTUlQkElOEYlRTklODElOEQlRTUlOEUlODYuamF2YQ==">102.二叉树的层序遍历<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1sZXZlbC1vcmRlci10cmF2ZXJzYWwv">🔗<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
<p>如 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzEwNC4lRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTElRTclOUElODQlRTYlOUMlODAlRTUlQTQlQTclRTYlQjclQjElRTUlQkElQTYuamF2YQ==">#104<i class="fa fa-external-link-alt"></i></span>，显然遍历一遍二叉树，用一个外部变量记录每个节点所在的深度，取最大值就可以得到最大深度，这就是遍历二叉树计算答案的思路。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 记录最大深度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录遍历到的节点的深度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历二叉树</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历位置</span></span><br><span class="line">        depth++;</span><br><span class="line">        <span class="comment">// 遍历的过程中记录最大深度</span></span><br><span class="line">        res = res &lt; depth ? depth : res;</span><br><span class="line">        traverse(root.left);</span><br><span class="line">        traverse(root.right);</span><br><span class="line">        <span class="comment">// 后序遍历位置</span></span><br><span class="line">        depth--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个解法很好理解，但为什么需要在前序位置增加 <code>depth</code>，在后序位置减小 <code>depth</code>？</p>
<p>因为前序位置是进入一个节点的时候，后序位置是离开一个节点的时候，<code>depth</code> 记录当前递归到的节点深度，把 <code>traverse</code> 理解成在二叉树上游走的一个指针，所以当然要这样维护。</p>
<p>至于对 <code>res</code> 的更新放到前中后序位置都可以，只要保证在进入节点之后，离开节点之前（即 <code>depth</code> 自增之后，自减之前）就行了。</p>
<p>一棵二叉树的最大深度也可以通过子树的最大深度推导出来，这就是分解问题计算答案的思路。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：输入根节点，返回这棵二叉树的最大深度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 利用定义，计算左右子树的最大深度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">    <span class="comment">// 整棵树的最大深度等于左右子树的最大深度取最大值，</span></span><br><span class="line">    <span class="comment">// 然后再加上根节点自己</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(leftMax, rightMax) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要明确递归函数的定义，这个解法也不难理解，但为什么主要的代码逻辑集中在后序位置？</p>
<p>因为这个思路正确的核心在于通过子树的最大深度推导出原树的深度首先需要利用递归函数的定义算出左右子树的最大深度，然后推出原树的最大深度，主要逻辑自然放在后序位置。</p>
<p>可以发现前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的。</p>
<p>因此，<strong>前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据</strong>。</p>
<p>举具体的例子，有一棵二叉树：</p>
<ol>
<li><p>如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？</p>
</li>
<li><p>如何打印出每个节点的左右子树各有多少节点？</p>
</li>
</ol>
<p>第一个问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树遍历函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    printf(<span class="string">&quot;节点 %s 在第 %d 层&quot;</span>, root, level);</span><br><span class="line">    traverse(root.left, level + <span class="number">1</span>);</span><br><span class="line">    traverse(root.right, level + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">traverse(root, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>第二个问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：输入一棵二叉树，返回这棵二叉树的节点总数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftCount</span> <span class="operator">=</span> count(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightCount</span> <span class="operator">=</span> count(root.right);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">    printf(<span class="string">&quot;节点 %s 的左子树有 %d 个节点，右子树有 %d 个节点&quot;</span>,</span><br><span class="line">            root, leftCount, rightCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> leftCount + rightCount + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个问题的根本区别在于：一个节点在第几层，从根节点遍历过来的过程就能顺带记录；而以一个节点为根的整棵子树有多少个节点，需要遍历完子树之后才能数清楚。</p>
<p><strong>一旦发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。</strong></p>
<ul>
<li><a href="Tree/652.%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E6%A0%91.java">652.寻找重复的子树</a>   <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWR1cGxpY2F0ZS1zdWJ0cmVlcy8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<br>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>运用纲领中的二叉树解题的思维模式：</p>
<ul>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzExNC4lRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTElRTUlQjElOTUlRTUlQkMlODAlRTQlQjglQkElRTklOTMlQkUlRTglQTElQTguamF2YQ==">114.二叉树展开为链表<i class="fa fa-external-link-alt"></i></span>   <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZmxhdHRlbi1iaW5hcnktdHJlZS10by1saW5rZWQtbGlzdC8=">🔗<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzExNi4lRTUlQTElQUIlRTUlODUlODUlRTYlQUYlOEYlRTQlQjglQUElRTglOEElODIlRTclODIlQjklRTclOUElODQlRTQlQjglOEIlRTQlQjglODAlRTQlQjglQUElRTUlOEYlQjMlRTQlQkUlQTclRTglOEElODIlRTclODIlQjklRTYlOEMlODclRTklOTIlODguamF2YQ==">116.填充每个节点的下一个右侧节点指针<i class="fa fa-external-link-alt"></i></span>   <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wb3B1bGF0aW5nLW5leHQtcmlnaHQtcG9pbnRlcnMtaW4tZWFjaC1ub2RlLw==">🔗<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzIyNi4lRTclQkYlQkIlRTglQkQlQUMlRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTEuamF2YQ==">226.翻转二叉树<i class="fa fa-external-link-alt"></i></span>   <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnZlcnQtYmluYXJ5LXRyZWUv">🔗<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
<p>每道二叉树的题都需要思考纲领中提到的：</p>
<ol>
<li><p>是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 <code>traverse</code> 函数配合外部变量来实现，这叫「遍历」的思维模式。</p>
</li>
<li><p>是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。</p>
</li>
</ol>
<p>无论使用哪种思维模式，都需要思考：</p>
<p>如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前&#x2F;中&#x2F;后序位置）做？递归函数会在所有节点上执行相同的操作，因此只需考虑一个节点。</p>
<p>对于 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzExNC4lRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTElRTUlQjElOTUlRTUlQkMlODAlRTQlQjglQkElRTklOTMlQkUlRTglQTElQTguamF2YQ==">#114<i class="fa fa-external-link-alt"></i></span> 由于函数的返回值限定为 <code>void</code>，因此无法通过简单的二叉树遍历来解决这道题。此时就应该考虑分解问题的思路。对于 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzExNi4lRTUlQTElQUIlRTUlODUlODUlRTYlQUYlOEYlRTQlQjglQUElRTglOEElODIlRTclODIlQjklRTclOUElODQlRTQlQjglOEIlRTQlQjglODAlRTQlQjglQUElRTUlOEYlQjMlRTQlQkUlQTclRTglOEElODIlRTclODIlQjklRTYlOEMlODclRTklOTIlODguamF2YQ==">#116<i class="fa fa-external-link-alt"></i></span> 可以使用遍历而不能使用分解问题的思路。对于 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzIyNi4lRTclQkYlQkIlRTglQkQlQUMlRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTEuamF2YQ==">#226<i class="fa fa-external-link-alt"></i></span> 两种思路都可以。</p>
</br>

<h2 id="构造二叉树"><a href="#构造二叉树" class="headerlink" title="构造二叉树"></a>构造二叉树</h2><p><strong>二叉树的构造问题一般都是使用「分解问题」的思路：构造整棵树 &#x3D; 根节点 + 构造左子树 + 构造右子树。</strong></p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzY1NC4lRTYlOUMlODAlRTUlQTQlQTclRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTEuamF2YQ==">654.最大二叉树<i class="fa fa-external-link-alt"></i></span>   <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW11bS1iaW5hcnktdHJlZS8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>每个二叉树节点都可以认为是一棵子树的根节点，对于根节点，首先要做的是把想办法把自己先构造出来，然后想办法构造自己的左右子树。</p>
<p>所以需要遍历数组找到最大值 <code>maxVal</code>，从而把根节点 <code>root</code> 做出来，然后对 <code>maxVal</code> 左边的数组和右边的数组进行递归构建，作为 <code>root</code> 的左右子树。</p>
<p>伪码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums is empty) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 找到数组中的最大值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxVal</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; maxVal) &#123;</span><br><span class="line">            maxVal = nums[i];</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(maxVal);</span><br><span class="line">    <span class="comment">// 递归调用构造左右子树</span></span><br><span class="line">    root.left = constructMaximumBinaryTree(nums[<span class="number">0.</span>.index-<span class="number">1</span>]);</span><br><span class="line">    root.right = constructMaximumBinaryTree(nums[index+<span class="number">1.</span>.nums.length-<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前 <code>nums</code> 中的最大值就是根节点，然后根据索引递归调用左右数组构造左右子树即可。</p>
</br>

<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzEwNS4lRTQlQkIlOEUlRTUlODklOEQlRTUlQkElOEYlRTQlQjglOEUlRTQlQjglQUQlRTUlQkElOEYlRTklODElOEQlRTUlOEUlODYlRTUlQkElOEYlRTUlODglOTclRTYlOUUlODQlRTklODAlQTAlRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTEuamF2YQ==">105.从前序与中序遍历序列构造二叉树<i class="fa fa-external-link-alt"></i></span>   <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29uc3RydWN0LWJpbmFyeS10cmVlLWZyb20tcHJlb3JkZXItYW5kLWlub3JkZXItdHJhdmVyc2FsLw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>与上一题类似，需要确定根节点，然后递归构造左右子树。</p>
<p>根据前序遍历的特点可以很容易的找到根节点——前序遍历的第一个数字 <code>preorder[0]</code>。关键在于如何通过根节点的值，将 <code>preorder</code> 和 <code>inorder</code> 数组划分成两半，构造根节点的左右子树</p>
<p>即下面代码中的 <code>？</code> 应该如何确定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储 inorder 中值到索引的映射</span></span><br><span class="line">HashMap&lt;Integer, Integer&gt; valToIndex = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">        valToIndex.put(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> build(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    build 函数的定义：</span></span><br><span class="line"><span class="comment">    若前序遍历数组为 preorder[preStart..preEnd]，</span></span><br><span class="line"><span class="comment">    中序遍历数组为 inorder[inStart..inEnd]，</span></span><br><span class="line"><span class="comment">    构造二叉树，返回该二叉树的根节点 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span> preStart, <span class="type">int</span> preEnd, <span class="type">int</span>[] inorder, <span class="type">int</span> inStart, <span class="type">int</span> inEnd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> preorder[preStart];</span><br><span class="line">    <span class="comment">// 避免 for 循环寻找 rootVal</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> valToIndex.get(rootVal);</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">    <span class="comment">// 递归构造左右子树</span></span><br><span class="line">    root.left = build(preorder, ?, ?, inorder, ?, ?);</span><br><span class="line"></span><br><span class="line">    root.right = build(preorder, ?, ?, inorder, ?, ?);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于左右子树对应的 <code>inorder</code> 数组的起始索引和终止索引比较容易确定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root.left = build(preorder, ?, ?, inorder, inStart, index - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">root.right = build(preorder, ?, ?, inorder, index + <span class="number">1</span>, inEnd);</span><br></pre></td></tr></table></figure>

<p>中序遍历的根节点左边就是左子树的节点值，右边就是右子树的节点值。</p>
<p>而对于 <code>preorder</code> 数组，可以通过左子树的节点数推导出来，假设左子树的节点数为 <code>leftSize</code>，那么可以根据 <code>inorder</code> 数组计算出 <code>leftSize</code>，而 <code>preStart + leftSize</code> 就是左子树的终止索引。</p>
<p>这样就可以完成代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> index - inStart;</span><br><span class="line"></span><br><span class="line">root.left = build(preorder, preStart + <span class="number">1</span>, preStart + leftSize, inorder, inStart, index - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">root.right = build(preorder, preStart + leftSize + <span class="number">1</span>, preEnd, inorder, index + <span class="number">1</span>, inEnd);</span><br></pre></td></tr></table></figure>

</br>

<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzEwNi4lRTQlQkIlOEUlRTQlQjglQUQlRTUlQkElOEYlRTQlQjglOEUlRTUlOTAlOEUlRTUlQkElOEYlRTklODElOEQlRTUlOEUlODYlRTUlQkElOEYlRTUlODglOTclRTYlOUUlODQlRTklODAlQTAlRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTEuamF2YQ==">106.从中序与后序遍历序列构造二叉树<i class="fa fa-external-link-alt"></i></span>   <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29uc3RydWN0LWJpbmFyeS10cmVlLWZyb20taW5vcmRlci1hbmQtcG9zdG9yZGVyLXRyYXZlcnNhbC8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>与 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzEwNS4lRTQlQkIlOEUlRTUlODklOEQlRTUlQkElOEYlRTQlQjglOEUlRTQlQjglQUQlRTUlQkElOEYlRTklODElOEQlRTUlOEUlODYlRTUlQkElOEYlRTUlODglOTclRTYlOUUlODQlRTklODAlQTAlRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTEuamF2YQ==">#105<i class="fa fa-external-link-alt"></i></span> 类似，可以通过后序遍历数组 <code>postorder</code> 推导出根节点的值，然后递归构造左右子树。后序遍历数组的最后一个元素就是根节点的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储 inorder 中值到索引的映射</span></span><br><span class="line">HashMap&lt;Integer, Integer&gt; valToIndex = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">        valToIndex.put(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> build(inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>, postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    build 函数的定义：</span></span><br><span class="line"><span class="comment">    后序遍历数组为 postorder[postStart..postEnd]，</span></span><br><span class="line"><span class="comment">    中序遍历数组为 inorder[inStart..inEnd]，</span></span><br><span class="line"><span class="comment">    构造二叉树，返回该二叉树的根节点 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span> inStart, <span class="type">int</span> inEnd, <span class="type">int</span>[] postorder, <span class="type">int</span> postStart, <span class="type">int</span> postEnd)</span> &#123;</span><br><span class="line">    <span class="comment">// root 节点对应的值就是后序遍历数组的最后一个元素</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> postorder[postEnd];</span><br><span class="line">    <span class="comment">// rootVal 在中序遍历数组中的索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> valToIndex.get(rootVal);</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">    <span class="comment">// 递归构造左右子树</span></span><br><span class="line">    root.left = build(inorder, ?, ?, postorder, ?, ?);</span><br><span class="line"></span><br><span class="line">    root.right = build(inorder, ?, ?, postorder, ?, ?);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先可以确定左右子树对应的 <code>inorder</code> 数组的起始索引和终止索引：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root.left = build(inorder, inStart, index - <span class="number">1</span>, postorder, ?, ?);</span><br><span class="line"></span><br><span class="line">root.right = build(inorder, index + <span class="number">1</span>, inEnd, postorder, ?, ?);</span><br></pre></td></tr></table></figure>

<p>同样可以通过中序遍历数组求出左子树的长度 <code>leftSize</code>，在 <code>postorder</code> 数组中左子树就从 <code>postStart</code> 到 <code>postStart + leftSize - 1</code>，而右子树就从 <code>postStart + leftSize</code> 到 <code>postEnd - 1</code> (<code>postEnd</code> 是根节点)。</p>
<p>这样就完成了代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> index - inStart;</span><br><span class="line"></span><br><span class="line">root.left = build(inorder, inStart, index - <span class="number">1</span>, postorder, postStart, postStart + leftSize - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">root.right = build(inorder, index + <span class="number">1</span>, inEnd, postorder, postStart + leftSize, postEnd - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

</br>

<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzg4OS4lRTYlQTAlQjklRTYlOEQlQUUlRTUlODklOEQlRTUlQkElOEYlRTUlOTIlOEMlRTUlOTAlOEUlRTUlQkElOEYlRTklODElOEQlRTUlOEUlODYlRTYlOUUlODQlRTklODAlQTAlRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTEuamF2YQ==">889.根据前序和后序遍历构造二叉树<i class="fa fa-external-link-alt"></i></span>   <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb25zdHJ1Y3QtYmluYXJ5LXRyZWUtZnJvbS1wcmVvcmRlci1hbmQtcG9zdG9yZGVyLXRyYXZlcnNhbC8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>我们可以通过一棵树的前序和中序、中序和后序遍历来唯一确定一棵原始二叉树。但通过前序后序遍历结果无法确定唯一的原始二叉树。</p>
<p>用前序遍历和后序遍历结果还原二叉树，解法逻辑上和 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzEwNS4lRTQlQkIlOEUlRTUlODklOEQlRTUlQkElOEYlRTQlQjglOEUlRTQlQjglQUQlRTUlQkElOEYlRTklODElOEQlRTUlOEUlODYlRTUlQkElOEYlRTUlODglOTclRTYlOUUlODQlRTklODAlQTAlRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTEuamF2YQ==">#105<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzEwNi4lRTQlQkIlOEUlRTQlQjglQUQlRTUlQkElOEYlRTQlQjglOEUlRTUlOTAlOEUlRTUlQkElOEYlRTklODElOEQlRTUlOEUlODYlRTUlQkElOEYlRTUlODglOTclRTYlOUUlODQlRTklODAlQTAlRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTEuamF2YQ==">#106<i class="fa fa-external-link-alt"></i></span> 差别不大，也是通过控制左右子树的索引来构建：</p>
<ol>
<li><p>首先把前序遍历结果的第一个元素或者后序遍历结果的最后一个元素确定为根节点的值。</p>
</li>
<li><p>然后把前序遍历结果的第二个元素作为左子树的根节点的值。</p>
</li>
<li><p>在后序遍历结果中寻找左子树根节点的值，从而确定了左子树的索引边界，进而确定右子树的索引边界，递归构造左右子树即可。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 存储 postorder 中值到索引的映射</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; valToIndex = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructFromPrePost</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; postorder.length; i++) &#123;</span><br><span class="line">            valToIndex.put(postorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：根据 preorder[preStart..preEnd] 和 postorder[postStart..postEnd]</span></span><br><span class="line">    <span class="comment">// 构建二叉树，并返回根节点。</span></span><br><span class="line">    TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span> preStart, <span class="type">int</span> preEnd, <span class="type">int</span>[] postorder, <span class="type">int</span> postStart, <span class="type">int</span> postEnd)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (preStart &gt; preEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (preStart == preEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[preStart]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// root 节点对应的值就是前序遍历数组的第一个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> preorder[preStart];</span><br><span class="line">        <span class="comment">// root.left 的值是前序遍历第二个元素</span></span><br><span class="line">        <span class="comment">// 通过前序和后序遍历构造二叉树的关键在于通过左子树的根节点</span></span><br><span class="line">        <span class="comment">// 确定 preorder 和 postorder 中左右子树的元素区间</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftRootVal</span> <span class="operator">=</span> preorder[preStart + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// leftRootVal 在后序遍历数组中的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> valToIndex.get(leftRootVal);</span><br><span class="line">        <span class="comment">// 左子树的元素个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> index - postStart + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先构造出当前根节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">        <span class="comment">// 递归构造左右子树</span></span><br><span class="line">        <span class="comment">// 根据左子树的根节点索引和元素个数推导左右子树的索引边界</span></span><br><span class="line">        root.left = build(preorder, preStart + <span class="number">1</span>, preStart + leftSize, postorder, postStart, index);</span><br><span class="line">        root.right = build(preorder, preStart + leftSize + <span class="number">1</span>, preEnd, postorder, index + <span class="number">1</span>, postEnd - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>造成前序和后序遍历构造二叉树结果不唯一的关键就在于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">leftRootVal</span> <span class="operator">=</span> preorder[preStart + <span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>假设前序遍历的第二个元素是左子树的根节点，但实际上左子树有可能是空指针，那么这个元素就应该是右子树的根节点。由于这里无法确切进行判断，所以导致了最终答案的不唯一。</p>
<p><strong>总之，二叉树的构造问题一般都是使用「分解问题」的思路：构造整棵树 &#x3D; 根节点 + 构造左子树 + 构造右子树。先找出根节点，然后根据根节点的值找到左右子树的元素，进而递归构建出左右子树。</strong></p>
</br>



<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序代码框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：排序 nums[lo..hi]</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lo == hi) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (lo + hi) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 利用定义，排序 nums[lo..mid]</span></span><br><span class="line">    sort(nums, lo, mid);</span><br><span class="line">    <span class="comment">// 利用定义，排序 nums[mid+1..hi]</span></span><br><span class="line">    sort(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">    <span class="comment">// 此时两部分子数组已经被排好序</span></span><br><span class="line">    <span class="comment">// 合并两个有序数组，使 nums[lo..hi] 有序</span></span><br><span class="line">    merge(nums, lo, mid, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将有序数组 nums[lo..mid] 和有序数组 nums[mid+1..hi]</span></span><br><span class="line"><span class="comment">// 合并为有序数组 nums[lo..hi]</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> mid, <span class="type">int</span> hi)</span>;</span><br></pre></td></tr></table></figure>

<p>归并排序就是先把左半边数组排好序，再把右半边数组排好序，然后把两半数组合并。</p>
<p>上述代码和二叉树的后序遍历很像：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二叉树遍历框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">    print(root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出归并排序利用的是分解问题的思路，归并排序的过程可以在逻辑上抽象成一棵二叉树，树上的每个节点的值可以认为是 nums[lo..hi]，叶子节点的值就是数组中的单个元素：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/j6jdt1"><img src="https://s1.ax1x.com/2022/07/11/j6jdt1.png" alt="j6jdt1.png"></a></p>
<p>然后，在每个节点的后序位置（左右子节点已经被排好序）的时候执行 <code>merge</code> 函数，合并两个子节点上的子数组：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/j6jN79"><img src="https://s1.ax1x.com/2022/07/11/j6jN79.png" alt="j6jN79.png"></a></p>
<p>这个 <code>merge</code> 操作会在二叉树的每个节点上都执行一遍，执行顺序是二叉树后序遍历的顺序。</p>
<p>因此可以写出代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Merge</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于辅助合并有序数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 先给辅助数组开辟内存空间</span></span><br><span class="line">        temp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="comment">// 排序整个数组（原地修改）</span></span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：将子数组 nums[lo..hi] 进行排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lo == hi) &#123;</span><br><span class="line">            <span class="comment">// 单个元素不用排序</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这样写是为了防止溢出，效果等同于 (hi + lo) / 2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 先对左半部分数组 nums[lo..mid] 排序</span></span><br><span class="line">        sort(nums, lo, mid);</span><br><span class="line">        <span class="comment">// 再对右半部分数组 nums[mid+1..hi] 排序</span></span><br><span class="line">        sort(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="comment">// 将两部分有序数组合并成一个有序数组</span></span><br><span class="line">        merge(nums, lo, mid, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 nums[lo..mid] 和 nums[mid+1..hi] 这两个有序数组合并成一个有序数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> mid, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="comment">// 先把 nums[lo..hi] 复制到辅助数组中</span></span><br><span class="line">        <span class="comment">// 以便合并后的结果能够直接存入 nums</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo; i &lt;= hi; i++) &#123;</span><br><span class="line">            temp[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组双指针技巧，合并两个有序数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> lo; p &lt;= hi; p++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == mid + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 左半边数组已全部被合并</span></span><br><span class="line">                nums[p] = temp[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == hi + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 右半边数组已全部被合并</span></span><br><span class="line">                nums[p] = temp[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp[i] &gt; temp[j]) &#123;</span><br><span class="line">                nums[p] = temp[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[p] = temp[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sort</code> 函数对 <code>nums[lo..mid]</code> 和 <code>nums[mid+1..hi]</code> 递归排序完成之后，我们没有办法原地把它们合并，所以需要 <code>copy</code> 到 <code>temp</code> 数组里面，然后通过类似于合并有序链表的双指针技巧将 <code>nums[lo..hi]</code> 合并成一个有序数组：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/j6jakR"><img src="https://s1.ax1x.com/2022/07/11/j6jakR.png" alt="j6jakR.png"></a></p>
<p>注意，这里不是在 <code>merge</code> 函数执行的时候 <code>new</code> 辅助数组，而是提前把 <code>temp</code> 辅助数组 <code>new</code> 出来了，这样就避免了在递归中频繁分配和释放内存可能产生的性能问题。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS85MTIuJUU2JThFJTkyJUU1JUJBJThGJUU2JTk1JUIwJUU3JUJCJTg0LmphdmE=">912.排序数组<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zb3J0LWFuLWFycmF5Lw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>除了最基本的排序问题，归并排序还可以用来解决：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzMxNS4lRTglQUUlQTElRTclQUUlOTclRTUlOEYlQjMlRTQlQkUlQTclRTUlQjAlOEYlRTQlQkElOEUlRTUlQkQlOTMlRTUlODklOEQlRTUlODUlODMlRTclQjQlQTAlRTclOUElODQlRTQlQjglQUElRTYlOTUlQjAuamF2YQ==">315.计算右侧小于当前元素的个数<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3VudC1vZi1zbWFsbGVyLW51bWJlcnMtYWZ0ZXItc2VsZi8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/j6jt0J"><img src="https://s1.ax1x.com/2022/07/11/j6jt0J.png" alt="j6jt0J.png"></a></p>
<p>在使用 <code>merge</code> 函数合并两个有序数组时可以知道一个元素 <code>nums[i]</code> 后边有多少个元素比 <code>nums[i]</code> 小：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/j6jYm4"><img src="https://s1.ax1x.com/2022/07/11/j6jYm4.png" alt="j6jYm4.png"></a></p>
<p>此时应该把 <code>temp[i]</code> 放到 <code>nums[p]</code> 上，因为 <code>temp[i] &lt; temp[j]</code>。</p>
<p>在这个场景下还可以知道：5 后面比 5 小的元素个数就是 左闭右开区间 <code>[mid + 1, j)</code> 中的元素个数，即 2 和 4 这两个元素。这是因为 <code>temp</code> 被 <code>mid</code> 划分成了两个已经排好序的数组，而在左边的数组中，<code>i</code> 的右边显然不会有比 <code>temp[i]</code> 更小的元素，因此比它小的只能在 <code>mid</code> 之后，即从 <code>mid + 1</code> 开始；又因为 <code>temp[i] &lt; temp[j]</code>，而此时 <code>temp[j - 1]</code> 是与 <code>temp[i]</code> 比较过并放入 <code>nums[p]</code> 中的，因此在 <code>j</code> 结束且不包含 <code>j</code>。</p>
<p>即在对 <code>nuns[lo..hi]</code> 合并的过程中，每当执行 <code>nums[p] = temp[i]</code> 时，就可以确定 <code>temp[i]</code> 这个元素后面比它小的元素个数为 <code>j - mid - 1</code>。</p>
<p>这样只需要修改 <code>merge</code> 方法即可完成该题。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzMyNy4lRTUlOEMlQkElRTklOTclQjQlRTUlOTIlOEMlRTclOUElODQlRTQlQjglQUElRTYlOTUlQjAuamF2YQ==">327.区间和的个数<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3VudC1vZi1yYW5nZS1zdW0v">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/j6jBp6"><img src="https://s1.ax1x.com/2022/07/11/j6jBp6.png" alt="j6jBp6.png"></a></p>
<p>要求计算计算元素和落在 <code>[lower, upper]</code> 中的所有子数组的个数。可以创建一个前缀和数组 <code>preSum</code> 来辅助计算区间和。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzQ5My4lRTclQkYlQkIlRTglQkQlQUMlRTUlQUYlQjkuamF2YQ==">493.翻转对<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLXBhaXJzLw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/j6jwfx"><img src="https://s1.ax1x.com/2022/07/11/j6jwfx.png" alt="j6jwfx.png"></a></p>
<p>与 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzMxNS4lRTglQUUlQTElRTclQUUlOTclRTUlOEYlQjMlRTQlQkUlQTclRTUlQjAlOEYlRTQlQkElOEUlRTUlQkQlOTMlRTUlODklOEQlRTUlODUlODMlRTclQjQlQTAlRTclOUElODQlRTQlQjglQUElRTYlOTUlQjAuamF2YQ==">#315<i class="fa fa-external-link-alt"></i></span> 非常相似，只是判断的条件发生了改变，这里求的是 <code>nums[i] &gt; 2*nums[j]</code>。</p>
<p>所以解题思路还是要在 <code>merge</code> 函数中修改，当 <code>nums[lo..mid]</code> 和 <code>nums[mid+1..hi]</code> 两个子数组完成排序后，对于 <code>nums[lo..mid]</code> 中的每个元素 <code>nums[i]</code>，去 <code>nums[mid+1..hi]</code> 中寻找符合条件的 <code>nums[j]</code> 就可以。</p>
<p><strong>所有递归的算法，本质上都是在遍历一棵（递归）树，然后在节点（前中后序位置）上执行代码。要写递归算法，本质上就是要告诉每个节点需要做什么。</strong></p>
<p><strong>如归并排序算法，递归的 <code>sort</code> 函数就是二叉树的遍历函数，而 <code>merge</code> 函数就是在每个节点上做的事情。</strong></p>
</br>

<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>二叉搜索树（Binary Search Tree，BST）的特点：</p>
<ol>
<li>对于 BST 的每一个节点 <code>node</code>，左子树节点的值都比 <code>node</code> 的值要小，右子树节点的值都比 <code>node</code> 的值大。 </li>
<li>对于 BST 的每一个节点 <code>node</code>，它的左侧子树和右侧子树都是 BST。</li>
</ol>
<p><strong>除了它的定义，还有一个重要的性质：BST 的中序遍历结果是有序的（升序）。</strong></p>
<p>也就是说，如果输入一棵 BST，可以将 BST 中每个节点的值升序打印出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    traverse(root.left);</span><br><span class="line">    <span class="comment">// 中序遍历代码位置</span></span><br><span class="line">    print(root.val);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<ul>
<li><a href="Tree/230.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0.java">230.二叉搜索树中第K小的元素</a>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9rdGgtc21hbGxlc3QtZWxlbWVudC1pbi1hLWJzdC8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jgopFK"><img src="https://s1.ax1x.com/2022/07/12/jgopFK.png" alt="jgopFK.png"></a></p>
<p>利用 BST 的这个特性就可以轻松完成这道题：中序遍历 BST 升序得到结果，并获取第 <code>k</code> 个元素即可:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 记录结果以及位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, rank = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 利用 BST 的中序遍历特性</span></span><br><span class="line">        traverse(root, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(root.left, k);</span><br><span class="line">        <span class="comment">// 中序遍历代码位置</span></span><br><span class="line">        <span class="keyword">if</span>(++rank == k) &#123;</span><br><span class="line">            <span class="comment">// 找到第 k 小的元素</span></span><br><span class="line">            res = root.val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(root.right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>


<ul>
<li><a href="Tree/538.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91.java">538.把二叉搜索树转换为累加树</a>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb252ZXJ0LWJzdC10by1ncmVhdGVyLXRyZWUv">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><a href="Tree/1038.%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%88%B0%E6%9B%B4%E5%A4%A7%E5%92%8C%E6%A0%91.java">1038.从二叉搜索树到更大和树</a>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktc2VhcmNoLXRyZWUtdG8tZ3JlYXRlci1zdW0tdHJlZS8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jgo9JO"><img src="https://s1.ax1x.com/2022/07/12/jgo9JO.png" alt="jgo9JO.png"></a></p>
<p>这两题完全相同，需要将每个节点的值更改为大于等于该节点的值之和，对于 BST 来说，每个节点的左子树都比该节点的值小，右子树都比该节点的值大，因此可以为每个节点加上其右子树的所有值即可。同样利用 BST 中序遍历的特点，但需要降序，即从右到左遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 先递归遍历右子树</span></span><br><span class="line">    traverse(root.right);</span><br><span class="line">    <span class="comment">// 中序遍历代码位置</span></span><br><span class="line">    print(root.val);</span><br><span class="line">    <span class="comment">// 后递归遍历左子树</span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码可以降序打印 BST 节点的值，如果维护一个外部累加变量 <code>sum</code>，然后把 <code>sum</code> 赋值给 BST 中的每一个节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    traverse(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录累加和</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    traverse(root.right);</span><br><span class="line">    <span class="comment">// 维护累加和</span></span><br><span class="line">    sum += root.val;</span><br><span class="line">    <span class="comment">// 将 BST 转化成累加树</span></span><br><span class="line">    root.val = sum;</span><br><span class="line">    traverse(root.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心还是 BST 的中序遍历特性，只不过修改了递归顺序，降序遍历 BST 的元素值，从而契合题目累加树的要求。</p>
<p>BST 相关的问题，要么利用 BST 左小右大的特性提升算法效率，要么利用中序遍历的特性满足题目的要求。</p>
</br>

<h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><p>BST 的基础操作主要依赖「左小右大」的特性，可以在二叉树中做类似二分搜索的操作，寻找一个元素的效率很高。</p>
<ol>
<li>判断 BST 的合法性</li>
</ol>
<ul>
<li><a href="Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.java">98.验证二叉搜索树</a>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZGF0ZS1iaW5hcnktc2VhcmNoLXRyZWUv">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jgoiSe"><img src="https://s1.ax1x.com/2022/07/12/jgoiSe.png" alt="jgoiSe.png"></a></p>
<p>按照 BST 左小右大的特性，每个节点想要判断自己是否是合法的 BST 节点，比较自己和左右子树即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.left != <span class="literal">null</span> &amp;&amp; root.left.val &gt;= root.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.right != <span class="literal">null</span> &amp;&amp; root.right.val &lt;= root.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样会出现问题：BST 的每个节点应该要小于右边子树的所有节点，下面这个二叉树显然不是 BST，因为节点 10 的右子树中有一个节点 6，但是我们的算法会把它判定为合法 BST：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jgIxdx"><img src="https://s1.ax1x.com/2022/07/12/jgIxdx.png" alt="jgIxdx.png"></a></p>
<p>出现问题的原因在于，对于每一个节点 <code>root</code>，代码值检查了它的左右孩子节点是否符合左小右大的原则；但是根据 BST 的定义，<code>root</code> 的整个左子树都要小于 <code>root.val</code>，整个右子树都要大于 <code>root.val</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 限定以 root 为根的子树节点必须满足 max.val &gt; root.val &gt; min.val</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root, TreeNode min, TreeNode max)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST</span></span><br><span class="line">    <span class="keyword">if</span>(min != <span class="literal">null</span> &amp;&amp; root.val &lt;= min.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(max != <span class="literal">null</span> &amp;&amp; root.val &gt;= max.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 限定左子树的最大值是 root.val，右子树的最小值是 root.val</span></span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.left, min, root) &amp;&amp; isValidBST(root.right, root, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用辅助函数，增加函数参数列表，在参数中携带额外信息，将这种约束传递给子树的所有节点。</p>
</br>


<ol start="2">
<li>在 BST 中搜索元素</li>
</ol>
<ul>
<li><a href="Tree/700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.java">700.二叉搜索树中的搜索</a>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZWFyY2gtaW4tYS1iaW5hcnktc2VhcmNoLXRyZWUv">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jgIzo6"><img src="https://s1.ax1x.com/2022/07/12/jgIzo6.png" alt="jgIzo6.png"></a></p>
<p>如果是在一棵普通的二叉树中寻找：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val == val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前节点没找到就递归地去左右子树寻找</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> searchBST(root.left, val);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> searchBST(root.right, val);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这段代码相当于穷举了所有节点，适用于所有二叉树。而这里题目给的是二叉搜索树，因此应该使用二叉搜索树的特点进行查找。不需要递归地搜索两边，类似二分查找思想，根据 <code>val</code> 和 <code>root.val</code> 的大小比较，就能排除一边：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 类似二分查找</span></span><br><span class="line">    <span class="keyword">if</span>(root.val == val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; val) &#123;</span><br><span class="line">        <span class="keyword">return</span> searchBST(root.left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchBST(root.right, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对数据结构的操作无非遍历 + 访问，遍历就是「找」，访问就是「改」。一旦涉及「改」，就类似二叉树的构造问题，函数要返回 <code>TreeNode</code> 类型，并且要对递归调用的返回值进行接收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="comment">// 找到空位置插入新节点</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">    <span class="comment">// BST 中一般不会插入已存在元素</span></span><br><span class="line">    <span class="comment">// if (root.val == val)</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; val) </span><br><span class="line">        root.right = insertIntoBST(root.right, val);</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; val) </span><br><span class="line">        root.left = insertIntoBST(root.left, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>


<ol start="3">
<li>在 BST 中删除一个数</li>
</ol>
<p>与插入操作类似，先「找」再「改」，代码框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">        <span class="comment">// 找到进行删除</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; key) &#123;</span><br><span class="line">        <span class="comment">// 在左子树找</span></span><br><span class="line">        root.left = deleteNode(root.left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; key) &#123;</span><br><span class="line">        <span class="comment">// 在右子树找</span></span><br><span class="line">        root.right = deleteNode(root.right, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点在于如何删除该节点且不破坏 BST 的性质。删除一个节点有三种情况：</p>
<p>情况 1：删除的是叶子结点，没有子树。直接删除。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jgoCWD"><img src="https://s1.ax1x.com/2022/07/12/jgoCWD.png" alt="jgoCWD.png"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>情况 2：删除的是只有一个子树的节点。则让其子树节点代替该节点的位置。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jgoFQH"><img src="https://s1.ax1x.com/2022/07/12/jgoFQH.png" alt="jgoFQH.png"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排除了情况 1 后</span></span><br><span class="line"><span class="keyword">if</span> (root.left == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> root.right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> root.left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>情况 3：删除的是有两个子树的节点。为了不破坏 BST 的性质，需要用左子树中最大的节点，或右子树中最小的节点来代替该节点的位置。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jgokyd"><img src="https://s1.ax1x.com/2022/07/12/jgokyd.png" alt="jgokyd.png"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 找到右子树的最小节点</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">minNode</span> <span class="operator">=</span> getMin(root.right);</span><br><span class="line">    <span class="comment">// 删除 minNode</span></span><br><span class="line">    root.right = deleteNode(root.right, minNode.val);</span><br><span class="line">    <span class="comment">// 把 root 改成 minNode</span></span><br><span class="line">    root.val = minNode.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<ul>
<li><a href="Tree/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.java">450.删除二叉搜索树中的节点</a>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWxldGUtbm9kZS1pbi1hLWJzdC8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jgoAOA"><img src="https://s1.ax1x.com/2022/07/12/jgoAOA.png" alt="jgoAOA.png"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.val == key) &#123;</span><br><span class="line">        <span class="comment">// 处理情况1、2</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理情况3</span></span><br><span class="line">        <span class="comment">// 获取右子树最小的节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">minNode</span> <span class="operator">=</span> getMin(root.right);</span><br><span class="line">        <span class="comment">// 删除右子树最小的节点</span></span><br><span class="line">        root.right = deleteNode(root.right, minNode.val);</span><br><span class="line">        <span class="comment">// 用右子树最小的节点替换 root 节点</span></span><br><span class="line">        minNode.left = root.left;</span><br><span class="line">        minNode.right = root.right;</span><br><span class="line">        root = minNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root .val &gt; key) &#123;</span><br><span class="line">        root.left = deleteNode(root.left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root.right = deleteNode(root.right, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">getMin</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// BST 中最左边的节点就是最小的</span></span><br><span class="line">    <span class="keyword">while</span>(root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        root = root.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在交换 <code>root</code> 和 <code>minNode</code> 时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理情况3</span></span><br><span class="line"><span class="comment">// 获取右子树最小的节点</span></span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">minNode</span> <span class="operator">=</span> getMin(root.right);</span><br><span class="line"><span class="comment">// 删除右子树最小的节点</span></span><br><span class="line">root.right = deleteNode(root.right, minNode.val);</span><br><span class="line"><span class="comment">// 用右子树最小的节点替换 root 节点</span></span><br><span class="line">minNode.left = root.left;</span><br><span class="line">minNode.right = root.right;</span><br><span class="line">root = minNode;</span><br></pre></td></tr></table></figure>

<p>先删除了右子树最小的节点再进行替换，避免在修改完右子树后再去删除，这样会导致超时。并且没有使用更简单的直接将 <code>root.val</code> 替换为 <code>minNode.val</code>，而是进行了一系列复杂链表操作，仅对于这道算法题来说是可以的，但一般不会通过修改节点内部的值来交换节点。因为在实际应用中，BST 节点内部的数据域是用户自定义的，可以非常复杂，而 BST 作为数据结构，其操作应该和内部存储的数据域解耦，所以更倾向于使用指针操作来交换节点而不关心内部数据。</p>
</br>

<h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzk2LiVFNCVCOCU4RCVFNSU5MCU4QyVFNyU5QSU4NCVFNCVCQSU4QyVFNSU4RiU4OSVFNiU5MCU5QyVFNyVCNCVBMiVFNiVBMCU5MS5qYXZh">96.不同的二叉搜索树<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy91bmlxdWUtYmluYXJ5LXNlYXJjaC10cmVlcy8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://files.catbox.moe/6eu9q1.png#crop=0&crop=0&crop=1&crop=1&id=YBUqQ&originHeight=1228&originWidth=1468&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>如输入 <code>n = 5</code>，也就是说用 <code>&#123;1,2,3,4,5&#125;</code> 构造 BST。 首先每个数字都可以作为根节点，假如说 3 作为根节点，左子树节点就是 <code>&#123;1,2&#125;</code> 的组合，右子树就是 <code>&#123;4,5&#125;</code> 的组合。左子树的组合数和右子树的组合数乘积就是 3 作为根节点时的 BST 个数。其他节点也用同样的方法就可以求出该题的答案。</p>
<p>使用递归可以写出代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 计算闭区间 [1, n] 组成的 BST 个数</span></span><br><span class="line">    <span class="keyword">return</span> count(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算闭区间 [lo, hi] 组成的 BST 个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(<span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (lo &gt; hi) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo; i &lt;= hi; i++) &#123;</span><br><span class="line">        <span class="comment">// i 的值作为根节点 root</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> count(lo, i - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> count(i + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="comment">// 左右子树的组合数乘积是 BST 的总数</span></span><br><span class="line">        res += left * right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 base case，显然当 <code>lo &gt; hi</code> 闭区间 <code>[lo, hi]</code> 肯定是个空区间，也就对应着空节点 <code>null</code>，虽然是空节点，但是也是一种情况，所以要返回 1 而不能返回 0。</p>
<p>但这样的时间复杂度非常高，有些已经计算过的在后面再次需要使用时仍会再次计算，因此可以加一个备忘录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 备忘录</span></span><br><span class="line"><span class="type">int</span>[][] memo;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 备忘录的值初始化为 0</span></span><br><span class="line">    memo = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> count(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(<span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (lo &gt; hi) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(memo[lo][hi] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 已经计算过就直接返回</span></span><br><span class="line">        <span class="keyword">return</span> memo[lo][hi];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo; i &lt;= hi; i++) &#123;</span><br><span class="line">        <span class="comment">// i 的值作为根节点 root</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> count(lo, i - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> count(i + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="comment">// 左右子树的组合数乘积是 BST 的总数</span></span><br><span class="line">        res += left * right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将结果存入备忘录</span></span><br><span class="line">    memo[lo][hi] = res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzk1LiVFNCVCOCU4RCVFNSU5MCU4QyVFNyU5QSU4NCVFNCVCQSU4QyVFNSU4RiU4OSVFNiU5MCU5QyVFNyVCNCVBMiVFNiVBMCU5MS1paS5qYXZh">95.不同的二叉搜索树 II<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy91bmlxdWUtYmluYXJ5LXNlYXJjaC10cmVlcy1paS8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://files.catbox.moe/dhbbub.png#crop=0&crop=0&crop=1&crop=1&id=YOt8K&originHeight=1234&originWidth=1460&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>除了与 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzk2LiVFNCVCOCU4RCVFNSU5MCU4QyVFNyU5QSU4NCVFNCVCQSU4QyVFNSU4RiU4OSVFNiU5MCU5QyVFNyVCNCVBMiVFNiVBMCU5MS5qYXZh">#96<i class="fa fa-external-link-alt"></i></span> 相似的需要求可以构造的 BST 数量，还要求将该树都构造出来并将它们的根节点存入一个列表返回。</p>
<p>思路也相似：</p>
<ol>
<li>穷举 <code>root</code> 节点的所有可能。 </li>
<li>递归构造出左右子树的所有合法 BST。 </li>
<li>给 <code>root</code> 节点穷举所有左右子树的组合。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 构造闭区间 [1, n] 组成的 BST </span></span><br><span class="line">    <span class="keyword">return</span> build(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;TreeNode&gt; <span class="title function_">build</span><span class="params">(<span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">    List&lt;TreeNode&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(lo &gt; hi) &#123;</span><br><span class="line">        res.add(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.穷举 root 节点的所有可能</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo; i &lt;= hi; i++) &#123;</span><br><span class="line">        <span class="comment">// 2.递归构造出左右子树的所有合法 BST</span></span><br><span class="line">        List&lt;TreeNode&gt; leftTree = build(lo, i - <span class="number">1</span>);</span><br><span class="line">        List&lt;TreeNode&gt; rightTree = build(i + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="comment">// 3.给 root 节点穷举所有左右子树的组合</span></span><br><span class="line">        <span class="keyword">for</span>(TreeNode left : leftTree) &#123;</span><br><span class="line">            <span class="keyword">for</span>(TreeNode right : rightTree) &#123;</span><br><span class="line">                <span class="comment">// i 作为根节点 root 的值</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(i);</span><br><span class="line">                root.left = left;</span><br><span class="line">                root.right = right;</span><br><span class="line">                res.add(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序代码框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对 nums[lo..hi] 进行切分</span></span><br><span class="line">    <span class="comment">// 使得 nums[lo..p-1] &lt;= nums[p] &lt; nums[p+1..hi]</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(nums, lo, hi);</span><br><span class="line">    <span class="comment">// 去左右子数组进行切分</span></span><br><span class="line">    sort(nums, lo, p - <span class="number">1</span>);</span><br><span class="line">    sort(nums, p + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现快速排序就是一个二叉树的前序遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    print(root.val);</span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>快速排序是先将一个元素排好序，然后再将剩下的元素排好序。</strong></p>
<p>快速排序的核心就是 <code>partition</code> 函数， <code>partition</code> 函数的作用是在 <code>nums[lo..hi]</code> 中寻找一个分界点 <code>p</code>，通过交换元素使得 <code>nums[lo..p-1]</code> 都小于等于 <code>nums[p]</code>，且 <code>nums[p+1..hi]</code> 都大于 <code>nums[p]</code>：</p>
<p><img src="https://files.catbox.moe/po3nwl.png#crop=0&crop=0&crop=1&crop=1&id=oeX9v&originHeight=736&originWidth=1142&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>通过 <code>partition</code> 就可以将 <code>nums[p]</code> 放在正确的位置。再用同样的方法把 <code>p</code> 左边和右边的子数组进行递归用 <code>partition</code> 把剩下的元素也排好序。</p>
<p><strong>从二叉树的视角，我们可以把子数组 nums[lo..hi] 理解成二叉树节点上的值，sort 函数理解成二叉树的遍历函数。</strong></p>
<p>这样，根据每次排序的元素的顺序，快速排序最后形成的二叉树就是一颗二叉搜索树：</p>
<p><img src="https://files.catbox.moe/gcezr2.png#crop=0&crop=0&crop=1&crop=1&id=yEZdr&originHeight=768&originWidth=980&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>但这样就需要考虑二叉搜索树不平衡的问题，在极端情况下会退化成链表，导致操作效率大幅降低。为了避免这种情况，需要引入随机性。常见的方式是在进行排序之前对整个数组执行 「洗牌算法」 进行打乱，或者在 <code>partition</code> 函数中随机选择数组元素作为分界点。</p>
<p>洗牌算法可以参考 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8zODQuJUU2JTg5JTkzJUU0JUI5JUIxJUU2JTk1JUIwJUU3JUJCJTg0LmphdmE=">#384<i class="fa fa-external-link-alt"></i></span></p>
<p>这样就可以使用代码实现快速排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quick</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 为了避免出现耗时的极端情况，先随机打乱</span></span><br><span class="line">        shuffle(nums);</span><br><span class="line">        <span class="comment">// 排序整个数组（原地修改）</span></span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(lo &gt;= hi) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对 nums[lo..hi] 进行切分</span></span><br><span class="line">        <span class="comment">// 使得 nums[lo..p-1] &lt;= nums[p] &lt; nums[p+1..hi]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(nums, lo, hi);</span><br><span class="line"></span><br><span class="line">        sort(nums, lo, p - <span class="number">1</span>);</span><br><span class="line">        sort(nums, p + <span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[lo];</span><br><span class="line">        <span class="comment">// 这里把 i, j 定义为开区间，同时定义：</span></span><br><span class="line">        <span class="comment">// [lo, i) &lt;= pivot；(j, hi] &gt; pivot</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo + <span class="number">1</span>, j = hi;</span><br><span class="line">        <span class="comment">// 当 i &gt; j 时结束循环，以保证区间 [lo, hi] 都被覆盖</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; hi &amp;&amp; nums[i] &lt;= pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="comment">// 此 while 结束时恰好 nums[i] &gt; pivot</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; lo &amp;&amp; nums[j] &gt; pivot) &#123;</span><br><span class="line">                j--;</span><br><span class="line">                <span class="comment">// 此 while 结束时恰好 nums[j] &lt;= pivot</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时 [lo, i) &lt;= pivot &amp;&amp; (j, hi] &gt; pivot</span></span><br><span class="line">            <span class="comment">// 交换 nums[j] 和 nums[i]</span></span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">            <span class="comment">// 此时 [lo, i] &lt;= pivot &amp;&amp; [j, hi] &gt; pivot</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后将 pivot 放到合适的位置，即 pivot 左边元素较小，右边元素较大</span></span><br><span class="line">        swap(nums, lo, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 洗牌算法，将输入的数组随机打乱</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 生成 [i, n - 1] 的随机数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> i + rand.nextInt(n - i);</span><br><span class="line">            swap(nums, i, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原地交换数组中的两个元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以解决：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzIxNS4lRTYlOTUlQjAlRTclQkIlODQlRTQlQjglQUQlRTclOUElODQlRTclQUMlQUNrJUU0JUI4JUFBJUU2JTlDJTgwJUU1JUE0JUE3JUU1JTg1JTgzJUU3JUI0JUEwLmphdmE=">215. 数组中的第K个最大元素<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMva3RoLWxhcmdlc3QtZWxlbWVudC1pbi1hbi1hcnJheS8=">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS85MTIuJUU2JThFJTkyJUU1JUJBJThGJUU2JTk1JUIwJUU3JUJCJTg0LmphdmE=">912. 排序数组<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc29ydC1hbi1hcnJheS8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</br>

<h2 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h2><p><code>git pull</code> 这个命令我们经常会用，它默认是使用 <code>merge</code> 方式将远端别人的修改拉到本地；如果带上参数<code>git pull -r</code>，就会使用 <code>rebase</code> 的方式将远端修改拉到本地。</p>
<p>这二者最直观的区别就是：<code>merge</code> 方式合并的分支会看到很多「分叉」，而 <code>rebase</code> 方式合并的分支就是一条直线。但无论哪种方式，如果存在冲突，Git 都会检测出来并让你手动解决冲突。</p>
<p>Git 是如何检测两条分支是否存在冲突的呢？</p>
<p>以 <code>rebase</code> 命令为例，如下图的情况，在 <code>dev</code> 分支执行 <code>git rebase master</code>，<code>dev</code> 就会接到 <code>master</code> 分支之上：</p>
<p><img src="https://s2.loli.net/2022/07/14/Q84MnoJvxsPpeZW.png#crop=0&crop=0&crop=1&crop=1&id=xJBUU&originHeight=648&originWidth=1186&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>首先找到这两条分支的最近公共祖先 LCA，然后从 <code>master</code> 节点开始，重演 LCA 到 <code>dev</code> 几个 <code>commit</code> 的修改，如果这些修改和 LCA 到 <code>master</code> 的 <code>commit</code> 有冲突，就会提示你手动解决冲突，最后的结果就是把 <code>dev</code> 的分支完全接到 <code>master</code> 上面。</p>
</br>

<h3 id="寻找一个元素"><a href="#寻找一个元素" class="headerlink" title="寻找一个元素"></a>寻找一个元素</h3><p>输入一棵没有重复元素的二叉树根节点 <code>root</code> 和一个目标值 <code>val</code>，写一个函数寻找树中值为 <code>val</code> 的节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：在以 root 为根的二叉树中寻找值为 val 的节点</span></span><br><span class="line">TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val == val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// root 不是目标节点，去左子树找</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> find(root.left, val);</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左子树找不到，去左子树找</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> find(root.right, val);</span><br><span class="line">    <span class="keyword">if</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找不到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于这段代码进行修改，首先修改 <code>return</code> 的位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    <span class="keyword">if</span> (root.val == val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// root 不是目标节点，去左右子树找</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> find(root.left, val);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> find(root.right, val);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码也可以达到目的，但实际运行的效率会低一些。这是因为，如果能够在左子树找到目标节点，这段代码还是会去右子树找，所以效率相对差一些。</p>
<p>更进一步，把对 <code>root.val</code> 的判断从前序位置移动到后序位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先去左右子树寻找</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> find(root.left, val);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> find(root.right, val);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">    <span class="keyword">if</span> (root.val == val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码相当于遍历了二叉树的所有节点，就算找到了目标值也需要先去去遍历左右子树，因此效率进一步降低。</p>
<p>现在若将题目修改为寻找值为 <code>val1</code> 或 <code>val2</code> 的节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：在以 root 为根的二叉树中寻找值为 val1 或 val2 的节点</span></span><br><span class="line">TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, <span class="type">int</span> val1, <span class="type">int</span> val2)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    <span class="keyword">if</span> (root.val == val1 || root.val == val2) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去左右子树寻找</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> find(root.left, val1, val2);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> find(root.right, val1, val2);</span><br><span class="line">    <span class="comment">// 后序位置，已经知道左右子树是否存在目标值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>写这个查找的目的在于：最近公共祖先系列问题的解法都是把这个函数作为框架的。</strong></p>
</br>


<h3 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzIzNi4lRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTElRTclOUElODQlRTYlOUMlODAlRTglQkYlOTElRTUlODUlQUMlRTUlODUlQjElRTclQTUlOTYlRTUlODUlODguamF2YQ==">236.二叉树的最近公共祖先<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb3dlc3QtY29tbW9uLWFuY2VzdG9yLW9mLWEtYmluYXJ5LXRyZWUv">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s2.loli.net/2022/07/14/fi5Cq8gJ9banuwZ.png#crop=0&crop=0&crop=1&crop=1&id=QFF7q&originHeight=1020&originWidth=1450&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>如图示例：</p>
<ol>
<li>如果 <code>p</code> 是节点 6，<code>q</code> 是节点 7，那么它们的 LCA 就是节点 5。 </li>
<li>当然，<code>p</code> 和 <code>q</code> 本身也可能是 LCA，比如 <code>p</code> 是节点 4，<code>q</code> 是节点 5， <code>q</code> 本身就是 LCA 节点。</li>
</ol>
<p>两个节点的最近公共祖先其实就是这两个节点向根节点的「延长线」的交汇点。如果一个节点能够在它的左右子树中分别找到 <code>p</code> 和 <code>q</code>，则该节点为 LCA 节点。</p>
<p>因此可以使用前面实现的 <code>find</code> 方法，只需在后序位置添加一个判断逻辑，即可改造成寻找最近公共祖先的解法代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> find(root, p, q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在二叉树中寻找 p 和 q 的最近公共祖先节点</span></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    <span class="keyword">if</span>(root.val == p.val || root.val == q.val) &#123;</span><br><span class="line">        <span class="comment">// 遇到目标值，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> find(root.left, p, q);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> find(root.right, p, q);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序位置，已经知道左右子树是否存在目标值</span></span><br><span class="line">    <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前节点是 LCA 节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>find</code> 函数的后序位置，如果发现 <code>left</code> 和 <code>right</code> 都非空，就说明当前节点是 LCA 节点，即解决了第一种情况。</p>
<p>在 <code>find</code> 函数的前序位置，如果找到一个值为 <code>p</code> 或 <code>q</code> 的节点则直接返回，恰好解决了第二种情况。这是因为题目的 <code>p</code> 和 <code>q</code> 一定存在于二叉树中，所以即便遇到 <code>q</code> 就直接返回，根本没遍历到 <code>p</code>，也依然可以断定 <code>p</code> 在 <code>q</code> 底下，<code>q</code> 就是 LCA 节点。</p>
</br>


<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzE2NzYuJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxJUU3JTlBJTg0JUU2JTlDJTgwJUU4JUJGJTkxJUU1JTg1JUFDJUU1JTg1JUIxJUU3JUE1JTk2JUU1JTg1JTg4LWl2LmphdmE=">1676.二叉树的最近公共祖先 IV<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb3dlc3QtY29tbW9uLWFuY2VzdG9yLW9mLWEtYmluYXJ5LXRyZWUtaXYv">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s1.ax1x.com/2022/07/14/jfM4Xt.png#crop=0&crop=0&crop=1&crop=1&id=VIdLS&originHeight=1110&originWidth=1462&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>与 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzIzNi4lRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTElRTclOUElODQlRTYlOUMlODAlRTglQkYlOTElRTUlODUlQUMlRTUlODUlQjElRTclQTUlOTYlRTUlODUlODguamF2YQ==">#236<i class="fa fa-external-link-alt"></i></span> 不同的是，这道题输入的节点不止两个，而是一个节点列表（所有节点都存在于树中），要寻找列表中所有节点的最近公共祖先。</p>
<p>如图所示，输入 <code>nodes = [7,4,6]</code>，那么函数应该返回节点 5。</p>
<p>解法逻辑与上题类似，只需将 <code>nodes</code> 存入哈希集合来判断遍历到的元素是否存在于 <code>nodes</code> 中（详细见代码）。</p>
<p>需要注意的是，这两道题的题目都明确告诉我们这些节点必定存在于二叉树中，如果没有这个前提条件，就需要修改代码了。</p>
</br>


<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzE2NDQuJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxJUU3JTlBJTg0JUU2JTlDJTgwJUU4JUJGJTkxJUU1JTg1JUFDJUU1JTg1JUIxJUU3JUE1JTk2JUU1JTg1JTg4LWlpLmphdmE=">1644.二叉树的最近公共祖先 II<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb3dlc3QtY29tbW9uLWFuY2VzdG9yLW9mLWEtYmluYXJ5LXRyZWUtaWkv">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s1.ax1x.com/2022/07/14/jflmxs.png#crop=0&crop=0&crop=1&crop=1&id=hSuJi&originHeight=1116&originWidth=1468&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>此时 <code>p</code> 和 <code>q</code> 可能不存在于该二叉树中，因此前面解决标准最近公共祖先问题时 <code>find</code> 方法中前序位置的判断就不可行了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序位置</span></span><br><span class="line"><span class="keyword">if</span> (root.val == val1 || root.val == val2) &#123;</span><br><span class="line">    <span class="comment">// 遇到目标值，直接返回</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这道题来说，<code>p</code> 和 <code>q</code> 不一定存在于树中，所以不能遇到一个目标值就直接返回，而应该对二叉树进行完全搜索（遍历每一个节点），如果发现 <code>p</code> 或 <code>q</code> 不存在于树中，那么是不存在 LCA 的。</p>
<p>在 <a href="#%E5%AF%BB%E6%89%BE%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0">寻找一个元素</a> 小节我们写了几种 <code>find</code> 方法，其中一种是对二叉树进行完整遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先去左右子树寻找</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> find(root.left, val);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> find(root.right, val);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">    <span class="keyword">if</span> (root.val == val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题的也类似，只需要将前序位置的判断放到后序位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录 p、q 是否存在于树中</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">foundP</span> <span class="operator">=</span> <span class="literal">false</span>, foundQ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">res</span> <span class="operator">=</span> find(root, p, q);</span><br><span class="line">    <span class="keyword">if</span> (!foundP || !foundQ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p 和 q 都存在二叉树中，才有公共祖先</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> find(root.left, p, q);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> find(root.right, p, q);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序位置，判断当前节点是不是 LCA 节点</span></span><br><span class="line">    <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root.val == left.val || root.val == right.val) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root.val == left.val) &#123;</span><br><span class="line">            foundP = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val == right.val) &#123;</span><br><span class="line">            foundQ = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对二叉树进行完全搜索，同时记录 <code>p</code> 和 <code>q</code> 是否同时存在树中，从而满足题目的要求。</p>
</br>


<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzIzNS4lRTQlQkElOEMlRTUlOEYlODklRTYlOTAlOUMlRTclQjQlQTIlRTYlQTAlOTElRTclOUElODQlRTYlOUMlODAlRTglQkYlOTElRTUlODUlQUMlRTUlODUlQjElRTclQTUlOTYlRTUlODUlODguamF2YQ==">235. 二叉搜索树的最近公共祖先<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb3dlc3QtY29tbW9uLWFuY2VzdG9yLW9mLWEtYmluYXJ5LXNlYXJjaC10cmVlLw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s1.ax1x.com/2022/07/14/jf1o0x.png#crop=0&crop=0&crop=1&crop=1&id=S0eJz&originHeight=1372&originWidth=1460&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>用前面标准最近公共祖先问题的代码同样可以解决这道题，但没有用到 BST 左小右大的性质，显然不是最优解。</p>
<p>在标准的最近公共祖先问题中，我们要在后序位置通过左右子树的搜索结果来判断当前节点是不是 LCA：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> find(root.left, val1, val2);</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> find(root.right, val1, val2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序位置，判断当前节点是不是 LCA 节点</span></span><br><span class="line"><span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>但对于 BST 来说，根本不需要遍历子树，由于 BST 左小右大的性质，将当前节点的值与 <code>val1</code> 和 <code>val2</code> 作对比即可判断当前节点是不是 LCA：</strong></p>
<p>假设 <code>val1 &lt; val2</code>，那么 <code>val1 &lt;= root.val &lt;= val2</code> 则说明当前节点就是 LCA；若 <code>root.val</code> 比 <code>val1</code> 小，则需要去值更大的右子树寻找 LCA；若 <code>root.val</code> 比 <code>val2</code> 还，则需要去值更小的左子树寻找 LCA。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">val1</span> <span class="operator">=</span> p.val &lt; q.val ? p.val : q.val;</span><br><span class="line">    <span class="type">int</span> <span class="variable">val2</span> <span class="operator">=</span> p.val &gt; q.val ? p.val : q.val;</span><br><span class="line">    <span class="keyword">return</span> find(root, val1, val2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 BST 中寻找 val1 和 val2 的最近公共祖先节点</span></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, <span class="type">int</span> val1, <span class="type">int</span> val2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.val &lt; val1) &#123;</span><br><span class="line">        <span class="comment">// 当前节点太小，去右子树找</span></span><br><span class="line">        <span class="keyword">return</span> find(root.right, val1, val2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.val &gt; val2) &#123;</span><br><span class="line">        <span class="comment">// 当前节点太大，去左子树找</span></span><br><span class="line">        <span class="keyword">return</span> find(root.left, val1, val2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时 val1 &lt;= root.val &lt;= val2</span></span><br><span class="line">    <span class="comment">// 则该节点就是最近公共祖先</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就把 BST 的性质利用上了。</p>
</br>


<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzE2NTAuJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxJUU3JTlBJTg0JUU2JTlDJTgwJUU4JUJGJTkxJUU1JTg1JUFDJUU1JTg1JUIxJUU3JUE1JTk2JUU1JTg1JTg4LWlpaS5qYXZh">1650.二叉树的最近公共祖先 III<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG93ZXN0LWNvbW1vbi1hbmNlc3Rvci1vZi1hLWJpbmFyeS10cmVlLWlpaS8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s1.ax1x.com/2022/07/14/jf83If.png#crop=0&crop=0&crop=1&crop=1&id=Kb7Jh&originHeight=1262&originWidth=1462&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>由于节点 <code>Node</code> 包含其父节点的引用，因此不需要输入根节点。这道题也就可以转化为单链表相交的问题：<code>parent</code> 就是 <code>next</code> 指针，需要返回两个节点的交点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">lowestCommonAncestor</span><span class="params">(Node p, Node q)</span> &#123;</span><br><span class="line">   <span class="type">Node</span> <span class="variable">a</span> <span class="operator">=</span> p, b = q;</span><br><span class="line">   <span class="keyword">while</span>(a != b) &#123;</span><br><span class="line">       <span class="keyword">if</span>(a == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">// a 走一步，如果走到根节点，转到 q 节点</span></span><br><span class="line">           a = q;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           a = a.parent;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(b == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">// a 走一步，如果走到根节点，转到 q 节点</span></span><br><span class="line">           b = p;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           b = b.parent;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;   </span><br><span class="line">   <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于单链表的交点问题在之前篇章已经讲过，这里不再赘述（<a href="#%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4">#链表相交问题</a>）。</p>
</br>


<h2 id="完全二叉树的节点数"><a href="#完全二叉树的节点数" class="headerlink" title="完全二叉树的节点数"></a>完全二叉树的节点数</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzIyMi4lRTUlQUUlOEMlRTUlODUlQTglRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTElRTclOUElODQlRTglOEElODIlRTclODIlQjklRTQlQjglQUElRTYlOTUlQjAuamF2YQ==">222.完全二叉树的节点个数<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY291bnQtY29tcGxldGUtdHJlZS1ub2Rlcy8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s1.ax1x.com/2022/07/14/jfY2Qg.png#crop=0&crop=0&crop=1&crop=1&id=y52JL&originHeight=1192&originWidth=1432&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>第一时间可以想到遍历整棵树来计算节点个数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> traverse(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> traverse(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> traverse(root.right);</span><br><span class="line">    <span class="keyword">return</span> left + right + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这样的时间复杂度为 <code>O(N)</code>，而且并没有利用到它是一颗完全二叉树这个前提。</p>
<p>首先要明确一下两个关于二叉树的名词「完全二叉树」和「满二叉树」。</p>
<p>完全二叉树如下图，每一层都是紧凑靠左排列的：</p>
<p><img src="https://s1.ax1x.com/2022/07/14/jftTHA.png#crop=0&crop=0&crop=1&crop=1&id=bHZZT&originHeight=335&originWidth=640&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>满二叉树如下图，是一种特殊的完全二叉树，每层都是是满的，像一个稳定的三角形：</p>
<p><img src="https://s1.ax1x.com/2022/07/14/jftoBd.png#crop=0&crop=0&crop=1&crop=1&id=Ntqko&originHeight=181&originWidth=397&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>若要求一颗普通的树的节点数，可以通过上面代码遍历所有节点进行统计:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + countNodes(root.left) + countNodes(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而若要求一颗满二叉树的节点数，节点总数就和树的高度呈指数关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算树的高度</span></span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        root = root.left;</span><br><span class="line">        h++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 节点总数就是 2^h - 1</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">2</span>, h) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完全二叉树比普通二叉树特殊，但又没有满二叉树那么特殊，计算它的节点总数，可以是普通二叉树和完全二叉树的结合版：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">l</span> <span class="operator">=</span> root, r = root;</span><br><span class="line">    <span class="comment">// 沿最左侧和最右侧分别计算高度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hl</span> <span class="operator">=</span> <span class="number">0</span>, hr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l != <span class="literal">null</span>) &#123;</span><br><span class="line">        l = l.left;</span><br><span class="line">        hl++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">        r = r.right;</span><br><span class="line">        hr++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果左右侧计算的高度相同，则是一棵满二叉树</span></span><br><span class="line">    <span class="keyword">if</span> (hl == hr) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">2</span>, hl) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果左右侧的高度不同，则按照普通二叉树的逻辑计算</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + countNodes(root.left) + countNodes(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分情况来选择不同的方式计算节点数，时间复杂度是 <code>O(logN*logN)</code>。</p>
</br>

<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="图的逻辑结构和具体实现"><a href="#图的逻辑结构和具体实现" class="headerlink" title="图的逻辑结构和具体实现"></a>图的逻辑结构和具体实现</h2><p>一幅图是由节点和边构成的，逻辑结构如下：</p>
<p><img src="https://s1.ax1x.com/2022/07/16/j4XVQs.jpg#crop=0&crop=0&crop=1&crop=1&id=p1vFh&originHeight=301&originWidth=423&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>根据这个逻辑结构，可以认为每个节点的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图节点的逻辑结构</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    Vertex[] neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它和多叉树节点几乎完全一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本的 N 叉树节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode[] children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，图本质上就是个高级的多叉树，适用于树的 DFS&#x2F;BFS 遍历算法，全部适用于图。</p>
<p>不过上面的这种实现是「逻辑上的」，实际上很少用 <code>Vertex</code> 类实现图，而是用邻接表和邻接矩阵来实现。</p>
<p>如上图所示的图，用邻接表和邻接矩阵的存储方式如下：</p>
<p><img src="https://s1.ax1x.com/2022/07/16/j4ji0x.png#crop=0&crop=0&crop=1&crop=1&id=Zu0Z5&originHeight=718&originWidth=1194&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>邻接表很直观，把每个节点 <code>x</code> 的邻居都存到一个列表里，然后把 <code>x</code> 和这个列表关联起来，这样就可以通过一个节点 <code>x</code> 找到它的所有相邻节点。</p>
<p>邻接矩阵则是一个二维布尔数组，称为 <code>matrix</code>，如果节点 <code>x</code> 和 <code>y</code> 是相连的，那么就把 <code>matrix[x][y]</code> 设为 <code>true</code>（上图中绿色的方格代表 <code>true</code>）。如果想找节点 <code>x</code> 的邻居，去扫一圈 <code>matrix[x][..]</code> 就可以了。</p>
<p>如果用代码的形式来表现，邻接表和邻接矩阵大概长这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 邻接表</span></span><br><span class="line"><span class="comment">// graph[x] 存储 x 的所有邻居节点</span></span><br><span class="line">List&lt;Integer&gt;[] graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="comment">// matrix[x][y] 记录 x 是否有一条指向 y 的边</span></span><br><span class="line"><span class="type">boolean</span>[][] matrix;</span><br></pre></td></tr></table></figure>

<p>对于邻接表，优点是占用的空间少。但邻接表无法快速判断两个节点是否相邻。</p>
<p>对于邻接表，优点是可以快速判断两个节点是否相邻，只需要判断 <code>matrix[i][j]</code> 是否为 <code>true</code>。但占用的空间大。</p>
<blockquote>
<p>在常规的算法题中，邻接表的使用会更频繁一些，主要是因为操作起来较为简单，但这不意味着邻接矩阵应该被轻视。矩阵是一个强有力的数学工具，图的一些隐晦性质可以借助精妙的矩阵运算展现出来。</p>
</blockquote>
<p>图论中的度(degree)：在无向图中，「度」就是每个节点相连的边的条数。</p>
<p>由于有向图的边有方向，所以有向图中每个节点「度」被细分为入度（indegree）和出度（outdegree），如下图：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/16/ce98179a2c5048b1.png#crop=0&crop=0&crop=1&crop=1&id=HkyLU&originHeight=301&originWidth=423&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>其中节点 <code>3</code> 的入度为 3（有三条边指向它），出度为 1（它有 1 条边指向别的节点）。</p>
<p>其他更复杂的模型都是基于这个最简单的图衍生出来的。</p>
</br>


<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>参考多叉树的 DFS 遍历框架如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多叉树遍历框架</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode child : root.children) &#123;</span><br><span class="line">        traverse(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图和多叉树最大的区别是，图是可能包含环的，从图的某一个节点开始遍历，有可能走了一圈又回到这个节点，而树不会出现这种情况，从某个节点出发必然走到叶子节点，不会回到它自身。</p>
<p>所以，如果图包含环，遍历框架就要一个 <code>visited</code> 数组进行辅助：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录被遍历过的节点</span></span><br><span class="line"><span class="type">boolean</span>[] visited;</span><br><span class="line"><span class="comment">// 记录从起点到当前节点的路径</span></span><br><span class="line"><span class="type">boolean</span>[] onPath;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图遍历框架</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Graph graph, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (visited[s]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 经过节点 s，标记为已遍历</span></span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 做选择：标记节点 s 在路径上</span></span><br><span class="line">    onPath[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> neighbor : graph.neighbors(s)) &#123;</span><br><span class="line">        traverse(graph, neighbor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 撤销选择：节点 s 离开路径</span></span><br><span class="line">    onPath[s] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 <code>visited</code> 和 <code>onPath</code> 数组的区别，前者用于记录节点是否被遍历过，后者用于记录从起点到当前节点的路径。<code>onPath</code> 在处理路径相关的问题时可以用到。</p>
</br>


<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9HcmFwaC83OTcuJUU2JTg5JTgwJUU2JTlDJTg5JUU1JThGJUFGJUU4JTgzJUJEJUU3JTlBJTg0JUU4JUI3JUFGJUU1JUJFJTg0LmphdmE=">797.所有可能的路径<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hbGwtcGF0aHMtZnJvbS1zb3VyY2UtdG8tdGFyZ2V0Lw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://i.bmp.ovh/imgs/2022/07/16/93d0535f299a3f84.png#crop=0&crop=0&crop=1&crop=1&id=llY6T&originHeight=1152&originWidth=1438&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>以 <code>0</code> 为起点遍历图，同时记录遍历过的路径，当遍历到终点时将路径记录下来即可。由于输入的图是无环图，因此不需要使用 <code>visited</code> 数组辅助：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录所有路径</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">allPathsSourceTarget</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">    <span class="comment">// 维护递归过程中经过的路径</span></span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    traverse(graph, <span class="number">0</span>, path);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图的遍历框架</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(<span class="type">int</span>[][] graph, <span class="type">int</span> s, LinkedList&lt;Integer&gt; path)</span> &#123;</span><br><span class="line">    <span class="comment">// 添加节点 s 到路径</span></span><br><span class="line">    path.addLast(s);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> graph.length;</span><br><span class="line">    <span class="keyword">if</span>(s == n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 到达终点</span></span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">        path.removeLast();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归每个相邻节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v : graph[s]) &#123;</span><br><span class="line">        traverse(graph, v, path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从路径移出节点 s</span></span><br><span class="line">    path.removeLast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 Java 的语言特性，因为 Java 函数参数传的是对象引用，所以向 <code>res</code> 中添加 <code>path</code> 时需要拷贝一个新的列表，否则最终 <code>res</code> 中的列表都是空的。</p>
</br>


<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h3 id="环检测算法-DFS"><a href="#环检测算法-DFS" class="headerlink" title="环检测算法(DFS)"></a>环检测算法(DFS)</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9HcmFwaC8yMDcuJUU4JUFGJUJFJUU3JUE4JThCJUU4JUExJUE4LmphdmE=">207.课程表<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3Vyc2Utc2NoZWR1bGU=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://i.bmp.ovh/imgs/2022/07/16/fc7f1a7787d947d1.png#crop=0&crop=0&crop=1&crop=1&id=WCmtw&originHeight=770&originWidth=1462&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>当存在循环依赖时，无法修完所有课程。<strong>依赖问题首先想到的是把问题转化成「有向图」，只要图中存在环，那就说明存在循环依赖。</strong></p>
<p>可以把课程看成「有向图」中的节点，节点编号分别是 <code>0, 1, ..., numCourses-1</code>，把课程之间的依赖关系看做节点之间的有向边。如必须修完课程 <code>1</code> 才能修课程 <code>3</code>，那么就有一条有向边从节点 <code>1</code> 指向 <code>3</code>。</p>
<p>如果生成当有向图中存在环，说明课程之间存在循环依赖，无法全部上完；反之，如果没有环，就可以完成全部课程。</p>
<p>使用邻接表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt;[] graph;</span><br></pre></td></tr></table></figure>

<p><code>graph[s]</code> 是一个列表，存储着节点 <code>s</code> 所指向的节点。生成图：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt;[] buildGraph(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">    <span class="comment">// 图中共有 numCourses 个节点</span></span><br><span class="line">    List&lt;Integer&gt;[] graph = <span class="keyword">new</span> <span class="title class_">LinkedList</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        graph[i] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] edge : prerequisites) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edge[<span class="number">1</span>], to = edge[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 添加一条从 from 指向 to 的有向边</span></span><br><span class="line">        <span class="comment">// 边的方向是「被依赖」关系，即修完课程 from 才能修课程 to</span></span><br><span class="line">        graph[from].add(to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历图：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防止重复遍历同一个节点</span></span><br><span class="line"><span class="type">boolean</span>[] visited;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt;[] graph = buildGraph(numCourses, prerequisites);</span><br><span class="line">    </span><br><span class="line">    visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        traverse(graph, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从节点 s 开始 DFS 遍历，将遍历过的节点标记为 true</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(List&lt;Integer&gt;[] graph, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(visited[s]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 前序遍历代码位置 */</span></span><br><span class="line">    <span class="comment">// 将当前节点标记为已遍历</span></span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t : graph[s]) &#123;</span><br><span class="line">        traverse(graph, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 后序遍历代码位置 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意图中并不是所有节点都相连，所以要用一个 for 循环将所有节点都作为起点调用一次 DFS 搜索算法。<br>只需要再添加一个布尔数组 <code>onPath</code> 记录当前 <code>traverse</code> 经过的路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span>[] onPath;</span><br><span class="line"><span class="type">boolean</span>[] visited;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">hasCycle</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(List&lt;Integer&gt;[] graph, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (onPath[s]) &#123;</span><br><span class="line">        <span class="comment">// 发现环</span></span><br><span class="line">        hasCycle = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (visited[s] || hasCycle) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将节点 s 标记为已遍历</span></span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 开始遍历节点 s</span></span><br><span class="line">    onPath[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t : graph[s]) &#123;</span><br><span class="line">        traverse(graph, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 节点 s 遍历完成</span></span><br><span class="line">    onPath[s] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在进入节点 <code>s</code> 的时候将 <code>onPath[s]</code> 标记为 <code>true</code>，离开时标记回 <code>false</code>，如果发现 <code>onPath[s]</code> 已经被标记，说明出现了环。</p>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录遍历过的节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span>[] visited;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录一次递归堆栈中的节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span>[] onPath;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录图中是否有环</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">hasCycle</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt;[] graph = buildGraph(numCourses, prerequisites);</span><br><span class="line"></span><br><span class="line">    visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[numCourses];</span><br><span class="line">    onPath = <span class="keyword">new</span> <span class="title class_">boolean</span>[numCourses];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        traverse(graph, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !hasCycle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;Integer&gt;[] buildGraph(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">    List&lt;Integer&gt;[] graph = <span class="keyword">new</span> <span class="title class_">LinkedList</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        graph[i] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>[] edge : prerequisites) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edge[<span class="number">1</span>], to = edge[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 边的方向是「被依赖」关系，即修完课程 from 才能修课程 to</span></span><br><span class="line">        graph[from].add(to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(List&lt;Integer&gt;[] graph, <span class="type">int</span> s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(onPath[s]) &#123;</span><br><span class="line">        <span class="comment">// 存在环</span></span><br><span class="line">        hasCycle = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(visited[s] || hasCycle) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    onPath[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t : graph[s])&#123;</span><br><span class="line">        traverse(graph, t);</span><br><span class="line">    &#125;</span><br><span class="line">    onPath[s] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h3 id="拓扑排序算法-DFS"><a href="#拓扑排序算法-DFS" class="headerlink" title="拓扑排序算法(DFS)"></a>拓扑排序算法(DFS)</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9HcmFwaC8yMTAuJUU4JUFGJUJFJUU3JUE4JThCJUU4JUExJUE4LWlpLmphdmE=">210.课程表 II<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY291cnNlLXNjaGVkdWxlLWlp">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://i.bmp.ovh/imgs/2022/07/16/d982dfeffc93194d.png#crop=0&crop=0&crop=1&crop=1&id=X0XWi&originHeight=746&originWidth=1450&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>与 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9HcmFwaC8yMDcuJUU4JUFGJUJFJUU3JUE4JThCJUU4JUExJUE4LmphdmE=">#207<i class="fa fa-external-link-alt"></i></span> 不同的事，需要进一步返回一个合理的上课顺序，保证开始修每个课程时，前置的课程都已经修完。</p>
<p>如果一幅有向图中存在环，是无法进行 <span class="exturl" data-url="aHR0cHM6Ly9iYWlqaWFoYW8uYmFpZHUuY29tL3M/aWQ9MTcxNzY1Mjk5OTg3NDE1NDkwOSZ3ZnI9c3BpZGVyJmZvcj1wYw==">拓扑排序<i class="fa fa-external-link-alt"></i></span> 的。如果把课程抽象成节点，课程之间的依赖关系抽象成有向边，那么拓扑排序结果就是上课顺序。</p>
<p><strong>将后序遍历的结果进行反转，就是拓扑排序的结果。</strong></p>
<blockquote>
<p>是否需要反转看的是对边的定义，即依赖与被依赖关系。</p>
</blockquote>
<p>对于环的判断，可以使用上提的主函数，完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录后序遍历结果</span></span><br><span class="line">List&lt;Integer&gt; postorder = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 记录是否存在环</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">hasCycle</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">boolean</span>[] visited, onPath;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">    List&lt;Integer&gt;[] graph = buildGraph(numCourses, prerequisites);</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[numCourses];</span><br><span class="line">    onPath = <span class="keyword">new</span> <span class="title class_">boolean</span>[numCourses];</span><br><span class="line">    <span class="comment">// 遍历图</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        traverse(graph, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有环图无法进行拓扑排序</span></span><br><span class="line">    <span class="keyword">if</span> (hasCycle) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 逆后序遍历结果即为拓扑排序结果</span></span><br><span class="line">    Collections.reverse(postorder);</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        res[i] = postorder.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图遍历函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(List&lt;Integer&gt;[] graph, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (onPath[s]) &#123;</span><br><span class="line">        <span class="comment">// 发现环</span></span><br><span class="line">        hasCycle = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (visited[s] || hasCycle) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序遍历位置</span></span><br><span class="line">    onPath[s] = <span class="literal">true</span>;</span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t : graph[s]) &#123;</span><br><span class="line">        traverse(graph, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后序遍历位置</span></span><br><span class="line">    postorder.add(s);</span><br><span class="line">    onPath[s] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt;[] buildGraph(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h3 id="环检测算法-BFS"><a href="#环检测算法-BFS" class="headerlink" title="环检测算法(BFS)"></a>环检测算法(BFS)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">    <span class="comment">// 建图，有向边代表「被依赖」关系</span></span><br><span class="line">    List&lt;Integer&gt;[] graph = buildGraph(numCourses, prerequisites);</span><br><span class="line">    <span class="comment">// 构建入度数组</span></span><br><span class="line">    <span class="type">int</span>[] indegree = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] edge : prerequisites) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edge[<span class="number">1</span>], to = edge[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 节点 to 的入度加一</span></span><br><span class="line">        indegree[to]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据入度初始化队列中的节点</span></span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 节点 i 没有入度，即没有依赖的节点</span></span><br><span class="line">            <span class="comment">// 可以作为拓扑排序的起点，加入队列</span></span><br><span class="line">            q.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录遍历的节点个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 开始执行 BFS 循环</span></span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 弹出节点 cur，并将它指向的节点的入度减一</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> next : graph[cur]) &#123;</span><br><span class="line">            indegree[next]--;</span><br><span class="line">            <span class="keyword">if</span> (indegree[next] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果入度变为 0，说明 next 依赖的节点都已被遍历</span></span><br><span class="line">                q.offer(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有节点都被遍历过，说明不成环</span></span><br><span class="line">    <span class="type">return</span> <span class="variable">count</span> <span class="operator">=</span>= numCourses;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt;[] buildGraph(<span class="type">int</span> n, <span class="type">int</span>[][] edges) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>构建邻接表，边的方向表示「被依赖」关系。 </li>
<li>构建一个 <code>indegree</code> 数组记录每个节点的入度，即 <code>indegree[i]</code> 记录节点 <code>i</code> 的入度。 </li>
<li>对 BFS 队列进行初始化，将入度为 0 的节点首先装入队列。 </li>
<li>开始执行 BFS 循环，不断弹出队列中的节点，减少相邻节点的入度，并将入度变为 0 的节点加入队列。 </li>
<li>如果最终所有节点都被遍历过（<code>count</code> 等于节点数），则说明不存在环，反之则说明存在环。</li>
</ol>
<p><img src="https://i.bmp.ovh/imgs/2022/07/16/c72d2bb208786b4d.png#crop=0&crop=0&crop=1&crop=1&id=n6sqn&originHeight=674&originWidth=1494&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>如果存在节点没有被遍历即，那么说明图中存在环。</p>
</br>


<h3 id="拓扑排序-BFS"><a href="#拓扑排序-BFS" class="headerlink" title="拓扑排序(BFS)"></a>拓扑排序(BFS)</h3><p>由上面的思路可以发现，图中每个节点入队的顺序就是一个可行的拓扑排序结果。</p>
<p>因此只需要修改 BFS 版本的环检测算法，记录节点的遍历顺序即可得到拓扑排序的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">    <span class="comment">// 建图，和环检测算法相同</span></span><br><span class="line">    List&lt;Integer&gt;[] graph = buildGraph(numCourses, prerequisites);</span><br><span class="line">    <span class="comment">// 计算入度，和环检测算法相同</span></span><br><span class="line">    <span class="type">int</span>[] indegree = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] edge : prerequisites) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edge[<span class="number">1</span>], to = edge[<span class="number">0</span>];</span><br><span class="line">        indegree[to]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据入度初始化队列中的节点，和环检测算法相同</span></span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            q.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录拓扑排序结果</span></span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">    <span class="comment">// 记录遍历节点的顺序（索引）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 开始执行 BFS 算法</span></span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">        <span class="comment">// 弹出节点的顺序即为拓扑排序结果</span></span><br><span class="line">        res[count] = cur;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> next : graph[cur]) &#123;</span><br><span class="line">            indegree[next]--;</span><br><span class="line">            <span class="keyword">if</span> (indegree[next] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.offer(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count != numCourses) &#123;</span><br><span class="line">        <span class="comment">// 存在环，拓扑排序不存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建图函数</span></span><br><span class="line">List&lt;Integer&gt;[] buildGraph(<span class="type">int</span> n, <span class="type">int</span>[][] edges) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 BFS 算法是通过 <code>indegree</code> 数组实现的 <code>visited</code> 数组的作用，只有入度为 <code>0</code> 的节点才能入队，从而保证不会出现死循环。</p>
</br>

<h2 id="二分图判定"><a href="#二分图判定" class="headerlink" title="二分图判定"></a>二分图判定</h2><h3 id="二分图简介"><a href="#二分图简介" class="headerlink" title="二分图简介"></a>二分图简介</h3><p>百度百科对「二分图」的定义：</p>
<blockquote>
<p>二分图的顶点集可分割为两个互不相交的子集，图中每条边依附的两个顶点都分属于这两个子集，且两个子集内的顶点不相邻。</p>
</blockquote>
<p><img src="https://i.bmp.ovh/imgs/2022/07/17/8cff726790465c70.png#crop=0&crop=0&crop=1&crop=1&id=pgD7S&originHeight=922&originWidth=960&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>其实就是「双色问题」：用两种颜色将图中的所有顶点着色，且使得任意一条边的两个端点的颜色都不相同。</p>
<p>这个问题就等同于二分图的判定问题，如果能够成功地将图染色，那么这幅图就是一幅二分图，反之则不是：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/07/17/f70c199ad17d839d.png#crop=0&crop=0&crop=1&crop=1&id=oQkMq&originHeight=642&originWidth=1114&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>二分图作为一种特殊的图模型，会被很多高级图算法（比如最大流算法）用到。二分图结构在某些场景可以更高效地存储数据。</p>
</br>


<h3 id="二分图判定思路"><a href="#二分图判定思路" class="headerlink" title="二分图判定思路"></a>二分图判定思路</h3><p>判定二分图就是用代码解决「双色问题」：<strong>遍历一遍图，一边遍历一边染色，判断是否能用两种颜色给所有节点染色，且相邻节点的颜色都不相同。</strong></p>
<p>首先可以写出图的遍历框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span>[] visited;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Graph graph, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(visited[v]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(TreeNode neighbor : graph.neighbors(v)) &#123;</span><br><span class="line">        traverse(graph, neighbor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为图中可能存在环，所以用 <code>visited</code> 数组防止死循环。</p>
<p>也可以把判断是否走过放在其他地方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span>[] visited;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Graph graph, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="comment">// 前序遍历位置，标记节点 v 已访问</span></span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> neighbor : graph.neighbors(v)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">            <span class="comment">// 只遍历没标记过的相邻节点</span></span><br><span class="line">            traverse(graph, neighbor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法把对 <code>visited</code> 的判断放到递归调用之前，和之前的写法唯一的不同是需要保证调用 <code>traverse(v)</code> 的时候，<code>visited[v] == false</code>。</p>
<p>这样就可以写出二分图判定的代码逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Graph graph, <span class="type">boolean</span>[] visited, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 遍历节点 v 的所有相邻节点 neighbor</span></span><br><span class="line">    <span class="keyword">for</span>(TreeNode neighbor : graph.neighbors(v)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">            <span class="comment">// 如果没访问过，就给节点 neighbor 涂上与 v 不同的颜色</span></span><br><span class="line">            traverse(graph, visited, neighbor);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 相邻节点 neighbor 已经被访问过</span></span><br><span class="line">            <span class="comment">// 那么应该比较节点 neighbor 和节点 v 的颜色</span></span><br><span class="line">            <span class="comment">// 若相同，则此图不是二分图</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9HcmFwaC83ODUuJUU1JTg4JUE0JUU2JTk2JUFEJUU0JUJBJThDJUU1JTg4JTg2JUU1JTlCJUJFLmphdmE=">785.判断二分图<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pcy1ncmFwaC1iaXBhcnRpdGUv">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://i.bmp.ovh/imgs/2022/07/17/9009c2c644e1cb1e.png#crop=0&crop=0&crop=1&crop=1&id=Yrwd3&originHeight=1360&originWidth=1432&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>可以额外使用一个 <code>color</code> 数组来记录每个节点的颜色：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录图是否符合二分图性质</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">ok</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 记录图中节点的颜色，false 和 true 代表两种不同颜色</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span>[] color;</span><br><span class="line"><span class="comment">// 记录图中节点是否被访问过</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span>[] visited;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBipartite</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">    color = <span class="keyword">new</span> <span class="title class_">boolean</span>[graph.length];</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[graph.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为图不一定是联通的，可能存在多个子图</span></span><br><span class="line">    <span class="comment">// 所以要把每个节点都作为起点进行一次遍历</span></span><br><span class="line">    <span class="comment">// 如果发现任何一个子图不是二分图，整幅图都不算二分图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i]) &#123;</span><br><span class="line">            traverse(graph, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(<span class="type">int</span>[][] graph, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!ok) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> w : graph[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[w]) &#123;</span><br><span class="line">            <span class="comment">// 相邻节点 w 没有被访问过</span></span><br><span class="line">            <span class="comment">// 给节点 w 涂上和节点 v 不同的颜色</span></span><br><span class="line">            color[w] = !color[v];</span><br><span class="line">            <span class="comment">// 继续遍历 w</span></span><br><span class="line">            traverse(graph, w);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 相邻节点 w 已经被访问过</span></span><br><span class="line">            <span class="comment">// 根据 v 和 w 的颜色判断是否是二分图</span></span><br><span class="line">            <span class="keyword">if</span>(color[w] == color[v]) &#123;</span><br><span class="line">                <span class="comment">// 若相同，则此图不是二分图</span></span><br><span class="line">                ok = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>


<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9HcmFwaC84ODYuJUU1JThGJUFGJUU4JTgzJUJEJUU3JTlBJTg0JUU0JUJBJThDJUU1JTg4JTg2JUU2JUIzJTk1LmphdmE=">886.可能的二分法<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wb3NzaWJsZS1iaXBhcnRpdGlvbi8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://i.bmp.ovh/imgs/2022/07/17/0bf7a7e4dcfa0edf.png#crop=0&crop=0&crop=1&crop=1&id=hFvS5&originHeight=1110&originWidth=1460&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>如果把每个人看做图中的节点，相互讨厌的关系看做图中的边，那么 <code>dislikes</code> 数组就可以构成一幅图。</p>
<p>又因为互相讨厌的人不能放在同一组里，相当于图中的所有相邻节点都要放进两个不同的组。</p>
<p>这就回到了「双色问题」，如果能够用两种颜色着色所有节点，且相邻节点颜色都不同，那么按照颜色把这些节点分成两组就可以了。</p>
<p>把 <code>dislikes</code> 构造成一幅图，然后执行二分图的判定算法即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">ok</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span>[] color;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span>[] visited;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">possibleBipartition</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] dislikes)</span> &#123;</span><br><span class="line">    <span class="comment">// 图节点编号从 1 开始</span></span><br><span class="line">    color = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转化成邻接表表示图结构</span></span><br><span class="line">    List&lt;Integer&gt;[] graph = buildGraph(n, dislikes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i]) &#123;</span><br><span class="line">            traverse(graph, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;Integer&gt;[] buildGraph(<span class="type">int</span> n, <span class="type">int</span>[][] dislikes) &#123;</span><br><span class="line">    <span class="comment">// 图节点编号为 1...n</span></span><br><span class="line">    List&lt;Integer&gt;[] graph = <span class="keyword">new</span> <span class="title class_">LinkedList</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        graph[i] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>[] edge : dislikes) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> edge[<span class="number">1</span>], w = edge[<span class="number">0</span>];</span><br><span class="line">        graph[v].add(w);</span><br><span class="line">        graph[w].add(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(List&lt;Integer&gt;[] graph, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!ok) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> w : graph[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[w]) &#123;</span><br><span class="line">            color[w] = !color[v];</span><br><span class="line">            traverse(graph, w);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(color[w] == color[v]) &#123;</span><br><span class="line">                ok = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h2 id="并查集-UNION-FIND-算法"><a href="#并查集-UNION-FIND-算法" class="headerlink" title="并查集(UNION-FIND)算法"></a>并查集(UNION-FIND)算法</h2><p>Union-Find 算法，也就是常说的并查集（Disjoint Set）结构，主要是解决图论中「动态连通性」问题的。</p>
<p>动态连通性其实可以抽象成给一幅图连线。比如下面这幅图，总共有 10 个节点，他们互不相连，分别用 0~9 标记：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/07/17/f728d0b913a522eb.png#crop=0&crop=0&crop=1&crop=1&id=dQJAc&originHeight=744&originWidth=854&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>Union-Find 算法主要需要实现这两个 API：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">    <span class="comment">/* 将 p 和 q 连接 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>;</span><br><span class="line">    <span class="comment">/* 判断 p 和 q 是否连通 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>;</span><br><span class="line">    <span class="comment">/* 返回图中有多少个连通分量 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里所说的「连通」是一种等价关系，也就是说具有如下三个性质：</p>
<ol>
<li>自反性：节点 <code>p</code> 和 <code>p</code> 是连通的。 </li>
<li>对称性：如果节点 <code>p</code> 和 <code>q</code> 连通，那么 <code>q</code> 和 <code>p</code> 也连通。 </li>
<li>传递性：如果节点 <code>p</code> 和 <code>q</code> 连通，<code>q</code> 和 <code>r</code> 连通，那么 <code>p</code> 和 <code>r</code> 也连通。</li>
</ol>
<p>比如 0～9 任意两个不同的点都不连通，调用 <code>connected</code> 都会返回 <code>false</code>，连通分量为 10 个。</p>
<p>如果调用 <code>union(0, 1)</code>，那么 0 和 1 被连通，连通分量降为 9 个。</p>
<p>再调用 <code>union(1, 2)</code>，这时 0, 1, 2 都被连通，调用 <code>connected(0, 2)</code> 也会返回 <code>true</code>，连通分量变为 8 个。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/17/c0dc0dfc657d0867.png#crop=0&crop=0&crop=1&crop=1&id=ojq3K&originHeight=736&originWidth=840&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>判断这种「等价关系」非常实用，如编译器判断同一个变量的不同引用、社交网络中的朋友圈计算等。</p>
</br>


<h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>可以使用森林（若干棵树）来表示图的动态连通性，用数组来具体实现这个森林。</p>
<p>设定树的每个节点有一个指针指向其父节点，如果是根节点的话，这个指针指向自己。如上图一开始的时候没有相互连通：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/17/a63c386fe86d030e.png#crop=0&crop=0&crop=1&crop=1&id=WIHzU&originHeight=310&originWidth=916&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">    <span class="comment">// 记录连通分量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="comment">// 节点 x 的父节点是 parent[x]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造函数，n 为图的节点总数 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UF</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 一开始互不联通</span></span><br><span class="line">        <span class="built_in">this</span>.count = n;</span><br><span class="line">        <span class="comment">// 父节点指针初始指向自己</span></span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果某两个节点被连通，则让其中的（任意）一个节点的根节点接到另一个节点的根节点上：</strong></p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/17/e4470285be9e73a5.png#crop=0&crop=0&crop=1&crop=1&id=zgTLF&originHeight=862&originWidth=2188&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">    <span class="keyword">if</span>(rootP == rootQ) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将两棵树合并为一棵</span></span><br><span class="line">    parent[rootP] = rootQ;</span><br><span class="line">    <span class="comment">// 也可以使用 parent[rootQ] = rootP </span></span><br><span class="line">    <span class="comment">// 两个分量合二为一，连通分量减一</span></span><br><span class="line">    count--; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 返回某个节点 x 的根节点 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// 根节点的 parent[x] == x</span></span><br><span class="line">    <span class="keyword">while</span>(parent[x] != x) &#123;</span><br><span class="line">        x = parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回当前的连通分量个数 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，如果节点 <code>p</code> 和 <code>q</code> 连通的话，它们一定拥有相同的根节点：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/17/623924a23a7430b2.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">    <span class="type">return</span> <span class="variable">rootP</span> <span class="operator">=</span>= rootQ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，Union-Find 算法就基本完成了。</p>
</br>


<h3 id="平衡性优化"><a href="#平衡性优化" class="headerlink" title="平衡性优化"></a>平衡性优化</h3><p>这个算法的主要 API <code>connected</code> 和 <code>union</code> 中的复杂度都是 <code>find</code> 函数造成的，所以说它们的复杂度和 <code>find</code> 一样。</p>
<p><code>find</code> 主要功能就是从某个节点向上遍历到树根，其时间复杂度就是树的高度。我们可能习惯性地认为树的高度就是 <code>logN</code>，但这并不一定。<code>logN</code> 的高度只存在于平衡二叉树，对于一般的树可能出现极端不平衡的情况，使得「树」几乎退化成「链表」，树的高度最坏情况下可能变成 <code>N</code>。</p>
<p>所以上面这种解法 <code>find</code> , <code>union</code> , <code>connected</code> 的时间复杂度都是 <code>O(N)</code>。</p>
<p>因此需要考虑如何避免树的不平衡，关键在于 <code>union</code> 过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">    <span class="keyword">if</span> (rootP == rootQ) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    parent[rootP] = rootQ;</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里直接把 <code>p</code> 所在的树接到 <code>q</code> 所在的树的根节点下面，就可能出现「头重脚轻」的不平衡状况，比如下面这种局面：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/17/ce502110e6817313.png#crop=0&crop=0&crop=1&crop=1&id=ike3X&originHeight=1028&originWidth=1226&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>长此以往，树可能生长得很不平衡。我们希望小一些的树接到大一些的树下面，这样就能避免头重脚轻，更平衡一些。解决方法是额外使用一个 <code>size</code> 数组，记录每棵树包含的节点数，不妨称为「重量」：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="comment">// 新增一个数组记录树的“重量”</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UF</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">// 最初每棵树只有一个节点</span></span><br><span class="line">        <span class="comment">// 重量应该初始化 1</span></span><br><span class="line">        size = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            size[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 其他函数 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如 <code>size[3] = 5</code> 表示，以节点 <code>3</code> 为根的树总共有 5 个节点。修改一下 <code>union</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">    <span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 小树接到大树下面，较平衡</span></span><br><span class="line">    <span class="keyword">if</span> (size[rootP] &gt; size[rootQ]) &#123;</span><br><span class="line">        parent[rootQ] = rootP;</span><br><span class="line">        size[rootP] += size[rootQ];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent[rootP] = rootQ;</span><br><span class="line">        size[rootQ] += size[rootP];</span><br><span class="line">    &#125;</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，通过比较树的重量，就可以保证树的生长相对平衡，树的高度大致在 <code>logN</code> 这个数量级，极大提升执行效率。</p>
<p>此时 <code>find</code> , <code>union</code> , <code>connected</code> 的时间复杂度都下降为 <code>O(logN)</code>。</p>
</br>


<h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p><strong>其实我们并不在乎每棵树的结构长什么样，只在乎根节点。</strong></p>
<p>因为无论树长什么样，树上的每个节点的根节点都是相同的，所以可以进一步压缩每棵树的高度，使树高始终保持为常数。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/17/6d93bfc2a8d5292c.png#crop=0&crop=0&crop=1&crop=1&id=mJjPQ&originHeight=366&originWidth=1458&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>这样每个节点的父节点就是整棵树的根节点，<code>find</code> 就能以 <code>O(1)</code> 的时间找到某一节点的根节点，相应的，<code>connected</code> 和 <code>union</code> 复杂度都下降为 <code>O(1)</code>。</p>
<p>要做到这一点主要是修改 <code>find</code> 函数逻辑.</p>
<p>第一种是在 <code>find</code> 中加一行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (parent[x] != x) &#123;</span><br><span class="line">        <span class="comment">// 这行代码进行路径压缩</span></span><br><span class="line">        parent[x] = parent[parent[x]];</span><br><span class="line">        x = parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次 while 循环都会把一对父子节点改到同一层，这样每次调用 <code>find</code> 函数向树根遍历的同时就将树高缩短了。</p>
<p>路径压缩的第二种写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">        parent[x] = find(parent[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>翻译成迭代：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// 先找到根节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> x;</span><br><span class="line">    <span class="keyword">while</span> (parent[root] != root) &#123;</span><br><span class="line">        root = parent[root];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 然后把 x 到根节点之间的所有节点直接接到根节点下面</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">old_parent</span> <span class="operator">=</span> parent[x];</span><br><span class="line">    <span class="keyword">while</span> (x != root) &#123;</span><br><span class="line">        parent[x] = root;</span><br><span class="line">        x = old_parent;</span><br><span class="line">        old_parent = parent[old_parent];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s3.bmp.ovh/imgs/2022/07/17/0e8193deed942bfd.png"></p>
<p>比起第一种路径压缩，显然这种方法压缩得更彻底，直接把一整条树枝压平。就算一些极端情况下产生了一棵比较高的树，只要一次路径压缩就能大幅降低树高，从摊还分析的角度来看，所有操作的平均时间复杂度依然是 <code>O(1)</code>。</p>
<p>另外，如果使用路径压缩技巧，那么 <code>size</code> 数组的平衡优化就不是特别必要了：</p>
<p><a id="Union-Find"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">    <span class="comment">// 连通分量个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="comment">// 存储每个节点的父节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// n 为图中节点的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UF</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将节点 p 和节点 q 连通</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        parent[rootQ] = rootP;</span><br><span class="line">        <span class="comment">// 两个连通分量合并成一个连通分量</span></span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断节点 p 和节点 q 是否连通</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">        <span class="type">return</span> <span class="variable">rootP</span> <span class="operator">=</span>= rootQ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">            parent[x] = find(parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回图中的连通分量个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Union-Find 算法的复杂度的分析：构造函数初始化数据结构需要 <code>O(N)</code> 的时间和空间复杂度；连通两个节点 <code>union</code>、判断两个节点的连通性 <code>connected</code>、计算连通分量 <code>count</code> 所需的时间复杂度均为 <code>O(1)</code>。</p>
<p>优化算法的过程：</p>
<ol>
<li>用 <code>parent</code> 数组记录每个节点的父节点，相当于指向父节点的指针，所以 <code>parent</code> 数组内实际存储着一个森林（若干棵多叉树）。 </li>
<li>用 <code>size</code> 数组记录着每棵树的重量，目的是让 <code>union</code> 后树依然拥有平衡性，保证各个 API 时间复杂度为 <code>O(logN)</code>，而不会退化成链表影响操作效率。 </li>
<li>在 <code>find</code> 函数中进行路径压缩，保证任意树的高度保持在常数，使得各个 API 时间复杂度为 <code>O(1)</code>。使用了路径压缩之后，可以不使用 size 数组的平衡优化。</li>
</ol>
</br>


<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9HcmFwaC8zMjMuJUU2JTk3JUEwJUU1JTkwJTkxJUU1JTlCJUJFJUU0JUI4JUFEJUU4JUJGJTlFJUU5JTgwJTlBJUU1JTg4JTg2JUU5JTg3JThGJUU3JTlBJTg0JUU2JTk1JUIwJUU3JTlCJUFFLmphdmE=">323.无向图中连通分量的数目<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9udW1iZXItb2YtY29ubmVjdGVkLWNvbXBvbmVudHMtaW4tYW4tdW5kaXJlY3RlZC1ncmFwaC8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/17/b74a073b1f32239f.png#crop=0&crop=0&crop=1&crop=1&id=wnIQO&originHeight=1068&originWidth=1460&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>可以直接使用 UF 类来解决：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countComponents</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line">    <span class="type">UF</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UF</span>(n);</span><br><span class="line">    <span class="comment">// 将每个节点进行连通</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] e : edges) &#123;</span><br><span class="line">        uf.union(e[<span class="number">0</span>], e[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回连通分量的个数</span></span><br><span class="line">    <span class="keyword">return</span> uf.count();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<p>另外，一些使用 DFS 深度优先算法解决的问题，也可以用 Union-Find 算法解决。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9HcmFwaC8xMzAuJUU4JUEyJUFCJUU1JTlCJUI0JUU3JUJCJTk1JUU3JTlBJTg0JUU1JThDJUJBJUU1JTlGJTlGLmphdmE=">130.被围绕的区域<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdXJyb3VuZGVkLXJlZ2lvbnMv">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/17/d9305aef676d77d3.png#crop=0&crop=0&crop=1&crop=1&id=rzot8&originHeight=1146&originWidth=1432&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>必须是四面被围的 <code>O</code> 才能被换成 <code>X</code>，也就是说边角上的 <code>O</code> 一定不会被围，进一步，与边角上的 <code>O</code> 相连的 <code>O</code> 也不会被 <code>X</code> 围四面，也不会被替换。</p>
<p>如果使用 DFS 算法：</p>
<p>先用 for 循环遍历棋盘的四边，用 DFS 算法把那些与边界相连的 <code>O</code> 换成一个特殊字符，比如 <code>#</code>；然后再遍历整个棋盘，把剩下的 <code>O</code> 换成 <code>X</code>，把 <code>#</code> 恢复成 <code>O</code>。这样就能完成题目的要求，时间复杂度 <code>O(MN)</code>。</p>
<p>这个问题也可以用 Union-Find 算法解决：</p>
<p>把所有靠边的 <code>O</code> 和一个虚拟节点 <code>dummy</code> 进行连通：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/17/55715f2b73aa74f7.png#crop=0&crop=0&crop=1&crop=1&id=HvjrS&originHeight=696&originWidth=1070&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>首先要解决的是，根据我们的实现，Union-Find 底层用的是一维数组，构造函数需要传入这个数组的大小，而题目给的是一个二维棋盘。</p>
<p>二维坐标 <code>(x,y)</code> 可以转换成 <code>x * n + y</code> 这个数（<code>m</code> 是棋盘的行数，<code>n</code> 是棋盘的列数）。<strong>这是将二维坐标映射到一维的常用技巧</strong>。</p>
<p>其次，索引 <code>[0.. m*n-1]</code> 都是棋盘内坐标的一维映射，因此虚拟的 <code>dummy</code> 节点占据索引 <code>m * n</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (board.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> board.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">// 给 dummy 留一个额外位置</span></span><br><span class="line">    <span class="type">UF</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UF</span>(m * n + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">dummy</span> <span class="operator">=</span> m * n;</span><br><span class="line">    <span class="comment">// 将首列和末列的 O 与 dummy 连通</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            uf.union(i * n, dummy);</span><br><span class="line">        <span class="keyword">if</span> (board[i][n - <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            uf.union(i * n + n - <span class="number">1</span>, dummy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将首行和末行的 O 与 dummy 连通</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[<span class="number">0</span>][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            uf.union(j, dummy);</span><br><span class="line">        <span class="keyword">if</span> (board[m - <span class="number">1</span>][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            uf.union(n * (m - <span class="number">1</span>) + j, dummy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方向数组 d 是上下左右搜索的常用手法</span></span><br><span class="line">    <span class="type">int</span>[][] d = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">0</span>,-<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) </span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                <span class="comment">// 将此 O 与上下左右的 O 连通</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> i + d[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> j + d[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (board[x][y] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                        uf.union(x * n + y, i * n + j);</span><br><span class="line">                &#125;</span><br><span class="line">    <span class="comment">// 所有不和 dummy 连通的 O，都要被替换</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) </span><br><span class="line">            <span class="keyword">if</span> (!uf.connected(dummy, i * n + j))</span><br><span class="line">                board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路与 DFS 算法相同，只有和边界 <code>O</code> 相连的 <code>O</code> 才具有和 <code>dummy</code> 的连通性，它们不会被替换。</p>
<p>虽然实现复杂一些，甚至效率也略低于 DFS，但可以体现 Union-Find 主要思路：<strong>适时增加虚拟节点，想办法让元素「分门别类」，建立动态连通关系</strong>。</p>
</br>


<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9HcmFwaC85OTAuJUU3JUFEJTg5JUU1JUJDJThGJUU2JTk2JUI5JUU3JUE4JThCJUU3JTlBJTg0JUU1JThGJUFGJUU2JUJCJUExJUU4JUI2JUIzJUU2JTgwJUE3LmphdmE=">990.等式方程的可满足性<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zYXRpc2ZpYWJpbGl0eS1vZi1lcXVhbGl0eS1lcXVhdGlvbnMv">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/17/6c03e9cdcc2194b5.png#crop=0&crop=0&crop=1&crop=1&id=nHKU5&originHeight=688&originWidth=1442&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>动态连通性其实就是一种等价关系，具有「自反性」「传递性」和「对称性」，<code>==</code> 关系也是一种等价关系，具有这些性质。所以这个问题适合使用 Union-Find 算法。</p>
<p>核心思想是，将 <code>equations</code> 中的算式根据 <code>==</code> 和 <code>!=</code> 分成两部分，先处理 <code>==</code> 算式，使得它们通过相等关系各自关联（连通分量）；然后处理 <code>!=</code> 算式，检查不等关系是否破坏了相等关系的连通性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">equationsPossible</span><span class="params">(String[] equations)</span> &#123;</span><br><span class="line">    <span class="comment">// 26 个英文字母</span></span><br><span class="line">    <span class="type">UF</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UF</span>(<span class="number">26</span>);</span><br><span class="line">    <span class="comment">// 先让相等的字母形成连通分量</span></span><br><span class="line">    <span class="keyword">for</span> (String eq : equations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eq.charAt(<span class="number">1</span>) == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">x</span> <span class="operator">=</span> eq.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="type">char</span> <span class="variable">y</span> <span class="operator">=</span> eq.charAt(<span class="number">3</span>);</span><br><span class="line">            uf.union(x - <span class="string">&#x27;a&#x27;</span>, y - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查不等关系是否打破相等关系的连通性</span></span><br><span class="line">    <span class="keyword">for</span> (String eq : equations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eq.charAt(<span class="number">1</span>) == <span class="string">&#x27;!&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">x</span> <span class="operator">=</span> eq.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="type">char</span> <span class="variable">y</span> <span class="operator">=</span> eq.charAt(<span class="number">3</span>);</span><br><span class="line">            <span class="comment">// 如果相等关系成立，就是逻辑冲突</span></span><br><span class="line">            <span class="keyword">if</span> (uf.connected(x - <span class="string">&#x27;a&#x27;</span>, y - <span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h2 id="Kruskal-最小生成树算法"><a href="#Kruskal-最小生成树算法" class="headerlink" title="Kruskal 最小生成树算法"></a>Kruskal 最小生成树算法</h2><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p><strong>「树」和「图」的根本区别：树不会包含环，图可以包含环</strong>。</p>
<p>一副没有环的图可以拉伸成一棵树，即树是「无环连通图」。而「生成树」就是在图中找一颗饱含图所有节点的树，即生成树是含有图中所有顶点的「无环连通子图」。</p>
<p>一幅图可以有多种不同的生成树，如下图红色边就组成了两棵不同的生成树：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/18/18535749842df6e7.png#crop=0&crop=0&crop=1&crop=1&id=ZRRHj&originHeight=852&originWidth=1600&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>对于加权图，每条边都有权重，所以每棵生成树都有一个权重和。如上图，右侧生成树的权重和比左侧生成树的权重和小。</p>
<p>因此「最小生成树」就是在所有可能的生成树中，权重和最小的那棵生成树。</p>
</br>


<h3 id="Union-Find-并查集算法"><a href="#Union-Find-并查集算法" class="headerlink" title="Union-Find 并查集算法"></a>Union-Find 并查集算法</h3><p>图的生成树是含有其所有顶点的「无环连通子图」，最小生成树是权重和最小的生成树。而说到连通性就会想到上节的 Union-Find 并查集算法，用来高效处理图中连通分量的问题。</p>
<p>Union-Find 算法代码实现：<a href="#Union-Find">#Union-Find</a></p>
<p>Kruskal 算法的一个难点是保证生成树的合法性，因为在构造生成树的过程中，首先需要保证生成的是棵树（不包含环），Union-Find 算法的作用也就在此。</p>
</br>

<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9HcmFwaC8yNjEuJUU0JUJCJUE1JUU1JTlCJUJFJUU1JTg4JUE0JUU2JUEwJTkxLmphdmE=">261.以图判树<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ncmFwaC12YWxpZC10cmVlLw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/18/ca072fae878171be.png#crop=0&crop=0&crop=1&crop=1&id=Fy6uB&originHeight=1238&originWidth=1468&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>若该图包含环，则不能形成一个合法有效的树结构。而会产生环的场景：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/18/e66cbfae5bdca68e.png#crop=0&crop=0&crop=1&crop=1&id=R7n6V&originHeight=774&originWidth=1016&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>不会产生环的场景：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/18/8c26352433834ce8.png#crop=0&crop=0&crop=1&crop=1&id=k4JBv&originHeight=736&originWidth=866&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>可以发现：<strong>对于添加的这条边，如果该边的两个节点在同一连通分量里，那么添加这条边会产生环；反之，如果该边的两个节点不在同一连通分量里，则添加这条边不会产生环。</strong></p>
<p>而判断两个节点是否连通（是否在同一个连通分量中）就是 Union-Find 算法的实现的，所以这道题的解法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validTree</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化 0...n-1 共 n 个节点</span></span><br><span class="line">        <span class="type">UF</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UF</span>(n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有边，将组成边的两个节点进行连接</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若两个节点已经在同一连通分量中，会产生环</span></span><br><span class="line">            <span class="keyword">if</span>(uf.connected(u, v)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这条边不会产生环，可以是树的一部分</span></span><br><span class="line">            uf.union(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 要保证最后只形成了一棵树，即只有一个连通分量</span></span><br><span class="line">        <span class="keyword">return</span> uf.count() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h3 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h3><p>所谓最小生成树，就是图中若干边的集合（后文称这个集合为 <code>mst</code>，最小生成树的英文缩写），要保证这些边：</p>
<ol>
<li>包含图中的所有节点。 </li>
<li>形成的结构是树结构（即不存在环）。 </li>
<li>权重和最小。</li>
</ol>
<p>有之前题目的铺垫，前两条可以很容易地利用 Union-Find 算法做到，关键在于第 3 点，如何保证得到的这棵生成树是权重和最小的。</p>
<p>这里可以使用到贪心思路：</p>
<p>将所有边按照权重从小到大排序，从权重最小的边开始遍历，如果这条边和 <code>mst</code> 中的其它边不会形成环，则这条边是最小生成树的一部分，将它加入 <code>mst</code> 集合；否则，这条边不是最小生成树的一部分，不把它加入 <code>mst</code> 集合。</p>
<p>这样，最后 <code>mst</code> 集合中的边就形成了最小生成树。</p>
</br>


<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9HcmFwaC8xMTM1LiVFNiU5QyU4MCVFNCVCRCU4RSVFNiU4OCU5MCVFNiU5QyVBQyVFOCU4MSU5NCVFOSU4MCU5QSVFNiU4OSU4MCVFNiU5QyU4OSVFNSU5RiU4RSVFNSVCOCU4Mi1rcnVza2FsLmphdmE=">1135.最低成本联通所有城市<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb25uZWN0aW5nLWNpdGllcy13aXRoLW1pbmltdW0tY29zdC8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/18/033fb0b903539914.png#crop=0&crop=0&crop=1&crop=1&id=eUO9O&originHeight=1078&originWidth=1442&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>每座城市相当于图中的节点，连通城市的成本相当于边的权重，连通所有城市的最小成本即是最小生成树的权重之和。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumCost</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] connections)</span> &#123;</span><br><span class="line">        <span class="comment">// 城市编号为 1...n，所以初始化大小为 n + 1</span></span><br><span class="line">        <span class="type">UF</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UF</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 对所有边按照权重从小到大排序</span></span><br><span class="line">        Arrays.sort(connections, (a, b) -&gt; (a[<span class="number">2</span>] - b[<span class="number">2</span>]));</span><br><span class="line">        <span class="comment">// 记录最小生成树的权重之和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mst</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] connection : connections) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> connection[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> connection[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> connection[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(uf.connected(u, v)) &#123;</span><br><span class="line">                <span class="comment">// 若这条边会产生环，则不能加入 mst</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若这条边不会产生环，则属于最小生成树</span></span><br><span class="line">            mst += weight;</span><br><span class="line">            uf.union(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保证所有节点都被连通</span></span><br><span class="line">        <span class="comment">// 按理说 uf.count() == 1 说明所有节点被连通</span></span><br><span class="line">        <span class="comment">// 但因为节点 0 没有被使用，所以 0 会额外占用一个连通分量</span></span><br><span class="line">        <span class="keyword">return</span> uf.count() == <span class="number">2</span> ? mst : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体思路和上一道题非常类似，可以认为树的判定算法加上按权重排序的逻辑就变成了 Kruskal 算法。</p>
</br>


<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9HcmFwaC8xNTg0LiVFOCVCRiU5RSVFNiU4RSVBNSVFNiU4OSU4MCVFNiU5QyU4OSVFNyU4MiVCOSVFNyU5QSU4NCVFNiU5QyU4MCVFNSVCMCU4RiVFOCVCNCVCOSVFNyU5NCVBOC1rcnVza2FsLmphdmE=">1584.连接所有点的最小费用<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW4tY29zdC10by1jb25uZWN0LWFsbC1wb2ludHMv">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/18/6c3978acf2f44ffc.png#crop=0&crop=0&crop=1&crop=1&id=z62rK&originHeight=1450&originWidth=1470&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>每个点就是无向加权图中的节点，边的权重就是曼哈顿距离，连接所有点的最小费用就是最小生成树的权重和。</p>
<p>所以解法思路就是先生成所有的边以及权重，然后对这些边执行 Kruskal 算法即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostConnectPoints</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> points.length;</span><br><span class="line">    <span class="comment">// 生成所有边及权重</span></span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">xi</span> <span class="operator">=</span> points[i][<span class="number">0</span>], yi = points[i][<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">xj</span> <span class="operator">=</span> points[j][<span class="number">0</span>], yj = points[j][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 用坐标点在 points 中的索引表示坐标点</span></span><br><span class="line">            edges.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;</span><br><span class="line">                i, j, Math.abs(xi - xj) + Math.abs(yi - yj)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将边按照权重从小到大排序</span></span><br><span class="line">    Collections.sort(edges, (a, b) -&gt; (a[<span class="number">2</span>] - b[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kruskal 算法</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mst</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">UF</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UF</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> edge[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(uf.connected(u, v)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mst += weight;</span><br><span class="line">        uf.union(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题做了一个小的变通：每个坐标点是一个二元组，按理说应该用五元组表示一条带权重的边，但这样的话不便执行 Union-Find 算法；所以用 <code>points</code> 数组中的索引代表每个坐标点，这样就可以直接复用之前的 Kruskal 算法逻辑了。</p>
<p>Kruskal 算法的复杂度分析：</p>
<p>假设一幅图的节点个数为 <code>V</code>，边的条数为 <code>E</code>，首先需要 <code>O(E)</code> 的空间装所有边，而且 Union-Find 算法也需要 <code>O(V)</code> 的空间，所以 Kruskal 算法总的空间复杂度就是 <code>O(V + E</code>)。</p>
<p>时间复杂度主要耗费在排序，需要 <code>O(ElogE)</code> 的时间，Union-Find 算法所有操作的复杂度都是 <code>O(1)</code>，套一个 for 循环也不过是 <code>O(E)</code>，所以总的时间复杂度为 <code>O(ElogE)</code>。</p>
</br>


<h2 id="Prim-最小生成树算法"><a href="#Prim-最小生成树算法" class="headerlink" title="Prim 最小生成树算法"></a>Prim 最小生成树算法</h2><h3 id="对比-Kruskal-算法"><a href="#对比-Kruskal-算法" class="headerlink" title="对比 Kruskal 算法"></a>对比 Kruskal 算法</h3><p>图论的最小生成树问题，就是从图中找若干边形成一个边的集合 <code>mst</code>，这些边有以下特性：</p>
<ol>
<li>这些边组成的是一棵树（树和图的区别在于不能包含环）。 </li>
<li>这些边形成的树要包含所有节点。 </li>
<li>这些边的权重之和要尽可能小。</li>
</ol>
<p>对于 Kruskal 算法，首先用到了贪心思想，来满足权重之和尽可能小的问题：</p>
<p>先对所有边按照权重从小到大排序，从权重最小的边开始，选择合适的边加入 <code>mst</code> 集合，这样挑出来的边组成的树就是权重和最小的。</p>
<p>其次，Kruskal 算法用到了 Union-Find 并查集算法，来保证挑选出来的这些边组成的一定是一棵「树」，而不会包含环或者形成一片「森林」：</p>
<p>如果一条边的两个节点已经是连通的，则这条边会使树中出现环；如果最后的连通分量总数大于 1，则说明形成的是「森林」而不是一棵「树」。</p>
<p>而对于 Prim 算法，首先也使用贪心思想来让生成树的权重尽可能小，也就是「切分定理」。</p>
<p>其次，Prim 算法使用 BFS 算法思想 和 <code>visited</code> 布尔数组避免成环，来保证选出来的边最终形成的一定是一棵树。</p>
<p>Prim 算法不需要事先对所有边排序，而是利用优先级队列动态实现排序的效果，所以 Prim 算法类似于 Kruskal 的动态过程。</p>
</br>


<h3 id="切分定理"><a href="#切分定理" class="headerlink" title="切分定理"></a>切分定理</h3><p>「切分」就是将一幅图分为两个不重叠且非空的节点集合：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/18/5492fc440959c00f.png#crop=0&crop=0&crop=1&crop=1&id=H3r1r&originHeight=874&originWidth=940&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>红线把图中的节点分成了两个集合，就是一种「切分」，其中被红线切中的的边（标记为蓝色）叫做「横切边」。</p>
<p>「切分定理」：</p>
<p><strong>对于任意一种「切分」，其中权重最小的那条「横切边」一定是构成最小生成树的一条边</strong>。</p>
<p>它的证明也很容易：</p>
<p>如果一幅加权无向图存在最小生成树，假设下图中用绿色标出来的边就是最小生成树：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/18/906a8d1ed6db4003.png#crop=0&crop=0&crop=1&crop=1&id=At2dn&originHeight=794&originWidth=930&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>那么肯定可以找到若干「切分」方式，将这棵最小生成树切成两棵子树。如下面这种切分：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/18/c7c815f135c0f0a8.png#crop=0&crop=0&crop=1&crop=1&id=Fpw4s&originHeight=840&originWidth=1086&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>任选一条蓝色的「横切边」都可以将这两棵子树连接起来，构成一棵生成树。为了让最终这棵生成树的权重和最小，需要选择权重最小的那条「横切边」。这就证明了「切分定理」。</p>
<p>根据切分定理，计算最小生成树的算法思路就可以很容易想到：</p>
<p>既然每一次「切分」一定可以找到最小生成树中的一条边，那每次都把权重最小的「横切边」拿出来加入最小生成树，直到把构成最小生成树的所有边都切出来为止。</p>
</br>


<h3 id="Prim-算法实现"><a href="#Prim-算法实现" class="headerlink" title="Prim 算法实现"></a>Prim 算法实现</h3><p>按照「切分」的定义，只要把图中的节点切成两个不重叠且非空的节点集合即可算作一个合法的「切分」，那么只切出来一个节点也算是一个合法的「切分」，而且「横切边」就是这个节点的边。</p>
<p>假设从 A 点开始切分：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/18/6fc27f6545f30cef.png#crop=0&crop=0&crop=1&crop=1&id=UGkl3&originHeight=854&originWidth=1020&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>按照切分定理，「横切边」<code>AB</code>, <code>AF</code> 中权重最小的边一定是最小生成树中的一条边：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/18/e5f75dfe19510824.png#crop=0&crop=0&crop=1&crop=1&id=oUnxF&originHeight=824&originWidth=918&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>现在已经找到最小生成树的第一条边（边 <code>AB</code>），按照 Prim 算法的逻辑，接下来可以围绕 <code>A</code> 和 <code>B</code> 这两个节点做切分：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/18/06adffe6276d276f.png#crop=0&crop=0&crop=1&crop=1&id=HQL29&originHeight=876&originWidth=940&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>然后又可以从这个切分产生的横切边（图中蓝色的边）中找出权重最小的一条边，也就又找到了最小生成树中的第二条边 <code>BC</code>：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/18/8615a8301d802cbf.png#crop=0&crop=0&crop=1&crop=1&id=bT0yi&originHeight=800&originWidth=898&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>接下来类似，再围绕 <code>A</code>, <code>B</code>, <code>C</code> 这三个点做切分，产生的横切边中权重最小的边是 <code>BD</code>，那么 <code>BD</code> 就是最小生成树的第三条边：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/18/7c109ee58a621b13.png#crop=0&crop=0&crop=1&crop=1&id=akw2q&originHeight=818&originWidth=938&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>接下来再围绕 <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> 这四个点做切分 ……</p>
<p>Prim 算法的逻辑就是这样，每次切分都能找到最小生成树的一条边，然后又可以进行新一轮切分，直到找到最小生成树的所有边为止。</p>
<p>这样设计算法有一个好处，就是比较容易确定每次新的「切分」所产生的「横切边」。</p>
<p>回顾刚才的图，当知道了节点 <code>A</code>, <code>B</code> 的所有「横切边」（不妨表示为 <code>cut(&#123;A, B&#125;)</code>），也就是图中蓝色的边：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/18/06adffe6276d276f.png#crop=0&crop=0&crop=1&crop=1&id=HD54V&originHeight=876&originWidth=940&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>可以根据它快速计算出 <code>cut(&#123;A, B, C&#125;)</code>，也就是节点 <code>A</code>, <code>B</code>, <code>C</code> 的所有「横切边」:</p>
<p><code>cut(&#123;A, B, C&#125;) = cut(&#123;A, B&#125;) + cut(&#123;C&#125;)</code></p>
<p>而 <code>cut(&#123;C&#125;)</code> 就是节点 <code>C</code> 的所有邻边：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/18/a161da6f239d332e.png#crop=0&crop=0&crop=1&crop=1&id=xS0SO&originHeight=676&originWidth=1690&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>因此，在进行切分的过程中只需要不断把新节点的邻边加入横切边集合，就可以得到新的切分的所有横切边。</p>
<p>注意 <code>cut(&#123;A, B&#125;)</code> 的横切边和 <code>cut(&#123;C&#125;)</code> 的横切边中 <code>BC</code> 边重复了。可以用一个布尔数组 <code>inMST</code> 辅助防止重复计算横切边。</p>
<p>而求横切边的目的是找权重最小的横切边，可以用一个优先级队列存储这些横切边来动态计算权重最小的横切边。</p>
<p>明白了上诉原理就可以用代码实现 Prim 算法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Prim</span> &#123;</span><br><span class="line">    <span class="comment">// 核心数据结构，存储「横切边」的优先级队列</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;<span class="type">int</span>[]&gt; pq;</span><br><span class="line">    <span class="comment">// 类似 visited 数组的作用，记录已经成为最小生成树的一部分的节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] inMST;</span><br><span class="line">    <span class="comment">// 记录最小生成树的权重和</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">weightSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// graph 是用邻接表表示的一幅图，</span></span><br><span class="line">    <span class="comment">// graph[s] 记录节点 s 所有相邻的边，</span></span><br><span class="line">    <span class="comment">// 三元组 int[]&#123;from, to, weight&#125; 表示一条边</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;<span class="type">int</span>[]&gt;[] graph;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Prim</span><span class="params">(List&lt;<span class="type">int</span>[]&gt;[] graph)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.graph = graph;</span><br><span class="line">        <span class="built_in">this</span>.pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a[<span class="number">2</span>] - b[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 图中有 n 个节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> graph.length;</span><br><span class="line">        <span class="built_in">this</span>.inMST = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不妨从节点 0 开始切分</span></span><br><span class="line">        inMST[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        cut(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 不断进行切分，向最小生成树中添加边</span></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span>[] edge = pq.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> edge[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (inMST[to]) &#123;</span><br><span class="line">                <span class="comment">// 节点 to 已经在最小生成树中，跳过</span></span><br><span class="line">                <span class="comment">// 否则这条边会产生环</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将边 edge 加入最小生成树</span></span><br><span class="line">            weightSum += weight;</span><br><span class="line">            inMST[to] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 节点 to 加入后，进行新一轮切分，会产生更多横切边</span></span><br><span class="line">            cut(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 s 的横切边加入优先队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cut</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历 s 的邻边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : graph[s]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (inMST[to]) &#123;</span><br><span class="line">                <span class="comment">// 相邻接点 to 已经在最小生成树中，跳过</span></span><br><span class="line">                <span class="comment">// 否则这条边会产生环</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 加入横切边队列</span></span><br><span class="line">            pq.offer(edge);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最小生成树的权重和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">weightSum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weightSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断最小生成树是否包含图中的所有节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">allConnected</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inMST.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!inMST[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kruskal 算法是在一开始的时候就把所有的边排序，然后从权重最小的边开始挑选属于最小生成树的边，组建最小生成树。</p>
<p>Prim 算法是从一个起点的切分（一组横切边）开始执行类似 BFS 算法的逻辑，借助切分定理和优先级队列动态排序的特性，从这个起点「生长」出一棵最小生成树。</p>
<p>Prim 算法的时间复杂度主要在优先级队列 <code>pq</code> 的操作上，由于 <code>pq</code> 里面装的是图中的「边」，假设一幅图边的条数为 <code>E</code>，那么最多操作 <code>O(E)</code> 次 <code>pq</code>。每次操作优先级队列的时间复杂度取决于队列中的元素个数，取最坏情况就是 <code>O(logE)</code>。</p>
<p>所以这种 Prim 算法实现的总时间复杂度是 <code>O(ElogE)</code>。Kruskal 算法，它的时间复杂度主要是给所有边按照权重排序，也是 <code>O(ElogE)</code>。</p>
</br>


<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9HcmFwaC8xMTM1LiVFNiU5QyU4MCVFNCVCRCU4RSVFNiU4OCU5MCVFNiU5QyVBQyVFOCU4MSU5NCVFOSU4MCU5QSVFNiU4OSU4MCVFNiU5QyU4OSVFNSU5RiU4RSVFNSVCOCU4Mi1wcmltLmphdmE=">1135.最低成本联通所有城市<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb25uZWN0aW5nLWNpdGllcy13aXRoLW1pbmltdW0tY29zdC8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>每座城市相当于图中的节点，连通城市的成本相当于边的权重，连通所有城市的最小成本即是最小生成树的权重之和。</p>
<p>先把题目输入的 <code>connections</code> 转化成邻接表形式，然后输入给之前实现的 Prim 算法类即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumCost</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] connections)</span> &#123;</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt;[] graph = buildGraph(n, connections);</span><br><span class="line">    <span class="type">Prim</span> <span class="variable">prim</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Prim</span>(graph);</span><br><span class="line">    <span class="keyword">if</span>(!prim.allConnected()) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prim.weightSum();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;<span class="type">int</span>[]&gt;[] buildGraph(<span class="type">int</span> n, <span class="type">int</span>[][] connections) &#123;</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt;[] graph = <span class="keyword">new</span> <span class="title class_">LinkedList</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        graph[i] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>[] conn : connections) &#123;</span><br><span class="line">        <span class="comment">// 题目给的节点编号从 1 开始</span></span><br><span class="line">        <span class="comment">// 但实现的 Prim 算法需要从 0 开始编号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> conn[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> conn[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> conn[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        graph[u].add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;u, v, weight&#125;);</span><br><span class="line">        graph[v].add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;v, u, weight&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于 <code>buildGraph</code> 函数需要注意两点：</p>
<ol>
<li>题目给的节点编号是从 1 开始的，所以做一下索引偏移，转化成从 0 开始以便 <code>Prim</code> 类使用； </li>
<li>如何用邻接表表示无向加权图，「无向图」其实就可以理解为「双向图」。</li>
</ol>
<p>这样转化出来的 <code>graph</code> 形式就和之前的 <code>Prim</code> 算法类对应了，可以直接使用 <code>Prim</code> 算法计算最小生成树。</p>
</br>


<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9HcmFwaC8xNTg0LiVFOCVCRiU5RSVFNiU4RSVBNSVFNiU4OSU4MCVFNiU5QyU4OSVFNyU4MiVCOSVFNyU5QSU4NCVFNiU5QyU4MCVFNSVCMCU4RiVFOCVCNCVCOSVFNyU5NCVBOC1wcmltLmphdmE=">1584.连接所有点的最小费用<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW4tY29zdC10by1jb25uZWN0LWFsbC1wb2ludHMv">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>每个点就是无向加权图中的节点，边的权重就是曼哈顿距离，连接所有点的最小费用就是最小生成树的权重和。</p>
<p>所以只需要把 <code>points</code> 数组转化成邻接表的形式，即可复用之前实现的 <code>Prim</code> 算法类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostConnectPoints</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> points.length;</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt;[] graph = buildGraph(n, points);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Prim</span>(graph).weightSum();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;<span class="type">int</span>[]&gt;[] buildGraph(<span class="type">int</span> n, <span class="type">int</span>[][] points) &#123;</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt;[] graph = <span class="keyword">new</span> <span class="title class_">LinkedList</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        graph[i] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">xi</span> <span class="operator">=</span> points[i][<span class="number">0</span>], yi = points[i][<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">xj</span> <span class="operator">=</span> points[j][<span class="number">0</span>], yj = points[j][<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> Math.abs(xi - xj) + Math.abs(yi - yj);</span><br><span class="line"></span><br><span class="line">            graph[i].add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, j, weight&#125;);</span><br><span class="line">            graph[j].add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;j, i, weight&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 <code>points</code> 数组中的索引代表每个坐标点，这样就可以直接复用之前的 <code>Prim</code> 算法逻辑了。</p>
</br>

<h2 id="BFS-算法"><a href="#BFS-算法" class="headerlink" title="BFS 算法"></a>BFS 算法</h2><p>BFS 的核心思想就是把一些问题抽象成图，从一个点开始，向四周开始扩散。一般来说，写 BFS 算法都是用「队列」这种数据结构，每次将一个节点周围的所有节点加入队列。</p>
<p>BFS 相对 DFS 的最主要的区别是：BFS 找到的路径一定是最短的，但代价就是空间复杂度可能比 DFS 大很多。</p>
<p>BFS 出现的常见场景问题的本质就是在一幅「图」中找到从起点 <code>start</code> 到终点 <code>target</code> 的最近距离。</p>
<p>代码框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算从起点 start 到终点 target 的最近距离</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BFS</span><span class="params">(Node start, Node target)</span> &#123;</span><br><span class="line">    Queue&lt;Node&gt; q; <span class="comment">// 核心数据结构</span></span><br><span class="line">    Set&lt;Node&gt; visited; <span class="comment">// 避免走回头路</span></span><br><span class="line">    </span><br><span class="line">    q.offer(start); <span class="comment">// 将起点加入队列</span></span><br><span class="line">    visited.add(start);</span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录扩散的步数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="comment">/* 将当前队列中的所有节点向四周扩散 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="comment">/* 判断是否到达终点 */</span></span><br><span class="line">            <span class="keyword">if</span> (cur is target)</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">/* 将 cur 的相邻节点加入队列 */</span></span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.adj()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x not in visited) &#123;</span><br><span class="line">                    q.offer(x);</span><br><span class="line">                    visited.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 更新步数 */</span></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>cur.adj()</code> 泛指 <code>cur</code> 相邻的节点，如二维数组中，<code>cur</code> 上下左右四面的位置就是相邻节点；<code>visited</code> 的主要作用是防止走回头路，大部分时候都是必须的，但是像一般的二叉树结构，没有子节点到父节点的指针，不会走回头路就不需要 <code>visited</code>。</p>
</br>


<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzExMS4lRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTElRTclOUElODQlRTYlOUMlODAlRTUlQjAlOEYlRTYlQjclQjElRTUlQkElQTYuamF2YQ==">111.二叉树的最小深度<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLWRlcHRoLW9mLWJpbmFyeS10cmVlLw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/19/34f09e0720835bbf.png#crop=0&crop=0&crop=1&crop=1&id=q6ZVV&originHeight=1234&originWidth=1448&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>首先需要明确起点 <code>start</code> 和终点 <code>target</code> 是什么，怎么判断到达了终点。</p>
<p>显然起点就是 <code>root</code> 根节点，终点就是最靠近根节点的那个「叶子节点」，叶子节点就是两个子节点都是 <code>null</code> 的节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur.left == <span class="literal">null</span> &amp;&amp; cur.right == <span class="literal">null</span>) </span><br><span class="line">    <span class="comment">// 到达叶子节点</span></span><br></pre></td></tr></table></figure>

<p>按照代码框架修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="comment">// root 本身就是一层，depth 初始化为 1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="comment">/* 遍历当前层的节点 */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="comment">/* 判断是否到达叶子结点 */</span></span><br><span class="line">            <span class="keyword">if</span>(cur.left == <span class="literal">null</span> &amp;&amp; cur.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> depth;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 将下一层节点加入队列 */</span></span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 增加步数</span></span><br><span class="line">        depth++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里注意这个 while 循环和 for 循环的配合，while 循环控制一层一层往下走，for 循环利用 <code>sz</code> 变量控制从左到右遍历每一层二叉树节点：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/19/6d8cf26e89926337.png#crop=0&crop=0&crop=1&crop=1&id=bdM7U&originHeight=666&originWidth=1678&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>这个形式在普通 BFS 问题中都很常见，但是在 Dijkstra 算法模板框架中修改了这种代码模式。</p>
<p>其他复杂问题都是这个框架的变形，用 BFS 找最短距离的好处就是 <code>depth</code> 每增加一次，队列中的所有节点都向前迈一步，这保证了第一次到达终点的时候，走的步数是最少的。而 DFS 要找到最短路径需要把所有节点都走完才能对比出最短路径。</p>
<p>一般来说在找最短路径的时候使用 BFS，其他时候还是 DFS 使用得多。</p>
</br>


<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9HcmFwaC83NTIuJUU2JTg5JTkzJUU1JUJDJTgwJUU4JUJEJUFDJUU3JTlCJTk4JUU5JTk0JTgxLmphdmE=">752.打开转盘锁<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9vcGVuLXRoZS1sb2NrLw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/19/0e447d0e49a9fc87.png#crop=0&crop=0&crop=1&crop=1&id=JOemb&originHeight=970&originWidth=1446&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>这题难点在于有 <code>deadends</code> 约束，不能直奔 <code>target</code>。</p>
<p>但若只转一次锁，一共有 4 个位置，每个位置都可以向上或向下转，也就是有 8 种可能。如从 <code>&quot;0000&quot;</code> 开始转一次，可能的结果有 <code>&quot;1000&quot;, &quot;9000&quot;, &quot;0100&quot;, &quot;0900&quot; ...</code> 共 8 种密码。再以这 8 种密码为基础再转一次，穷举出所有可能。</p>
<p>这就可以抽象成一幅图，每个节点有 8 个相邻的节点，让求最短距离，就是典型的 BFS 算法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向上转</span></span><br><span class="line">String <span class="title function_">plusOne</span><span class="params">(String s, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">    <span class="keyword">if</span>(ch[j] == <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        ch[j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ch[j] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向下转</span></span><br><span class="line">String <span class="title function_">minusOne</span><span class="params">(String s, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">    <span class="keyword">if</span>(ch[j] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">        ch[j] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ch[j] -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS 框架，打印出所有可能的密码</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">BFS</span><span class="params">(String target)</span> &#123;</span><br><span class="line">    Queue&lt;String&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.offer(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将当前队列中的所有节点向周围扩散</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="comment">// 判断是否到达终点</span></span><br><span class="line">            System.out.println(cur);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将一个节点的相邻节点加入队列</span></span><br><span class="line">            <span class="comment">// 0000 四位</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">up</span> <span class="operator">=</span> plusOne(cur, j);</span><br><span class="line">                <span class="type">String</span> <span class="variable">down</span> <span class="operator">=</span> minusOne(cur, j);</span><br><span class="line">                q.offer(up);</span><br><span class="line">                q.offer(down);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 增加步数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段 BFS 代码已经能够穷举所有可能的密码组合了，但有如下问题需要解决：</p>
<ol>
<li>会走回头路。如从 <code>&quot;0000&quot;</code> 到 <code>&quot;1000&quot;</code>，但是等从队列拿出 <code>&quot;1000&quot;</code> 时，还可以到 <code>&quot;0000</code>“，这样会产生死循环。 </li>
<li>没有终止条件，需要返回找到 <code>target</code> 时的步数。 </li>
<li>没有对 <code>deadends</code> 的处理，这些 <code>deadends</code> 是不能出现的，遇到这些密码的时候需要跳过。</li>
</ol>
<p>在上面代码中修改即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">openLock</span><span class="params">(String[] deadends, String target)</span> &#123;</span><br><span class="line">    <span class="comment">// 记录需要跳过的 deadens</span></span><br><span class="line">    Set&lt;String&gt; deads = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String s : deadends) &#123;</span><br><span class="line">        deads.add(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录已经穷举过的密码，防止走回头路</span></span><br><span class="line">    Set&lt;String&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    Queue&lt;String&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从起点开始 BFS</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    q.offer(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">    visited.add(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="comment">// 将当前队列中的所有节点向周围扩散</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断是否到达终点</span></span><br><span class="line">            <span class="keyword">if</span>(deads.contains(cur)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur.equals(target)) &#123;</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将一个节点的未遍历相邻节点加入队列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">up</span> <span class="operator">=</span> plusOne(cur, j);</span><br><span class="line">                <span class="keyword">if</span>(!visited.contains(up)) &#123;</span><br><span class="line">                    q.offer(up);</span><br><span class="line">                    visited.add(up);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">String</span> <span class="variable">down</span> <span class="operator">=</span> minusOne(cur, j);</span><br><span class="line">                <span class="keyword">if</span>(!visited.contains(down)) &#123;</span><br><span class="line">                    q.offer(down);</span><br><span class="line">                    visited.add(down);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 增加步数</span></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 无法达到</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以不需要 <code>dead</code> 这个哈希集合，直接将这些元素初始化到 <code>visited</code> 集合中效果相同。</p>
</br>


<h2 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h2><h3 id="图的抽象"><a href="#图的抽象" class="headerlink" title="图的抽象"></a>图的抽象</h3><p>「图」这种数据结构的基本实现，图中的节点一般就抽象成一个数字（索引），图的具体实现一般是「邻接矩阵」或者「邻接表」。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/19/76610c47f983f840.png#crop=0&crop=0&crop=1&crop=1&id=Bdf8k&originHeight=301&originWidth=423&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>如上图用邻接表和邻接矩阵的存储方式如下：</p>
<p><img src="https://s1.ax1x.com/2022/07/16/j4ji0x.png#crop=0&crop=0&crop=1&crop=1&id=cKgo3&originHeight=718&originWidth=1194&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>一幅图可以用如下 Java 代码表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// graph[s] 存储节点 s 指向的节点（出度）</span></span><br><span class="line">List&lt;Integer&gt;[] graph;</span><br></pre></td></tr></table></figure>

<p>如果要把一个问题抽象成「图」的问题，那么首先要实现一个 API <code>adj</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入节点 s 返回 s 的相邻节点</span></span><br><span class="line">List&lt;Integer&gt; <span class="title function_">adj</span><span class="params">(<span class="type">int</span> s)</span>;</span><br></pre></td></tr></table></figure>

<p>类似多叉树节点中的 <code>children</code> 字段记录当前节点的所有子节点，<code>adj(s)</code> 就是计算一个节点 <code>s</code> 的相邻节点。</p>
<p>比如用邻接表表示「图」的方式，<code>adj</code> 函数就可以这样表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt;[] graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入节点 s，返回 s 的相邻节点</span></span><br><span class="line">List&lt;Integer&gt; <span class="title function_">adj</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> graph[s];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于「加权图」，需要知道两个节点之间的边权重是多少，所以还可以抽象出一个 <code>weight</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回节点 from 到节点 to 之间的边的权重</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">weight</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span>;</span><br></pre></td></tr></table></figure>

<p>这个 <code>weight</code> 方法可以根据实际情况而定，因为不同的算法题，题目给的「权重」含义可能不一样，存储权重的方式也不一样。</p>
<p>有了上述基础知识，就可以搞定 Dijkstra 算法了。</p>
</br>


<h3 id="二叉树层级遍历和-BFS-算法"><a href="#二叉树层级遍历和-BFS-算法" class="headerlink" title="二叉树层级遍历和 BFS 算法"></a>二叉树层级遍历和 BFS 算法</h3><p>二叉树的层级遍历框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入一棵二叉树的根节点，层序遍历这棵二叉树</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">levelTraverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 从上到下遍历二叉树的每一层</span></span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="comment">// 从左到右遍历每一层的每个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            printf(<span class="string">&quot;节点 %s 在第 %s 层&quot;</span>, cur, depth);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将下一层节点放入队列</span></span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                q.offer(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                q.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>while 循环和 for 循环的配合正是这个遍历框架设计的巧妙之处：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/19/6d8cf26e89926337.png#crop=0&crop=0&crop=1&crop=1&id=tiGdy&originHeight=666&originWidth=1678&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><strong>while 循环控制一层一层往下走，for 循环利用 <code>sz</code>变量控制从左到右遍历每一层二叉树节点。</strong></p>
<p>注意代码框架中的 <code>depth</code> 变量记录了当前遍历到的层数。每当遍历到一个节点 <code>cur</code>，就知道这个节点属于第几层。</p>
<p>二叉树的遍历框架，可以扩展出多叉树的层序遍历框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入一棵多叉树的根节点，层序遍历这棵多叉树</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">levelTraverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 从上到下遍历多叉树的每一层</span></span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="comment">// 从左到右遍历每一层的每个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            printf(<span class="string">&quot;节点 %s 在第 %s 层&quot;</span>, cur, depth);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将下一层节点放入队列</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode child : cur.children) &#123;</span><br><span class="line">                q.offer(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于多叉树的遍历框架，可以扩展出 BFS（广度优先搜索）的算法框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入起点，进行 BFS 搜索</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BFS</span><span class="params">(Node start)</span> &#123;</span><br><span class="line">    Queue&lt;Node&gt; q; <span class="comment">// 核心数据结构</span></span><br><span class="line">    Set&lt;Node&gt; visited; <span class="comment">// 避免走回头路</span></span><br><span class="line">    </span><br><span class="line">    q.offer(start); <span class="comment">// 将起点加入队列</span></span><br><span class="line">    visited.add(start);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录搜索的步数</span></span><br><span class="line">    <span class="keyword">while</span> (q not empty) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="comment">/* 将当前队列中的所有节点向四周扩散一步 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            printf(<span class="string">&quot;从 %s 到 %s 的最短距离是 %s&quot;</span>, start, cur, step);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 将 cur 的相邻节点加入队列 */</span></span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.adj()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x not in visited) &#123;</span><br><span class="line">                    q.offer(x);</span><br><span class="line">                    visited.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，BFS 算法框架也是 while 循环嵌套 for 循环的形式，也用了一个 <code>step</code> 变量记录 for 循环执行的次数，多用了一个 <code>visited</code> 集合记录走过的节点。</p>
<p>对于「无权图」，其每条「边」没有权重，或者说每条「边」的权重都是 1，从起点 <code>start</code> 到任意一个节点之间的路径权重就是它们之间「边」的条数，就是 <code>step</code> 变量记录的值。</p>
<p>BFS 算法利用 for 循环一层一层向外扩散的逻辑和 <code>visited</code> 集合防止走回头路的逻辑，当每次从队列中拿出节点 <code>cur</code> 的时候，从 <code>start</code> 到 <code>cur</code> 的最短权重就是 <code>step</code> 记录的步数。</p>
<p>而对于「加权图」，这个权重可以是任意正数（Dijkstra 算法要求不能存在负权重边），比如下图的例子：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/19/ca619432420f26ee.png#crop=0&crop=0&crop=1&crop=1&id=NVA4e&originHeight=468&originWidth=668&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>如果沿用 BFS 算法中的 <code>step</code> 变量记录「步数」，显然红色路径一步就可以走到终点，但是这一步的权重很大；正确的最小权重路径应该是绿色的路径，虽然需要走很多步，但是路径权重依然很小。</p>
<p>Dijkstra 和 BFS 算法差不多，对之前的 BFS 框架进行改造：</p>
<p><strong>去掉 while 循环里面的 for 循环。</strong></p>
<p>for 循环是为了让二叉树一层一层往下遍历，让 BFS 算法一步一步向外扩散，因为这个层数 <code>depth</code>，或步数 <code>step</code> 在之前的场景中有用。</p>
<p>但现在想解决「加权图」中的最短路径问题，「步数」已经没有参考意义了，「路径的权重之和」才有意义，所以这个 for 循环可以被去掉：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入一棵二叉树的根节点，遍历这棵二叉树所有节点</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">levelTraverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历二叉树的每一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">        printf(<span class="string">&quot;我不知道节点 %s 在第几层&quot;</span>, cur);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将子节点放入队列</span></span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            q.offer(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            q.offer(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想同时维护 <code>depth</code> 变量，让每个节点 <code>cur</code> 知道自己在第几层，可以新建一个 <code>State</code> 类，记录每个节点所在的层数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="comment">// 记录 node 节点的深度</span></span><br><span class="line">    <span class="type">int</span> depth;</span><br><span class="line">    TreeNode node;</span><br><span class="line"></span><br><span class="line">    State(TreeNode node, <span class="type">int</span> depth) &#123;</span><br><span class="line">        <span class="built_in">this</span>.node = node;</span><br><span class="line">        <span class="built_in">this</span>.depth = depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入一棵二叉树的根节点，遍历这棵二叉树所有节点</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">levelTraverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;State&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.offer(<span class="keyword">new</span> <span class="title class_">State</span>(root, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历二叉树的每一个节点</span></span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">State</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">curNode</span> <span class="operator">=</span> cur.node;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curDepth</span> <span class="operator">=</span> cur.depth;</span><br><span class="line">        printf(<span class="string">&quot;节点 %s 在第 %s 层&quot;</span>, curNode, curDepth);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将子节点放入队列</span></span><br><span class="line">        <span class="keyword">if</span>(curNode.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            q.offer(<span class="keyword">new</span> <span class="title class_">State</span>(curNode.left, curDepth + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curNode.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            q.offer(<span class="keyword">new</span> <span class="title class_">State</span>(curNode.right, curDepth + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，就可以不使用 for 循环也确切地知道每个二叉树节点的深度了。</p>
</br>

<h3 id="Dijkstra-算法框架"><a href="#Dijkstra-算法框架" class="headerlink" title="Dijkstra 算法框架"></a>Dijkstra 算法框架</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入一幅图和一个起点 start，计算 start 到其他节点的最短距离</span></span><br><span class="line"><span class="type">int</span>[] dijkstra(<span class="type">int</span> start, List&lt;Integer&gt;[] graph);</span><br></pre></td></tr></table></figure>

<p>输入一幅图 <code>graph</code> 和一个起点 <code>start</code>，返回一个记录最短路径权重的数组。</p>
<p>标准的 Dijkstra 算法会把从起点 <code>start</code> 到所有其他节点的最短路径都算出来，如输入起点 <code>start = 3</code>，函数返回一个 <code>int[]</code> 数组，假设赋值给 <code>distTo</code> 变量，那么从起点 <code>3</code> 到节点 <code>6</code> 的最短路径权重的值就是 <code>distTo[6]</code>。</p>
<p>类似二叉树的层序遍历，这里也需要用 <code>State</code> 类记录一些额外信息，也就是使用 <code>distFromStart</code> 变量记录从起点 <code>start</code> 到当前这个节点的距离：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="comment">// 图节点的 id</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="comment">// 从 start 节点到当前节点的距离</span></span><br><span class="line">    <span class="type">int</span> distFromStart;</span><br><span class="line"></span><br><span class="line">    State(<span class="type">int</span> id, <span class="type">int</span> distFromStart) &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.distFromStart = distFromStart;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>普通 BFS 算法中，根据 BFS 的逻辑和无权图的特点，第一次遇到某个节点所走的步数就是最短距离，所以用一个 <code>visited</code> 数组防止走回头路，每个节点只会经过一次。</p>
<p>加权图中的 Dijkstra 算法和无权图中的普通 BFS 算法不同，在 Dijkstra 算法中，第一次经过某个节点时的路径权重不一定就是最小的，所以对于同一个节点可能会经过多次，而且每次的 <code>distFromStart</code> 可能都不一样，比如下图：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/19/817c4fb6b00ff29e.png#crop=0&crop=0&crop=1&crop=1&id=vC3ki&originHeight=450&originWidth=1148&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>会经过节点 <code>5</code> 三次，每次的 <code>distFromStart</code> 值都不一样。那么取 <code>distFromStart</code> 最小的那次就是从起点 <code>start</code> 到节点 <code>5</code> 的最短路径权重。</p>
<p>这样就可以写出 Dijkstra 算法框架了，Dijkstra 可以理解成一个带 dp table（或备忘录）的 BFS 算法，伪码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回节点 from 到节点 to 之间的边的权重</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">weight</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入节点 s 返回 s 的相邻节点</span></span><br><span class="line">List&lt;Integer&gt; <span class="title function_">adj</span><span class="params">(<span class="type">int</span> s)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入一幅图和一个起点 start，计算 start 到其他节点的最短距离</span></span><br><span class="line"><span class="type">int</span>[] dijkstra(<span class="type">int</span> start, List&lt;Integer&gt;[] graph) &#123;</span><br><span class="line">    <span class="comment">// 图中节点的个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">V</span> <span class="operator">=</span> graph.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录最短路径的权重，你可以理解为 dp table</span></span><br><span class="line">    <span class="comment">// 定义：distTo[i] 的值就是节点 start 到达节点 i 的最短路径权重</span></span><br><span class="line">    <span class="type">int</span>[] distTo = <span class="keyword">new</span> <span class="title class_">int</span>[V];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求最小值，所以 dp table 初始化为正无穷</span></span><br><span class="line">    Arrays.fill(distTo, Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// base case，start 到 start 的最短距离就是 0</span></span><br><span class="line">    distTo[start] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优先级队列，distFromStart 较小的排在前面</span></span><br><span class="line">    Queue&lt;State&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a.distFromStart - b.distFromStart);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从起点 start 开始进行 BFS</span></span><br><span class="line">    pq.offer(<span class="keyword">new</span> <span class="title class_">State</span>(start, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!pq.isEmpty()) &#123;</span><br><span class="line">        <span class="type">State</span> <span class="variable">curState</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">        <span class="type">int</span> <span class="variable">curDistFromStart</span> <span class="operator">=</span> curState.distFromStart;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(curDistFromStart &gt; distTo[curNodeID]) &#123;</span><br><span class="line">            <span class="comment">// 已经有一条更短的路径到达 curNode 节点了</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 curNode 的相邻节点装入队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> nextNodeID : adj(curNodeID)) &#123;</span><br><span class="line">            <span class="comment">// 判断从 curNode 到 nextNode 的距离是否会更短</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">distToNextNode</span> <span class="operator">=</span> distTo[curNodeID] + weight(curNodeID, nextNodeID);</span><br><span class="line">            <span class="keyword">if</span>(distTo[nextNodeID] &gt; distToNextNode) &#123;</span><br><span class="line">                <span class="comment">// 更新 dp table</span></span><br><span class="line">                distTo[nextNodeID] = distToNextNode;</span><br><span class="line">                <span class="comment">// 将这个节点以及距离放入队列</span></span><br><span class="line">                pq.offer(<span class="keyword">new</span> <span class="title class_">State</span>(nextNodeID, distToNextNode));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> distTo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比普通的 BFS 算法：</p>
<ol>
<li>没有 <code>visited</code> 集合记录已访问的节点，所以一个节点会被访问多次，会被多次加入队列，那会不会导致队列永远不为空，造成死循环？ </li>
<li>为什么用优先级队列 <code>PriorityQueue</code> 而不是 <code>LinkedList</code> 实现的普通队列？为什么要按照 <code>distFromStart</code> 的值来排序？ </li>
<li>如果我只想计算起点 <code>start</code> 到某一个终点 <code>end</code> 的最短路径，是否可以修改算法，提升一些效率？</li>
</ol>
<p>首先，这个算法不用 <code>visited</code> 集合也不会死循环。循环结束的条件是队列为空，那么就要注意看什么时候往队列里放元素（调用 <code>offer</code> 方法），再注意看什么时候从队列往外拿元素（调用 <code>poll</code> 方法）。</p>
<p>while 循环每执行一次，都会往外拿一个元素，但想往队列里放元素就有很多限制，必须满足下面这个条件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断从 curNode 到 nextNode 的距离是否会更短</span></span><br><span class="line"><span class="keyword">if</span> (distTo[nextNodeID] &gt; distToNextNode) &#123;</span><br><span class="line">    <span class="comment">// 更新 dp table</span></span><br><span class="line">    distTo[nextNodeID] = distToNextNode;</span><br><span class="line">    pq.offer(<span class="keyword">new</span> <span class="title class_">State</span>(nextNodeID, distToNextNode));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个算法逻辑就是在不断的最小化 <code>distTo</code> 数组中的元素，因此 <code>distTo</code> 数组可以理解成熟悉的 <code>dp table</code>。如果能让到达 <code>nextNodeID</code> 的距离更短，就更新 <code>distTo[nextNodeID]</code> 的值，让其入队，否则不让入队。</p>
<p>因为两个节点之间的最短距离（路径权重）肯定是一个确定的值，不可能无限减小下去，所以队列一定会空。队列空了之后，<code>distTo</code> 数组中记录的就是从 <code>start</code> 到其他节点的最短距离。</p>
<p>对于第 2 点，如果要用普通队列，可以直接把 <code>PriorityQueue</code> 改成 <code>LinkedList</code>，也能得到正确答案但是效率会低很多。</p>
<p>Dijkstra 算法使用优先级队列，主要是为了效率上的优化，类似一种贪心算法的思路，计算从起点 <code>start</code> 到终点 <code>end</code> 的最短路径权重：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/19/552858884eac2cba.png#crop=0&crop=0&crop=1&crop=1&id=EZwso&originHeight=880&originWidth=1494&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>假设当前只遍历了图中的这几个节点，那么你下一步准备遍历的节点显然是橙色路径的可能性更大，所以我们希望节点 <code>2</code> 排在队列靠前的位置，优先被拿出来向后遍历。</p>
<p>所以我们使用 <code>PriorityQueue</code> 作为队列，让 <code>distFromStart</code> 的值较小的节点排在前面，这就类似贪心算法的贪心思路，可以很大程度上优化算法的效率。</p>
<p>对于第 3 点，如果只关心起点 <code>start</code> 到某一个终点 <code>end</code> 的最短路径，只需要稍微修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入起点 start 和终点 end，计算起点到终点的最短距离</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dijkstra</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, List&lt;Integer&gt;[] graph)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">        <span class="type">State</span> <span class="variable">curState</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">        <span class="type">int</span> <span class="variable">curNodeID</span> <span class="operator">=</span> curState.id;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curDistFromStart</span> <span class="operator">=</span> curState.distFromStart;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这里加一个判断，其他代码不用改</span></span><br><span class="line">        <span class="keyword">if</span> (curNodeID == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> curDistFromStart;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curDistFromStart &gt; distTo[curNodeID]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果运行到这里，说明从 start 无法走到 end</span></span><br><span class="line">    <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为优先级队列自动排序的性质，每次从队列里面拿出来的都是 <code>distFromStart</code> 值最小的，所以当第一次从队列中拿出终点 <code>end</code> 时，此时的 <code>distFromStart</code> 对应的值就是从 <code>start</code> 到 <code>end</code> 的最短距离。</p>
<p>这个算法较之前的实现提前 <code>return</code> 了，所以效率有一定的提高。</p>
</br>


<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9HcmFwaC83NDMuJUU3JUJEJTkxJUU3JUJCJTlDJUU1JUJCJUI2JUU4JUJGJTlGJUU2JTk3JUI2JUU5JTk3JUI0LmphdmE=">743.网络延迟时间<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9uZXR3b3JrLWRlbGF5LXRpbWUv">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/19/38ef0b9e0e99c0e7.png#crop=0&crop=0&crop=1&crop=1&id=mG2OL&originHeight=1150&originWidth=1444&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>求所有节点都收到信号的时间，把传递时间看做距离，实际上就是问「从节点 <code>k</code> 到其他所有节点的最短路径中，最长的那条最短路径距离是多少」，也就是计算从节点 <code>k</code> 出发到其他所有节点的最短路径，就是标准的 Dijkstra 算法。</p>
<p>根据之前 Dijkstra 算法的框架可以写出下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">networkDelayTime</span><span class="params">(<span class="type">int</span>[][] times, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">// 节点编号是从 1 开始的，所以要一个大小为 n + 1 的邻接表</span></span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt;[] graph = <span class="keyword">new</span> <span class="title class_">LinkedList</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        graph[i] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> [] edge : times) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> edge[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// from -&gt; List&lt;(to, weight)&gt;</span></span><br><span class="line">        <span class="comment">// 邻接表存储图结构，同时存储权重信息</span></span><br><span class="line">        graph[from].add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;to, weight&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用 dijkstra 算法计算以节点 k 为起点到其他节点的最短路径</span></span><br><span class="line">    <span class="type">int</span>[] distTo = dijkstra(k, graph);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到最长的那一条最短路径</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; distTo.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(distTo[i] == Integer.MAX_VALUE) &#123;</span><br><span class="line">            <span class="comment">// 有节点不可达，返回 -1</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, distTo[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入一个起点 start，计算从 start 到其他节点的最短距离</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] dijkstra(<span class="type">int</span> start, List&lt;<span class="type">int</span>[]&gt;[] graph) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码首先利用题目输入的数据转化成邻接表表示一幅图，接下来可以直接套用 Dijkstra 算法的框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入一个起点 start，计算从 start 到其他节点的最短距离</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] dijkstra(<span class="type">int</span> start, List&lt;<span class="type">int</span>[]&gt;[] graph) &#123;</span><br><span class="line"><span class="comment">// 定义：distTo[i] 的值就是起点 start 到达节点 i 的最短路径权重</span></span><br><span class="line"><span class="type">int</span>[] distTo = <span class="keyword">new</span> <span class="title class_">int</span>[graph.length];</span><br><span class="line">Arrays.fill(distTo, Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// base case，start 到 start 的最短距离就是 0</span></span><br><span class="line">distTo[start] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先级队列，distFromStart 较小的排在前面</span></span><br><span class="line">Queue&lt;State&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a.distFromStart - b.distFromStart);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从起点 start 开始进行 BFS</span></span><br><span class="line">pq.offer(<span class="keyword">new</span> <span class="title class_">State</span>(start, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!pq.isEmpty()) &#123;</span><br><span class="line">    <span class="type">State</span> <span class="variable">curState</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">    <span class="type">int</span> <span class="variable">curNodeID</span> <span class="operator">=</span> curState.id;</span><br><span class="line">    <span class="type">int</span> <span class="variable">curDistFromStart</span> <span class="operator">=</span> curState.distFromStart;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(curDistFromStart &gt; distTo[curNodeID]) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 curNode 的相邻节点装入队列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>[] neighbor : graph[curNodeID]) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextNodeID</span> <span class="operator">=</span> neighbor[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">distToNextNode</span> <span class="operator">=</span> distTo[curNodeID] + neighbor[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新 dp table</span></span><br><span class="line">        <span class="keyword">if</span>(distTo[nextNodeID] &gt; distToNextNode) &#123;</span><br><span class="line">            distTo[nextNodeID] = distToNextNode;</span><br><span class="line">            pq.offer(<span class="keyword">new</span> <span class="title class_">State</span>(nextNodeID, distToNextNode));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> distTo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>


<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9HcmFwaC8xNjMxLiVFNiU5QyU4MCVFNSVCMCU4RiVFNCVCRCU5MyVFNSU4QSU5QiVFNiVCNiU4OCVFOCU4MCU5NyVFOCVCNyVBRiVFNSVCRSU4NC5qYXZh">1631.最小体力消耗路径<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXRoLXdpdGgtbWluaW11bS1lZmZvcnQ=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/19/5d94ff12b40ae024.png#crop=0&crop=0&crop=1&crop=1&id=HDbpw&originHeight=1402&originWidth=1446&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>如果把二维数组中每个 <code>(x, y)</code> 坐标看做一个节点，它上下左右的坐标就是相邻节点，它对应的值和相邻坐标对应的值之差的绝对值就是题目说的「体力消耗」，可以理解为边的权重。</p>
<p>这样，就在让求以左上角坐标为起点，以右下角坐标为终点，起点到终点的最短路径，Dijkstra 算法可以做到。<strong>不过，这道题中评判一条路径是长还是短的标准不再是路径经过的权重总和，而是路径经过的权重最大值</strong>。</p>
<p>二维矩阵抽象成图，先实现图的 <code>adj</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方向数组，上下左右的坐标偏移量</span></span><br><span class="line"><span class="type">int</span>[][] dirs = <span class="keyword">new</span> <span class="title class_">int</span>[][] &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回坐标 (x, y) 的上下左右相邻坐标</span></span><br><span class="line">List&lt;<span class="type">int</span>[]&gt; adj(<span class="type">int</span>[][] matrix, <span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储相邻节点</span></span><br><span class="line">List&lt;<span class="type">int</span>[]&gt; neighbors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span>[] dir : dirs) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nextX</span> <span class="operator">=</span> x + dir[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">nextY</span> <span class="operator">=</span> y + dir[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nextX &gt;= m || nextX &lt; <span class="number">0</span> || nextY &gt;= n || nextY &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 索引越界</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    neighbors.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nextX, nextY&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似的，现在认为一个二维坐标 <code>(x, y)</code> 是图中的一个节点，所以 <code>State</code> 类也需要修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line"><span class="comment">// 矩阵中的一个位置</span></span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从起点 (0, 0) 到当前位置的最小体力消耗（距离）</span></span><br><span class="line"><span class="type">int</span> effortFromStart;</span><br><span class="line"></span><br><span class="line">State(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> effortFromStart) &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">    <span class="built_in">this</span>.effortFromStart = effortFromStart;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以使用 Dijkstra 算法框架了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dijkstra 算法，计算 (0, 0) 到 (m - 1, n - 1) 的最小体力消耗</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumEffortPath</span><span class="params">(<span class="type">int</span>[][] heights)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> heights.length, n =heights[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">// 定义：从 (0, 0) 到 (i, j) 的最小体力消耗是 effortTo[i][j]</span></span><br><span class="line">    <span class="type">int</span>[][] effortTo = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dp table 初始化为正无穷</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        Arrays.fill(effortTo[i], Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// base case，起点到起点的最小消耗就是 0</span></span><br><span class="line">    effortTo[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优先级队列，effortFromStart 较小的排在前面</span></span><br><span class="line">    Queue&lt;State&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a.effortFromStart - b.effortFromStart);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从起点 (0, 0) 开始进行 BFS</span></span><br><span class="line">    pq.offer(<span class="keyword">new</span> <span class="title class_">State</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!pq.isEmpty()) &#123;</span><br><span class="line">        <span class="type">State</span> <span class="variable">curState</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">        <span class="type">int</span> <span class="variable">curX</span> <span class="operator">=</span> curState.x;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curY</span> <span class="operator">=</span> curState.y;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curEffortFromStart</span> <span class="operator">=</span> curState.effortFromStart;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到达终点提前结束</span></span><br><span class="line">        <span class="keyword">if</span>(curX == m - <span class="number">1</span> &amp;&amp; curY == n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> curEffortFromStart;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(curEffortFromStart &gt; effortTo[curX][curY]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 (curX, curY) 的相邻坐标装入队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] neighbor : adj(heights, curX, curY)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextX</span> <span class="operator">=</span> neighbor[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextY</span> <span class="operator">=</span> neighbor[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算从 (curX, curY) 达到 (nextX, nextY) 的消耗</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">effortToNextNode</span> <span class="operator">=</span> Math.max(effortTo[curX][curY], </span><br><span class="line">            Math.abs(heights[curX][curY] - heights[nextX][nextY]));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新 dp table</span></span><br><span class="line">            <span class="keyword">if</span>(effortTo[nextX][nextY] &gt; effortToNextNode) &#123;</span><br><span class="line">                effortTo[nextX][nextY] = effortToNextNode;</span><br><span class="line">                pq.offer(<span class="keyword">new</span> <span class="title class_">State</span>(nextX, nextY, effortToNextNode));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>


<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9HcmFwaC8xNTE0LiVFNiVBNiU4MiVFNyU4RSU4NyVFNiU5QyU4MCVFNSVBNCVBNyVFNyU5QSU4NCVFOCVCNyVBRiVFNSVCRSU4NC5qYXZh">1514.概率最大的路径<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXRoLXdpdGgtbWF4aW11bS1wcm9iYWJpbGl0eS8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/19/202b6128a20a118e.png#crop=0&crop=0&crop=1&crop=1&id=nDEol&originHeight=1112&originWidth=1466&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>这道题给的是无向图，而无向图本质上可以认为是「双向图」，从而转化成有向图。 Dijkstra 和很多最优化算法一样，计算的是「最优值」，这个最优值可能是最大值，也可能是最小值。标准 Dijkstra 算法是计算最短路径的，Dijkstra 算法不允许存在负权重边是因为 Dijkstra 计算最短路径的正确性依赖一个前提：路径中每增加一条边，路径的总权重就会增加。</p>
<p>所以如果想计算最长路径，路径中每增加一条边，路径的总权重就会减少，要是能够满足这个条件，也可以用 Dijkstra 算法。而这道题边和边之间是乘法关系，每条边的概率都是小于 1 的，所以肯定会越乘越小。</p>
<p>不过，这道题的解法要把优先级队列的排序顺序反过来，一些 if 大小判断也要反过来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">maxProbability</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges, <span class="type">double</span>[] succProb, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    List&lt;<span class="type">double</span>[]&gt;[] graph = <span class="keyword">new</span> <span class="title class_">LinkedList</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        graph[i] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造无向图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edges[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> edges[i][<span class="number">1</span>];</span><br><span class="line">        <span class="type">double</span> <span class="variable">weight</span> <span class="operator">=</span> succProb[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双向图</span></span><br><span class="line">        graph[from].add(<span class="keyword">new</span> <span class="title class_">double</span>[]&#123;(<span class="type">double</span>)to, weight&#125;);</span><br><span class="line">        graph[to].add(<span class="keyword">new</span> <span class="title class_">double</span>[]&#123;(<span class="type">double</span>)from, weight&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dijkstra(start, end, graph);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">dijkstra</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, List&lt;<span class="type">double</span>[]&gt;[] graph)</span> &#123;</span><br><span class="line">    <span class="comment">// 定义：probTo[i] 的值就是节点 start 到达节点 i 的最大概率</span></span><br><span class="line">    <span class="type">double</span>[] probTo = <span class="keyword">new</span> <span class="title class_">double</span>[graph.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dp table 初始化为一个取不到的最小值</span></span><br><span class="line">    Arrays.fill(probTo, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// base case，start 到 start 的概率就是 1</span></span><br><span class="line">    probTo[start] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 优先级队列，probFromStart 较大的排在前面</span></span><br><span class="line">    Queue&lt;State&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(b.probFromStart, a.probFromStart);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从起点 start 开始进行 BFS</span></span><br><span class="line">    pq.offer(<span class="keyword">new</span> <span class="title class_">State</span>(start, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!pq.isEmpty()) &#123;</span><br><span class="line">        <span class="type">State</span> <span class="variable">curState</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">        <span class="type">int</span> <span class="variable">curNodeID</span> <span class="operator">=</span> curState.id;</span><br><span class="line">        <span class="type">double</span> <span class="variable">curProbFromStart</span> <span class="operator">=</span> curState.probFromStart;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遇到终点提前返回</span></span><br><span class="line">        <span class="keyword">if</span> (curNodeID == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> curProbFromStart;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (curProbFromStart &lt; probTo[curNodeID]) &#123;</span><br><span class="line">            <span class="comment">// 已经有一条概率更大的路径到达 curNode 节点了</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 curNode 的相邻节点装入队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">double</span>[] neighbor : graph[curNodeID]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextNodeID</span> <span class="operator">=</span> (<span class="type">int</span>)neighbor[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 判断从 curNode 到 nextNode 的概率是否会更大</span></span><br><span class="line">            <span class="type">double</span> <span class="variable">probToNextNode</span> <span class="operator">=</span> probTo[curNodeID] * neighbor[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (probTo[nextNodeID] &lt; probToNextNode) &#123;</span><br><span class="line">                probTo[nextNodeID] = probToNextNode;</span><br><span class="line">                pq.offer(<span class="keyword">new</span> <span class="title class_">State</span>(nextNodeID, probToNextNode));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果到达这里，说明从 start 开始无法到达 end，返回 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="comment">// 图节点的 id</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="comment">// 从 start 节点到达当前节点的概率</span></span><br><span class="line">    <span class="type">double</span> probFromStart;</span><br><span class="line"></span><br><span class="line">    State(<span class="type">int</span> id, <span class="type">double</span> probFromStart) &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.probFromStart = probFromStart;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="LRU-算法"><a href="#LRU-算法" class="headerlink" title="LRU 算法"></a>LRU 算法</h2><p>LRU 是 Least Recently Used 的缩写，即最近最少使用页面置换算法，是为虚拟页式存储管理服务的，是根据页面调入内存后的使用情况进行决策了。由于无法预测各页面将来的使用情况，只能利用 “最近的过去” 作为 “最近的将来” 的近似。</p>
<p>因此，LRU 算法就是将最近最久未使用的页面予以淘汰。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9EUy8xNDYubHJ1LSVFNyVCQyU5MyVFNSVBRCU5OC5qYXZh">146.lru-缓存<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9scnUtY2FjaGU=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/20/c8fb511179a25999.png#crop=0&crop=0&crop=1&crop=1&id=pY4u2&originHeight=1386&originWidth=1442&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>设计数据结构：</p>
<p>首先要接收一个 <code>capacity</code> 参数作为缓存的最大容量，然后实现两个 API，一个是 <code>put(key, val)</code> 方法存入键值对，另一个是 <code>get(key)</code> 方法获取 <code>key</code> 对应的 <code>val</code>，如果 <code>key</code> 不存在则返回 <code>-1</code>。</p>
<p>对题目示例的解释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 缓存容量为 2 */</span></span><br><span class="line"><span class="type">LRUCache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LRUCache</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 可以把 cache 理解成一个队列</span></span><br><span class="line"><span class="comment">// 假设左边是队头，右边是队尾</span></span><br><span class="line"><span class="comment">// 最近使用的排在队头，久未使用的排在队尾</span></span><br><span class="line"><span class="comment">// 圆括号表示键值对 (key, val)</span></span><br><span class="line"></span><br><span class="line">cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// cache = [(1, 1)]</span></span><br><span class="line"></span><br><span class="line">cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// cache = [(2, 2), (1, 1)]</span></span><br><span class="line"></span><br><span class="line">cache.get(<span class="number">1</span>);       <span class="comment">// 返回 1</span></span><br><span class="line"><span class="comment">// cache = [(1, 1), (2, 2)]</span></span><br><span class="line"><span class="comment">// 解释：因为最近访问了键 1，所以提前至队头</span></span><br><span class="line"><span class="comment">// 返回键 1 对应的值 1</span></span><br><span class="line"></span><br><span class="line">cache.put(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// cache = [(3, 3), (1, 1)]</span></span><br><span class="line"><span class="comment">// 解释：缓存容量已满，需要删除内容空出位置</span></span><br><span class="line"><span class="comment">// 优先删除久未使用的数据，也就是队尾的数据</span></span><br><span class="line"><span class="comment">// 然后把新的数据插入队头</span></span><br><span class="line"></span><br><span class="line">cache.get(<span class="number">2</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line"><span class="comment">// cache = [(3, 3), (1, 1)]</span></span><br><span class="line"><span class="comment">// 解释：cache 中不存在键为 2 的数据</span></span><br><span class="line"></span><br><span class="line">cache.put(<span class="number">1</span>, <span class="number">4</span>);    </span><br><span class="line"><span class="comment">// cache = [(1, 4), (3, 3)]</span></span><br><span class="line"><span class="comment">// 解释：键 1 已存在，把原始值 1 覆盖为 4</span></span><br><span class="line"><span class="comment">// 不要忘了也要将键值对提前到队头</span></span><br></pre></td></tr></table></figure>

<p>分析上面的操作过程，要让 <code>put</code> 和 <code>get</code> 方法的时间复杂度为<code>O(1)</code>，可以总结出 <code>cache</code> 这个数据结构必要的条件：</p>
<ol>
<li>显然 <code>cache</code> 中的元素必须有时序，以区分最近使用的和久未使用的数据，当容量满后要删除最近最久未使用的元素空出位置。 </li>
<li>要在 <code>cache</code> 中快速找某个 <code>key</code> 是否已存在并得到对应的 <code>val</code>； </li>
<li>每次访问 <code>cache</code> 中的某个 <code>key</code>，需要将这个元素变为最近使用的，也就是说 <code>cache</code> 要支持在任意位置快速插入和删除元素。</li>
</ol>
<p>同时符合上述条件的数据结构中，哈希表查找快，但数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢。因此根据计算机通用的折中，形成一种新的数据结构：哈希链表 <code>LinkedHashMap</code>。</p>
<p>LRU 缓存算法的核心数据结构就是哈希链表，双向链表和哈希表的结合体：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/20/08ffeaba0e8600be.png#crop=0&crop=0&crop=1&crop=1&id=oncku&originHeight=958&originWidth=1608&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>借助这个结构，前面的 3 个条件：</p>
<ol>
<li>如果每次默认从链表尾部添加元素，那么显然越靠尾部的元素就是最近使用的，越靠头部的元素就是最久未使用的。 </li>
<li>对于某一个 <code>key</code>，可以通过哈希表快速定位到链表中的节点，从而取得对应 <code>val</code>。 </li>
<li>链表显然是支持在任意位置快速插入和删除的，修改指针就即可。不过传统的链表无法按照索引快速访问某一个位置的元素，而这里借助哈希表，可以通过 <code>key</code> 快速映射到任意一个链表节点，然后进行插入和删除。</li>
</ol>
<p>这里先手动造轮子，不使用 Java 内置的 <code>LinkedHashMap</code>。首先实现双链表的节点类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> key, val;</span><br><span class="line">    <span class="keyword">public</span> Node next, prev;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = k;</span><br><span class="line">        <span class="built_in">this</span>.val = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依靠 <code>Node</code> 类型构建一个双链表，实现几个 LRU 算法必须的 API：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleList</span> &#123;</span><br><span class="line">    <span class="comment">// 虚拟头尾节点</span></span><br><span class="line">    <span class="keyword">private</span> Node head, tail;  </span><br><span class="line">    <span class="comment">// 链表元素数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoubleList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化双向链表的数据</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链表尾部添加节点 x，时间 O(1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(Node x)</span> &#123;</span><br><span class="line">        x.prev = tail.prev;</span><br><span class="line">        x.next = tail;</span><br><span class="line">        tail.prev.next = x;</span><br><span class="line">        tail.prev = x;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除链表中的 x 节点（x 一定存在）</span></span><br><span class="line">    <span class="comment">// 由于是双链表且给的是目标 Node 节点，时间 O(1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Node x)</span> &#123;</span><br><span class="line">        x.prev.next = x.next;</span><br><span class="line">        x.next.prev = x.prev;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除链表中第一个节点，并返回该节点，时间 O(1)</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next == tail) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> head.next;</span><br><span class="line">        remove(first);</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回链表长度，时间 O(1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，就可以体现出为什么需要使用双向链表了：因为我们需要删除操作。删除一个节点不光要得到该节点本身的指针，也需要操作其前驱节点的指针，而双向链表才能支持直接查找前驱，保证操作的时间复杂度 <code>O(1)</code>。</p>
<p>注意我们实现的双链表 API 只能从尾部插入，也就是说靠尾部的数据是最近使用的，靠头部的数据是最久未使用的。</p>
<p>有了双向链表的实现，只需要在 LRU 算法中把它和哈希表结合起来即可，代码框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="comment">// key -&gt; Node(key, val)</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="comment">// Node(k1, v1) &lt;-&gt; Node(k2, v2)...</span></span><br><span class="line">    <span class="keyword">private</span> DoubleList cache;</span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cap;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cap = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">DoubleList</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>由于要同时维护一个双链表 <code>cache</code> 和一个哈希表 <code>map</code>，因此一些操作需要注意同步，如删除某个 <code>key</code> 时，需要在 <code>cache</code> 中删除对应的 <code>Node</code>，同时需要在 <code>map</code> 中删除 <code>key</code>。一个有效的方案是：在这两种数据结构之上提供一层抽象 API。就是尽量让 LRU 的主方法 <code>get</code> 和 <code>put</code> 避免直接操作 <code>map</code> 和 <code>cache</code> 的细节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将某个 key 提升为最近使用的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">makeRecently</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">    <span class="comment">// 先从链表中删除这个节点</span></span><br><span class="line">    cache.remove(x);</span><br><span class="line">    <span class="comment">// 重新插到队尾</span></span><br><span class="line">    cache.addLast(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加最近使用的元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addRecently</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, val);</span><br><span class="line">    <span class="comment">// 链表尾部就是最近使用的元素</span></span><br><span class="line">    cache.addLast(x);</span><br><span class="line">    <span class="comment">// 在 map 中添加 key 的映射</span></span><br><span class="line">    map.put(key, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除某一个 key</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteKey</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">    <span class="comment">// 从链表中删除</span></span><br><span class="line">    cache.remove(x);</span><br><span class="line">    <span class="comment">// 从 map 中删除</span></span><br><span class="line">    map.remove(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除最久未使用的元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeLeastRecently</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 链表头部的第一个元素就是最久未使用的</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">deletedNode</span> <span class="operator">=</span> cache.removeFirst();</span><br><span class="line">    <span class="comment">// 同时从 map 中删除它的 key</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">deletedKey</span> <span class="operator">=</span> deletedNode.key;</span><br><span class="line">    map.remove(deletedKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就可以看出在链表中同时存储 <code>key</code> 和 <code>val</code> 而不是只存储 <code>val</code> 的原因： 在 <code>removeLeastRecently</code> 函数中需要用 <code>deletedNode</code> 得到 <code>deletedKey</code>。</p>
<p>也就是说，当缓存容量满时，不仅仅要删除最后一个 <code>Node</code> 节点，还要把 <code>map</code> 中映射到该节点的 <code>key</code> 同时删除，而这个 <code>key</code> 只能由 <code>Node</code> 得到。如果 <code>Node</code> 结构中只存储 <code>val</code>，那么就无法获取 <code>key</code>，就无法删除 <code>map</code> 中的键，造成错误。</p>
<p>上述方法就是简单的操作封装，调用这些函数可以避免直接操作 <code>cache</code> 链表和 <code>map</code> 哈希表，下面实现 LRU 算法的 <code>get</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!map.containsKey(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将该数据提升为最近使用的</span></span><br><span class="line">    makeRecently(key);</span><br><span class="line">    <span class="keyword">return</span> map.get(key).val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>put</code> 方法的逻辑：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/20/a75fcba3cc6f46ab.png#crop=0&crop=0&crop=1&crop=1&id=HknCP&originHeight=980&originWidth=1452&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(key)) &#123;</span><br><span class="line">        <span class="comment">// 删除旧的数据</span></span><br><span class="line">        deleteKey(key);</span><br><span class="line">        <span class="comment">// 新插入的数据为最近使用的数据</span></span><br><span class="line">        addRecently(key, val);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cap == cache.size()) &#123;</span><br><span class="line">        <span class="comment">// 删除最久未使用的元素</span></span><br><span class="line">        removeLeastRecently();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加为最近使用的元素</span></span><br><span class="line">    addRecently(key, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就实现了 LRUCache 类。最后用 Java 的内置类型 <code>LinkedHashMap</code> 来实现 LRU 算法，逻辑和之前完全一致：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="type">int</span> cap;</span><br><span class="line">    LinkedHashMap&lt;Integer, Integer&gt; cache = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        cap = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!cache.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache.get(key).val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">// 修改 key 的值</span></span><br><span class="line">            cache.put(key, val);</span><br><span class="line">            <span class="comment">// 将 key 变为最近使用</span></span><br><span class="line">            makeRecently(key);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (cache.size() &gt;= <span class="built_in">this</span>.cap) &#123;</span><br><span class="line">            <span class="comment">// 链表头部就是最久未使用的 key</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">oldestKey</span> <span class="operator">=</span> cache.keySet().iterator().next();</span><br><span class="line">            cache.remove(oldestKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将新的 key 添加链表尾部</span></span><br><span class="line">        cache.put(key, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">makeRecently</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="comment">// 删除 key，重新插入到队尾</span></span><br><span class="line">        cache.remove(key);</span><br><span class="line">        cache.put(key, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h2 id="LFU-算法"><a href="#LFU-算法" class="headerlink" title="LFU 算法"></a>LFU 算法</h2><p>LFU 是 Least Frequently Used 的缩写，即最近最少使用策略，也就是说在一段时间内数据被使用频次最少的优先被淘汰。</p>
<p>从实现难度上来说，LFU 算法的难度大于 LRU 算法， LFU 算法是淘汰访问频次最低的数据，如果访问频次最低的数据有多条，需要淘汰最旧的数据。把数据按照访问频次进行排序，而且频次还会不断变化。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9EUy80NjAubGZ1LSVFNyVCQyU5MyVFNSVBRCU5OC5qYXZh">460.lfu-缓存<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sZnUtY2FjaGU=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/20/63519fa54826011e.png#crop=0&crop=0&crop=1&crop=1&id=WOBwI&originHeight=1450&originWidth=1460&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<ul>
<li><code>get(key)</code> 方法会去缓存中查询键 <code>key</code>，如果 <code>key</code> 存在，则返回 <code>key</code> 对应的 <code>val</code>，否则返回 <code>-1</code>。 </li>
<li><code>put(key, value)</code> 方法插入或修改缓存。如果 <code>key</code> 已存在，则将它对应的值改为 <code>val</code>；如果 <code>key</code> 不存在，则插入键值对 <code>(key, val)</code>。 </li>
<li>当缓存达到容量 <code>capacity</code> 时，则应该在插入新的键值对之前，删除使用频次（用 <code>freq</code> 表示）最低的键值对。如果 <code>freq</code> 最低的键值对有多个，则删除其中最旧的一个。</li>
</ul>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> 构造一个容量为 <span class="number">2</span> 的 LFU 缓存</span><br><span class="line">LFUCache cache = new LFUCache(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 插入两对 (key, val)，对应的 freq 为 <span class="number">1</span></span><br><span class="line">cache.put(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">cache.put(<span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 查询 key 为 <span class="number">1</span> 对应的 val</span><br><span class="line"><span class="regexp">//</span> 返回 <span class="number">10</span>，同时键 <span class="number">1</span> 对应的 freq 变为 <span class="number">2</span></span><br><span class="line">cache.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 容量已满，淘汰 freq 最小的键 <span class="number">2</span></span><br><span class="line"><span class="regexp">//</span> 插入键值对 (<span class="number">3</span>, <span class="number">30</span>)，对应的 freq 为 <span class="number">1</span></span><br><span class="line">cache.put(<span class="number">3</span>, <span class="number">30</span>);   </span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 键 <span class="number">2</span> 已经被淘汰删除，返回 -<span class="number">1</span></span><br><span class="line">cache.get(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>根据 LFU 算法的逻辑列举出算法需求：</p>
<ol>
<li>调用 <code>get(key)</code> 方法时，要返回该 <code>key</code> 对应的 <code>val</code>。 </li>
<li>只要用 <code>get</code> 或者 <code>put</code> 方法访问一次某个 <code>key</code>，该 <code>key</code> 的 <code>freq</code> 就加一。 </li>
<li>如果在容量满了的时候进行插入，则需要将 <code>freq</code> 最小的 <code>key</code> 删除，如果最小的 <code>freq</code> 对应多个 <code>key</code>，则删除其中最旧的一个。</li>
</ol>
<p>需要在 O(1) 的时间内解决这些需求，可以使用基本数据结构：</p>
<ol>
<li>使用一个 <code>HashMap</code> 存储 <code>key</code> 到 <code>val</code> 的映射，就可以快速计算 <code>get(key)</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, Integer&gt; keyToVal;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用一个 <code>HashMap</code> 存储 <code>key</code> 到 <code>freq</code> 的映射，就可以快速操作 <code>key</code> 对应的 <code>freq</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, Integer&gt; keyToFreq;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>这个需求是 LFU 算法的核心 <ol>
<li>首先需要 <code>freq</code> 到 <code>key</code> 的映射，用来找到 <code>freq</code> 最小的 <code>key</code>。 </li>
<li>要将 <code>freq</code> 最小的 <code>key</code> 删除，就需要快速得到当前所有 <code>key</code> 最小的 <code>freq</code>。若想时间复杂度为 <code>O(1)</code>，就不能遍历寻找，需要用一个变量 <code>minFreq</code> 来记录当前最小的 <code>freq</code>。 </li>
<li>可能有多个 <code>key</code> 拥有相同的 <code>freq</code>，所以 <code>freq</code> 对 <code>key</code> 是一对多的关系，即一个 <code>freq</code> 对应一个 <code>key</code> 的列表。 </li>
<li><code>freq</code> 对应的 <code>key</code> 的列表是存在时序的，便于快速查找并删除最旧的 <code>key</code>。 </li>
<li>能够快速删除 <code>key</code> 列表中的任何一个 <code>key</code>。如果频次为 <code>freq</code> 的某个 <code>key</code> 被访问，那么它的频次就会变成 <code>freq+1</code>，就应该从 <code>freq</code> 对应的 <code>key</code> 列表中删除，加到 <code>freq+1</code> 对应的 <code>key</code> 的列表中。</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; freqToKeys;</span><br><span class="line"><span class="type">int</span> <span class="variable">minFreq</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><code>LinkedHashSet</code> 是链表和哈希集合的结合体。链表不能快速访问链表节点，但是插入元素具有时序；哈希集合中的元素无序，但是可以对元素进行快速的访问和删除。它们结合起来就兼具了哈希集合和链表的特性，既可以在 <code>O(1)</code> 时间内访问或删除其中的元素，又可以保持插入的时序，高效实现 3.5 这个需求。</p>
<p>综上，可以写出 LFU 算法的基本数据结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LFUCache</span> &#123;</span><br><span class="line">    <span class="comment">// key 到 val 的映射，称 KV 表</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; keyToVal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key 到 freq 的映射，称 KF 表</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; keyToFreq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// freq 到 key 列表的映射，称 FK 表</span></span><br><span class="line">    HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; freqToKeys;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录最小的频次</span></span><br><span class="line">    <span class="type">int</span> minFreq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录 LFU 缓存的最大容量</span></span><br><span class="line">    <span class="type">int</span> cap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LFUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        keyToVal = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        keyToFreq = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        freqToKeys = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.cap = capacity;</span><br><span class="line">        <span class="built_in">this</span>.minFreq = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先实现 <code>get(key)</code> 方法，返回 <code>key</code> 对应的 <code>val</code>，然后增加 <code>key</code> 对应的<code>freq</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!keyToVal.containsKey(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增加 key 对应的 freq</span></span><br><span class="line">    increaseFreq(key);</span><br><span class="line">    <span class="keyword">return</span> keyToVal.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加key对应的freq是 LFU 算法的核心，所以抽象成一个函数 <code>increaseFreq</code>。</p>
<p>然后实现 <code>put(key, val)</code> 方法，逻辑如下图：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/20/01f57ee4ab018b3f.png#crop=0&crop=0&crop=1&crop=1&id=mRskt&originHeight=976&originWidth=1492&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.cap &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若 key 已存在，修改对应的 val</span></span><br><span class="line">    <span class="keyword">if</span>(keyToVal.containsKey(key)) &#123;</span><br><span class="line">        keyToVal.put(key, val);</span><br><span class="line">        <span class="comment">// key 对应的 freq 增加 1</span></span><br><span class="line">        increaseFreq(key);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key 不存在，需要插入</span></span><br><span class="line">    <span class="comment">// 容量已满需要淘汰一个 freq 最小的 key</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.cap &lt;= keyToVal.size()) &#123;</span><br><span class="line">        removeMinFreqKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入 key 和 val，对应的 freq 为 1</span></span><br><span class="line">    <span class="comment">// 插入 KV 表</span></span><br><span class="line">    keyToVal.put(key, val);</span><br><span class="line">    <span class="comment">// 插入 KF 表</span></span><br><span class="line">    keyToFreq.put(key, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 插入 FK 表</span></span><br><span class="line">    freqToKeys.put(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;());</span><br><span class="line">    freqToKeys.get(<span class="number">1</span>).add(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入新 key 后最小的 freq 是 1</span></span><br><span class="line">    <span class="built_in">this</span>.minFreq = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>increaseFreq</code> 和 <code>removeMinFreqKey</code> 方法是 LFU 算法的核心，首先实现 <code>removeMinFreqKey()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeMinFreqKey</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// freq 最小的 key 列表</span></span><br><span class="line">    LinkedHashSet&lt;Integer&gt; minKeyList = freqToKeys.get(minFreq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其中最先被插入的那个 key 就是该被淘汰的 key</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">deletedKey</span> <span class="operator">=</span> minKeyList.iterator().next();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 FK 表</span></span><br><span class="line">    minKeyList.remove(deletedKey);</span><br><span class="line">    <span class="keyword">if</span>(minKeyList.isEmpty()) &#123;</span><br><span class="line">        freqToKeys.remove(<span class="built_in">this</span>.minFreq);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 KV 表</span></span><br><span class="line">    keyToVal.remove(deletedKey);</span><br><span class="line">    <span class="comment">// 更新 KF 表</span></span><br><span class="line">    keyToFreq.remove(deletedKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除某个键 <code>key</code> 需要同时修改三个映射表，借助 <code>minFreq</code> 参数可以从 <code>FK</code> 表中找到 <code>freq</code> 最小的 <code>minKeyList</code>，根据时序，其中第一个元素就是要被淘汰的 <code>deletedKey</code>，操作三个映射表删除这个 <code>key</code> 即可。</p>
<p>如果 <code>minKeyList</code> 中只有一个元素，那么删除之后 <code>minFreq</code> 对应的 <code>key</code> 列表就为空了，也就是 <code>minFreq</code> 变量需要被更新。如何计算当前的 <code>minFreq</code> 是多少呢？</p>
<p>实际上无法快速计算 <code>minFreq</code>，只能线性遍历 <code>FK</code> 表或者 <code>KF</code> 表来计算，但这样肯定不能保证 <code>O(1)</code> 的时间复杂度。</p>
<p>但是这里没有必要更新 <code>minFreq</code> 变量，因为 <code>removeMinFreqKey</code> 这个函数是在 <code>put</code> 方法中插入新 <code>key</code> 时可能调用。而 <code>put</code> 插入新 <code>key</code> 时一定会把 <code>minFreq</code> 更新成 1，所以说这里 <code>minFreq</code> 值不需要考虑。</p>
<p>然后实现 <code>increaseFreq()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">increaseFreq</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">freq</span> <span class="operator">=</span> keyToFreq.get(key);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新 KF 表</span></span><br><span class="line">    keyToFreq.put(key, freq + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 FK 表</span></span><br><span class="line">    <span class="comment">// 将 key 从 freq 对应的列表中删除</span></span><br><span class="line">    freqToKeys.get(freq).remove(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 key 加入 freq + 1 对应的列表中</span></span><br><span class="line">    freqToKeys.putIfAbsent(freq + <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;());</span><br><span class="line">    freqToKeys.get(freq + <span class="number">1</span>).add(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 freq 对应的列表空了，移除这个 freq</span></span><br><span class="line">    <span class="keyword">if</span> (freqToKeys.get(freq).isEmpty()) &#123;</span><br><span class="line">        freqToKeys.remove(freq);</span><br><span class="line">        <span class="comment">// 如果这个 freq 恰好是 minFreq，更新 minFreq</span></span><br><span class="line">        <span class="keyword">if</span> (freq == <span class="built_in">this</span>.minFreq) &#123;</span><br><span class="line">            <span class="built_in">this</span>.minFreq++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新某个 <code>key</code> 的 <code>freq</code> 会涉及 <code>FK</code> 表和 <code>KF</code> 表，所以分别更新这两个表即可。</p>
<p>和之前类似，当 <code>FK</code> 表中 <code>freq</code> 对应的列表被删空后，需要删除 <code>FK</code> 表中 <code>freq</code> 这个映射。如果这个 <code>freq</code> 恰好是 <code>minFreq</code>，说明 <code>minFreq</code> 变量需要更新。因为把 <code>key</code> 的 <code>freq</code> 加 1，所以 <code>minFreq</code> 也加 1。</p>
<p>这样就实现了 LFU 算法。</p>
</br>

<h2 id="设计朋友圈时间线"><a href="#设计朋友圈时间线" class="headerlink" title="设计朋友圈时间线"></a>设计朋友圈时间线</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9EUy8zNTUuJUU4JUFFJUJFJUU4JUFFJUExJUU2JThFJUE4JUU3JTg5JUI5LmphdmE=">355.设计推特<i class="fa fa-external-link-alt"></i></span> &amp;emsp;<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZXNpZ24tdHdpdHRlci8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/20/c437418baee0ab8d.png"></p>
<p>Twitter 和微博功能差不多，主要要实现这样几个 API：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Twitter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** user 发表一条 tweet 动态 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postTweet</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> tweetId)</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 返回该 user 关注的人（包括他自己）最近的动态 id，</span></span><br><span class="line"><span class="comment">    最多 10 条，而且这些动态必须按从新到旧的时间线顺序排列。*/</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getNewsFeed</span><span class="params">(<span class="type">int</span> userId)</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** follower 关注 followee，如果 Id 不存在则新建 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">follow</span><span class="params">(<span class="type">int</span> followerId, <span class="type">int</span> followeeId)</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** follower 取关 followee，如果 Id 不存在则什么都不做 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unfollow</span><span class="params">(<span class="type">int</span> followerId, <span class="type">int</span> followeeId)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目示例解释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Twitter</span> <span class="variable">twitter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Twitter</span>();</span><br><span class="line"></span><br><span class="line">twitter.postTweet(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 用户 1 发送了一条新推文 5</span></span><br><span class="line"></span><br><span class="line">twitter.getNewsFeed(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// return [5]，因为自己是关注自己的</span></span><br><span class="line"></span><br><span class="line">twitter.follow(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 用户 1 关注了用户 2</span></span><br><span class="line"></span><br><span class="line">twitter.postTweet(<span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line"><span class="comment">// 用户 2 发送了一个新推文 (id = 6)</span></span><br><span class="line"></span><br><span class="line">twitter.getNewsFeed(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// return [6, 5]</span></span><br><span class="line"><span class="comment">// 解释：用户 1 关注了自己和用户 2，所以返回他们的最近推文</span></span><br><span class="line"><span class="comment">// 而且 6 必须在 5 之前，因为 6 是最近发送的</span></span><br><span class="line"></span><br><span class="line">twitter.unfollow(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 用户 1 取消关注了用户 2</span></span><br><span class="line"></span><br><span class="line">twitter.getNewsFeed(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// return [5]</span></span><br></pre></td></tr></table></figure>

<p>这几个 API 中最核心的功能难点是 <code>getNewsFeed</code>，返回的结果必须在时间上有序，但用户的关注是动态变化的。</p>
<p>如果把每个用户各自的推文存储在链表里，每个链表节点存储文章 <code>id</code> 和一个时间戳 <code>time</code>（记录发帖时间以便比较），且这个链表是按 <code>time</code> 有序的，那么如果某个用户关注了 <code>k</code> 个用户，就可以用合并 <code>k</code> 个有序链表的算法合并出有序的推文列表，正确地 <code>getNewsFeed</code>。</p>
<p>根据分析，需要一个 <code>User</code> 类储存 <code>user</code> 信息，还需要一个 <code>Tweet</code> 类储存推文信息，并且要作为链表的节点。所以先搭建整体框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Twitter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">timestamp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Tweet</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* API */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postTweet</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> tweetId)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getNewsFeed</span><span class="params">(<span class="type">int</span> userId)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">follow</span><span class="params">(<span class="type">int</span> followerId, <span class="type">int</span> followeeId)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unfollow</span><span class="params">(<span class="type">int</span> followerId, <span class="type">int</span> followeeId)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之所以要把 <code>Tweet</code> 和 <code>User</code> 类放到 <code>Twitter</code> 类里面，是因为 <code>Tweet</code> 类必须要用到一个全局时间戳 <code>timestamp</code>，而 <code>User</code> 类又需要用到 <code>Tweet</code> 类记录用户发送的推文，所以它们都作为内部类。</p>
</br>

<ol>
<li>Tweet 类的实现</li>
</ol>
<p>每个 <code>Tweet</code> 实例需要记录自己的 <code>tweetId</code> 和发表时间 <code>time</code>，且作为链表节点，要有一个指向下一个节点的 <code>next</code> 指针。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> time;</span><br><span class="line">    <span class="keyword">private</span> Tweet next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要传入推文内容（id）和发文时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Tweet</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> time)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.time = time;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s3.bmp.ovh/imgs/2022/07/20/1bf101ef2c1d3ccb.png"></p>
</br>

<ol start="2">
<li>User 类的实现</li>
</ol>
<p>一个用户需要存储的信息有 <code>userId</code>，关注列表，以及该用户发过的推文列表。其中关注列表应该用集合（HashSet）这种数据结构来存，因为不能重复，而且需要快速查找；推文列表应该由链表这种数据结构储存，以便于进行有序合并的操作：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/20/31932608faf0d171.png"></p>
<p>除此之外，根据面向对象的设计原则，「关注」「取关」和「发文」应该是 <code>User</code> 的行为，而且关注列表和推文列表也存储在 <code>User</code> 类中，所以也应该给 <code>User</code> 添加 <code>follow</code>、<code>unfollow</code> 和 <code>post</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static int timestamp = 0</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> Set&lt;Integer&gt; followed;</span><br><span class="line">    <span class="comment">// 用户发表的推文链表头结点</span></span><br><span class="line">    <span class="keyword">public</span> Tweet head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        followed = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关注自己</span></span><br><span class="line">        follow(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">follow</span><span class="params">(<span class="type">int</span> userId)</span> &#123;</span><br><span class="line">        followed.add(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unfollow</span><span class="params">(<span class="type">int</span> userId)</span> &#123;</span><br><span class="line">        <span class="comment">// 不能取关自己</span></span><br><span class="line">        <span class="keyword">if</span>(userId != <span class="built_in">this</span>.id) &#123;</span><br><span class="line">            followed.remove(userId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">post</span><span class="params">(<span class="type">int</span> tweetId)</span> &#123;</span><br><span class="line">        <span class="type">Tweet</span> <span class="variable">tweet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tweet</span>(tweetId, timestamp);</span><br><span class="line">        timestamp++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将新建的推文插入链表头</span></span><br><span class="line">        <span class="comment">// 越靠前的推文 time 值越大</span></span><br><span class="line">        tweet.next = head;</span><br><span class="line">        head = tweet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<ol start="3">
<li>API 实现</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Twitter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">timestamp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Tweet</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要一个映射将 userId 和 User 对象对应起来</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, User&gt; userMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** user 发表一条 tweet 动态 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postTweet</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> tweetId)</span> &#123;</span><br><span class="line">        <span class="comment">// 若 userId 不存在，则新建</span></span><br><span class="line">        <span class="keyword">if</span>(!userMap.containsKey(userId)) &#123;</span><br><span class="line">            userMap.put(userId, <span class="keyword">new</span> <span class="title class_">User</span>(userId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> userMap.get(userId);</span><br><span class="line">        u.post(tweetId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** follower 关注 followee */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">follow</span><span class="params">(<span class="type">int</span> followerId, <span class="type">int</span> followeeId)</span> &#123;</span><br><span class="line">        <span class="comment">// 若 follower 不存在，则新建</span></span><br><span class="line">        <span class="keyword">if</span>(!userMap.containsKey(followerId)) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(followerId);</span><br><span class="line">            userMap.put(followerId, u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若 followee 不存在，则新建</span></span><br><span class="line">        <span class="keyword">if</span>(!userMap.containsKey(followeeId)) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(followeeId);</span><br><span class="line">            userMap.put(followeeId, u);</span><br><span class="line">        &#125;   </span><br><span class="line">        userMap.get(followerId).follow(followeeId); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/** follower 取关 followee，如果 Id 不存在则什么都不做 */</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unfollow</span><span class="params">(<span class="type">int</span> followerId, <span class="type">int</span> followeeId)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(userMap.containsKey(followeeId)) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">follower</span> <span class="operator">=</span> userMap.get(followeeId);</span><br><span class="line">            follower.unfollow(followeeId);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/** 返回该 user 关注的人（包括他自己）最近的动态 id，</span></span><br><span class="line"><span class="comment">    最多 10 条，而且这些动态必须按从新到旧的时间线顺序排列。*/</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getNewsFeed</span><span class="params">(<span class="type">int</span> userId)</span> &#123;</span><br><span class="line">        <span class="comment">// 见下文</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<ol start="4">
<li>getNewsFeed 算法实现</li>
</ol>
<p>实现合并 k 个有序链表的算法需要用到优先级队列（PriorityQueue），这种数据结构是「二叉堆」最重要的应用，可以理解为它可以对插入的元素自动排序。乱序的元素插入其中就被放到了正确的位置，可以按照从小到大（或从大到小）有序地取出元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue pq</span><br><span class="line"><span class="comment"># 乱序插入</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">6</span>&#125;:</span><br><span class="line">    pq.add(i)</span><br><span class="line"><span class="keyword">while</span> pq <span class="keyword">not</span> empty:</span><br><span class="line">    <span class="comment"># 每次取出第一个（最小）元素</span></span><br><span class="line">    <span class="built_in">print</span>(pq.pop())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出有序：1,2,4,6,9</span></span><br></pre></td></tr></table></figure>

<p>把优先级队列设为按 <code>time</code> 属性从大到小降序排列，因为 <code>time</code> 越大意味着时间越近，应该排在前面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getNewsFeed</span><span class="params">(<span class="type">int</span> userId)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(!userMap.containsKey(userId)) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关注列表的用户 Id</span></span><br><span class="line">    Set&lt;Integer&gt; users = userMap.get(userId).followed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动通过 time 属性从大到小排序，容量为 users 的大小</span></span><br><span class="line">    PriorityQueue&lt;Tweet&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(user.size(), (a, b) -&gt; b.time - a.time);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先将所有链表头节点插入优先级队列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> id : users) &#123;</span><br><span class="line">        <span class="type">Tweet</span> <span class="variable">tweet</span> <span class="operator">=</span> userMap.get(id).head;</span><br><span class="line">        <span class="keyword">if</span>(tweet == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pq.add(tweet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!pq.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 最多返回 10 条</span></span><br><span class="line">        <span class="keyword">if</span>(res.size() == <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 弹出 time 值最大的（最近发表的）</span></span><br><span class="line">        <span class="type">Tweet</span> <span class="variable">tweet</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">        res.add(tweet.id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将下一篇 Tweet 插入进行排序</span></span><br><span class="line">        <span class="keyword">if</span>(tweet.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            pq.add(tweet.next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过程假设有三个 <code>Tweet</code> 链表按 <code>time</code> 属性降序排列，把它们降序合并添加到 <code>res</code> 中。注意图中链表节点中的数字是 <code>time</code> 属性，不是 <code>id</code> 属性：</p>
<p><img src="https://labuladong.github.io/algo/images/%e8%ae%be%e8%ae%a1Twitter/merge.gif"></p>
<p>至此，这道一个极其简化的 Twitter 时间线功能就设计完毕了。</p>
</br>

<h2 id="前缀树算法"><a href="#前缀树算法" class="headerlink" title="前缀树算法"></a>前缀树算法</h2><p>Trie 树又叫字典树、前缀树、单词查找树，是一种二叉树衍生出来的高级数据结构，主要应用场景是处理字符串前缀相关的操作。</p>
<p>常见的 <code>Map</code> 和 <code>Set</code> 的底层实现原理有哈希表和二叉搜索树两种，如 Java 的 <code>HashMap/HashSet</code> 和 C++ 的 <code>unorderd_map/unordered_set</code> 底层就是用哈希表实现，而 Java 的 <code>TreeMap/TreeSet</code> 和 C++ 的 <code>map/set</code> 底层使用红黑树这种自平衡 BST 实现的。</p>
<p>而下面要实现的 <code>TrieSet/TrieMap</code> 底层则用 Trie 树这种结构来实现。</p>
<p>本质上 <code>Set</code> 可以视为一种特殊的 <code>Map</code>，<code>Set</code> 其实就是 <code>Map</code> 中的键。所以下面先实现 <code>TrieMap</code>，然后在 <code>TrieMap</code> 的基础上封装出 <code>TrieSet</code>。</p>
<p>各种结构都是为了在「特定场景」下尽可能高效地进行增删查改。如 <code>HashMap&lt;K, V&gt;</code> 的优势是能够在 <code>O(1)</code> 时间通过键查找对应的值，但要求键的类型 <code>K</code> 必须是「可哈希」的；而 <code>TreeMap&lt;K, V&gt;</code> 的特点是方便根据键的大小进行操作，但要求键的类型 <code>K</code> 必须是「可比较」的。</p>
<p>下面要实现的 <code>TrieMap</code> 也是类似的，由于 Trie 树原理，我们要求 <code>TrieMap&lt;V&gt;</code> 的键必须是字符串类型，值的类型 <code>V</code> 可以随意。</p>
</br>

<h3 id="Trie-树原理"><a href="#Trie-树原理" class="headerlink" title="Trie 树原理"></a>Trie 树原理</h3><p><strong>Trie 树本质上就是一棵从二叉树衍生出来的多叉树。</strong></p>
<p>二叉树节点的代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 基本的二叉树节点 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left, right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>left, right</code> 存储左右子节点的指针。</p>
<p>多叉树节点的代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 基本的多叉树节点 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode[] children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>children</code> 数组中存储指向孩子节点的指针。</p>
<p>而 <code>TrieMap</code> 中的树节点 <code>TrieNode</code> 的代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Trie 树节点实现 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="type">V</span> <span class="variable">val</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    TrieNode&lt;V&gt;[] children = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">256</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 <code>val</code> 字段存储键对应的值，<code>children</code> 数组存储指向子节点的指针。</p>
<p>但是和之前的普通多叉树节点不同，<code>TrieNode</code> 中 <code>children</code> 数组的索引是有意义的，代表键中的一个字符。</p>
<p>如 <code>children[97]</code> 若非空，说明这里存储了一个字符 <code>&#39;a&#39;</code>，因为 <code>&#39;a&#39;</code> 的 ASCII 码为 97。</p>
<p>这里只考虑处理 ASCII 字符，所以 <code>children</code> 数组的大小设置为 256。可以根据具体问题修改，比如改成更小的数组或者 <code>HashMap&lt;Character, TrieNode&gt;</code> 都是一样的效果。</p>
<p>Trie 树的结构：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/21/42ae8f27d056f5d4.png"></p>
<p>一个节点有 256 个子节点指针，但大多数时候都是空的，可以省略掉不画，所以一般看到的 Trie 树结构如下图：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/21/52073fda17f7e8b2.png"></p>
<p>这是在 <code>TrieMap&lt;Integer</code>&gt; 中插入一些键值对后的样子，白色节点代表 <code>val</code> 字段为空，橙色节点代表 <code>val</code> 字段非空。</p>
<p>特别注意，<code>TrieNode</code> 节点本身只存储 <code>val</code> 字段，并没有一个字段来存储字符，字符是通过子节点在父节点的 <code>children</code> 数组中的索引确定的。</p>
<p>形象理解就是，Trie 树用「树枝」存储字符串（键），用「节点」存储字符串（键）对应的数据（值）。所以在图中把字符标在树枝，键对应的值 <code>val</code> 标在节点上：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/21/6855db9918e34ab8.png"></p>
<p>因为其中的字符串共享前缀，相同前缀的字符串集中在 Trie 树中的一个子树上，给字符串的处理带来很大的便利。使用 Trie 树又叫做前缀树。</p>
</br>

<h3 id="TrieMap-x2F-TrieSet-API-实现"><a href="#TrieMap-x2F-TrieSet-API-实现" class="headerlink" title="TrieMap&#x2F;TrieSet API 实现"></a>TrieMap&#x2F;TrieSet API 实现</h3><p>假设 TrieMap 中已经存储了如上图键值对：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 底层用 Trie 树实现的键值映射</span></span><br><span class="line"><span class="comment">// 键为 String 类型，值为类型 V</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieMap</span>&lt;V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 增/改 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 Map 中添加 key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, V val)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 删 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除键 key 以及对应的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(String key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 查 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索 key 对应的值，不存在则返回 null</span></span><br><span class="line">    <span class="comment">// get(&quot;the&quot;) -&gt; 4</span></span><br><span class="line">    <span class="comment">// get(&quot;tha&quot;) -&gt; null</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(String key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 key 是否存在在 Map 中</span></span><br><span class="line">    <span class="comment">// containsKey(&quot;tea&quot;) -&gt; false</span></span><br><span class="line">    <span class="comment">// containsKey(&quot;team&quot;) -&gt; true</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(String key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 Map 的所有键中搜索 query 的最短前缀</span></span><br><span class="line">    <span class="comment">// shortestPrefixOf(&quot;themxyz&quot;) -&gt; &quot;the&quot;</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">shortestPrefixOf</span><span class="params">(String query)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 Map 的所有键中搜索 query 的最长前缀</span></span><br><span class="line">    <span class="comment">// longestPrefixOf(&quot;themxyz&quot;) -&gt; &quot;them&quot;</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPrefixOf</span><span class="params">(String query)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索所有前缀为 prefix 的键</span></span><br><span class="line">    <span class="comment">// keysWithPrefix(&quot;th&quot;) -&gt; [&quot;that&quot;, &quot;the&quot;, &quot;them&quot;]</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">keysWithPrefix</span><span class="params">(String prefix)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是和否存在前缀为 prefix 的键</span></span><br><span class="line">    <span class="comment">// hasKeyWithPrefix(&quot;tha&quot;) -&gt; true</span></span><br><span class="line">    <span class="comment">// hasKeyWithPrefix(&quot;apple&quot;) -&gt; false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPrefix</span><span class="params">(String prefix)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通配符 . 匹配任意字符，搜索所有匹配的键</span></span><br><span class="line">    <span class="comment">// keysWithPattern(&quot;t.a.&quot;) -&gt; [&quot;team&quot;, &quot;that&quot;]</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">keysWithPattern</span><span class="params">(String pattern)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通配符 . 匹配任意字符，判断是否存在匹配的键</span></span><br><span class="line">    <span class="comment">// hasKeyWithPattern(&quot;.ip&quot;) -&gt; true</span></span><br><span class="line">    <span class="comment">// hasKeyWithPattern(&quot;.i&quot;) -&gt; false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPattern</span><span class="params">(String pattern)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 Map 中键值对的数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TrieSet</code> 的 API 大同小异，这里不重复列举。</p>
<p>首先，<code>TrieMap</code> 类中一定需要记录 Trie 的根节点 <code>root</code>，以及 Trie 树中的所有节点数量用于实现 <code>size()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieMap</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">// ASCII 码个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> <span class="number">256</span>;</span><br><span class="line">    <span class="comment">// 当前存在 Map 中的键值对个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span>&lt;V&gt; &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">val</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        TrieNode&lt;V&gt;[] children = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[R];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trie 树的根节点</span></span><br><span class="line">    <span class="keyword">private</span> TrieNode&lt;V&gt; root = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 其他 API 的实现... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，再实现一个工具函数 <code>getNode</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从节点 node 开始搜索 key，如果存在返回对应节点，否则返回 null</span></span><br><span class="line"><span class="keyword">private</span> TrieNode&lt;V&gt; <span class="title function_">getNode</span><span class="params">(TrieNode&lt;V&gt; node, String key)</span> &#123;</span><br><span class="line">    TrieNode&lt;V&gt; p = node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从节点 node 开始搜索 key</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; key.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向下搜索</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> key.charAt(i);</span><br><span class="line">        p = p.children[c];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s3.bmp.ovh/imgs/2022/07/21/513cac8fe97f601e.png"></p>
<p>这样就可以实现 <code>containsKey</code> 和 <code>get</code> 方法了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 搜索 key 对应的值，不存在则返回 null</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="comment">// 从 root 开始搜索 key</span></span><br><span class="line">    TrieNode&lt;V&gt; node = getNode(root, key);</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">null</span> || node.val == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// node 为空或 node 的 val 字段为空都说明 key 没有对应的值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 key 是否存在在 Map 中</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get(key) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意，就算 <code>getNode(key)</code> 的返回值 <code>node</code> 非空，也只能说字符串 <code>key</code> 是一个「前缀」；除非 <code>node.val</code> 同时非空，才能判断键 <code>key</code> 存在。</p>
<p>不过，这个特性恰好能够帮我们实现 <code>hasKeyWithPrefix</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是和否存在前缀为 prefix 的键</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPrefix</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">    <span class="comment">// 只要能找到一个节点，就是存在前缀</span></span><br><span class="line">    <span class="keyword">return</span> getNode(root, prefix) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似于 <code>getNode</code> 方法的逻辑可以实现 <code>shortestPrefixOf</code> 方法，只要在第一次遇到存有 val 的节点时返回：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在所有键中寻找 query 的最短前缀</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">shortestPrefixOf</span><span class="params">(String query)</span> &#123;</span><br><span class="line">    TrieNode&lt;V&gt; p = root;</span><br><span class="line">    <span class="comment">// 从节点 node 开始搜索 key</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; query.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p.val != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到一个键是 query 的前缀</span></span><br><span class="line">            <span class="keyword">return</span> query.substring(<span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向下搜索</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> query.charAt(i);</span><br><span class="line">        p = p.children[c];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">null</span> &amp;&amp; p.val != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 query 本身就是一个键</span></span><br><span class="line">        <span class="keyword">return</span> query;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是 for 循环结束之后还需要额外检查一下。</p>
<p>因为 Trie 树中「树枝」存储字符串，「节点」存储字符串对应的值，for 循环相当于只遍历了「树枝」，但漏掉了最后一个「节点」，即 <code>query</code> 本身就是 TrieMap 中的一个键的情况。</p>
<p><code>longestPrefixOf</code> 非常类似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">`longestPrefixOf` 也是非常类似的：</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">longestPrefixOf</span><span class="params">(String query)</span> &#123;</span><br><span class="line">    TrieNode&lt;V&gt; p = root;</span><br><span class="line">    <span class="comment">// 记录前缀的最大长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从节点 node 开始搜索 key</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; query.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p.val != <span class="literal">null</span>) &#123;</span><br><span class="line">             <span class="comment">// 找到一个键是 query 的前缀，更新前缀的最大长度</span></span><br><span class="line">             maxLen = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向下搜索</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> query.charAt(i);</span><br><span class="line">        p = p.children[c];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; p.val != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 query 本身就是一个键</span></span><br><span class="line">        <span class="keyword">return</span> query;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> query.substring(<span class="number">0</span>, maxLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次遇到 <code>p.val</code> 非空的时候说明找到一个键，但是不急着返回，而是更新 <code>maxLen</code> 变量，记录最长前缀的长度。</p>
<p>同样的，在 for 循环结束时要特殊判断一下，处理 <code>query</code> 本身就是键的情况。</p>
<p>实现 <code>keysWithPrefix</code> 方法，得到所有前缀为 <code>prefix</code> 的键。先利用 <code>getNode</code> 函数在 Trie 树中找到 <code>prefix</code> 对应的节点 <code>x</code>，然施展多叉树的遍历算法，遍历以 <code>x</code> 为根的这棵 Trie 树，找到所有键值对：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/21/b6dd7cc2877a77cd.png"></p>
<p>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 搜索前缀为 prefix 的所有键</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">keysWithPrefix</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到匹配 prefix 在 Trie 树中的节点</span></span><br><span class="line">    TrieNode&lt;V&gt; x = getNode(root, prefix);</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// DFS 遍历以 x 为根的这棵 Trie 树</span></span><br><span class="line">    traverse(x, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(prefix), res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历以 node 节点为根的 Trie 树，找到所有键</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TrieNode&lt;V&gt; node, StringBuilder path, List&lt;String&gt; res)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 到达 Trie 树底部叶子结点</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(node.val != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到一个 key，添加到结果列表中</span></span><br><span class="line">        res.add(path.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; R; c++) &#123;</span><br><span class="line">        path.append(c);</span><br><span class="line">        traverse(node.children[c], path, res);</span><br><span class="line">        path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现 <code>keysWithPattern</code> 方法，使用通配符来匹配多个键，其关键就在于通配符 <code>.</code> 可以匹配所有字符，用 <code>path</code> 变量记录匹配键的路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通配符 . 匹配任意字符</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">keysWithPattern</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    traverse(root, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(), pattern, <span class="number">0</span> , res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历函数，尝试在「以 node 为根的 Trie 树中」匹配 pattern[i..]</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TrieNode&lt;V&gt; node, StringBuilder path, String pattern, <span class="type">int</span> i, List&lt;String&gt; res)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 树枝不存在，即字符 pattern[i-1] 匹配失败</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == pattern.length()) &#123;</span><br><span class="line">        <span class="comment">// pattern 匹配完成</span></span><br><span class="line">        <span class="keyword">if</span> (node.val != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果这个节点存储着 val，则找到一个匹配的键</span></span><br><span class="line">            res.add(path.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> pattern.charAt(i);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// pattern[i] 是通配符，可以变化成任意字符</span></span><br><span class="line">        <span class="comment">// 多叉树（回溯算法）遍历框架</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; R; j++) &#123;</span><br><span class="line">            path.append(j);</span><br><span class="line">            traverse(node.children[j], path, pattern, i + <span class="number">1</span>, res);</span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// pattern[i] 是普通字符 c</span></span><br><span class="line">        path.append(c);</span><br><span class="line">        traverse(node.children[c], path, pattern, i + <span class="number">1</span>, res);</span><br><span class="line">        path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>keysWithPattern</code> 和 <code>keysWithPrefix</code> 的实现有些类似，而且这两个函数还有一个潜在的特性：它们返回的结果列表一定是符合「字典序」的：每一个节点的 <code>children</code> 数组都是从左到右进行遍历，即按照 ASCII 码从小到大的顺序递归遍历，得到的结果自然是符合字典序的。</p>
<p>实现 <code>hasKeyWithPattern</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是和否存在前缀为 prefix 的键</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPattern</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">    <span class="comment">// 从 root 节点开始匹配 pattern[0..]</span></span><br><span class="line">    <span class="keyword">return</span> hasKeyWithPattern(root, pattern, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义：从 node 节点开始匹配 pattern[i..]，返回是否成功匹配</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPattern</span><span class="params">(TrieNode&lt;V&gt; node, String pattern, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 树枝不存在，即匹配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == pattern.length()) &#123;</span><br><span class="line">        <span class="comment">// 模式串走到头了，看看匹配到的是否是一个键</span></span><br><span class="line">        <span class="keyword">return</span> node.val != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> pattern.charAt(i);</span><br><span class="line">    <span class="comment">// 没有遇到通配符</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 从 node.children[c] 节点开始匹配 pattern[i+1..]</span></span><br><span class="line">        <span class="keyword">return</span> hasKeyWithPattern(node.children[c], pattern, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遇到通配符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; R; j++) &#123;</span><br><span class="line">        <span class="comment">// pattern[i] 可以变化成任意字符，尝试所有可能，只要遇到一个匹配成功就返回</span></span><br><span class="line">        <span class="keyword">if</span> (hasKeyWithPattern(node.children[j], pattern, i + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 都没有匹配</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>put</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 map 中添加或修改键值对</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, V val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!containsKey(key)) &#123;</span><br><span class="line">        <span class="comment">// 新增键值对</span></span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要一个额外的辅助函数，并接收其返回值</span></span><br><span class="line">    root = put(root, key, val, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义：向以 node 为根的 Trie 树中插入 key[i..]，返回插入完成后的根节点</span></span><br><span class="line"><span class="keyword">private</span> TrieNode&lt;V&gt; <span class="title function_">put</span><span class="params">(TrieNode&lt;V&gt; node, String key, V val, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果树枝不存在，新建</span></span><br><span class="line">        node = <span class="keyword">new</span> <span class="title class_">TrieNode</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == key.length()) &#123;</span><br><span class="line">        <span class="comment">// key 的路径已插入完成，将值 val 存入节点</span></span><br><span class="line">        node.val = val;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> key.charAt(i);</span><br><span class="line">    <span class="comment">// 递归插入子节点，并接收返回值</span></span><br><span class="line">    node.children[c] = put(node.children[c], key, val, i + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为是递归修改数据结构，所以必须额外创建一个返回类型为 <code>TrieNode</code> 的辅助函数，并且在递归调用的时候接收其返回值，拼接到父节点上。</p>
<p>由于 Trie 树中的键就是「树枝」，值就是「节点」，所以插入的逻辑就是沿路新建「树枝」，把 <code>key</code> 的整条「树枝」构建出来之后，在树枝末端的「节点」中存储 <code>val</code>。</p>
<p>对于 <code>remove</code> 函数，如下图这个场景，如果想删除键 <code>&quot;team&quot;</code>，那么需要删掉 <code>&quot;eam&quot;</code> 这条树枝才是符合逻辑的：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/21/df21251abd234070.png"></p>
<p>要控制算法来正确地进行删除：</p>
<p>首先递归修改数据结构时，如果一个节点想删掉自己，直接返回空指针。</p>
<p>其次，一个节点如何知道自己是否需要被删除主要看自己的 <code>val</code> 字段是否为空以及自己的 <code>children</code> 数组是否全都是空指针。一个节点要先递归处理子树，然后在后序位置检查自己的 <code>val</code> 字段和 <code>children</code> 列表，判断自己是否需要被删除。如果自己的 <code>val</code> 字段为空，说明自己没有存储值，如果同时自己的 <code>children</code> 数组全是空指针，说明自己下面也没有接树枝，即不是任何一个键的前缀。这种情况下这个节点就应该删掉自己。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 Map 中删除 key</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!containsKey(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归修改数据结构要接收函数的返回值</span></span><br><span class="line">    root = remove(root, key, <span class="number">0</span>);</span><br><span class="line">    size--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义：在以 node 为根的 Trie 树中删除 key[i..]，返回删除后的根节点</span></span><br><span class="line"><span class="keyword">private</span> TrieNode&lt;V&gt; <span class="title function_">remove</span><span class="params">(TrieNode&lt;V&gt; node, String key, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == key.length()) &#123;</span><br><span class="line">        <span class="comment">// 找到了 key 对应的 TrieNode，删除 val</span></span><br><span class="line">        node.val = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> key.charAt(i);</span><br><span class="line">        <span class="comment">// 递归去子树进行删除</span></span><br><span class="line">        node.children[c] = remove(node.children[c], key, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后序位置，递归路径上的节点可能需要被清理</span></span><br><span class="line">    <span class="keyword">if</span> (node.val != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果该 TireNode 存储着 val，不需要被清理</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查该 TrieNode 是否还有后缀</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; R; c++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.children[c] != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 只要存在一个子节点（后缀树枝），就不需要被清理</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 既没有存储 val，也没有后缀树枝，则该节点需要被清理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里 TrieMap 的所有 API 就实现完了，完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieMap</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">// ASCII 码个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> <span class="number">256</span>;</span><br><span class="line">    <span class="comment">// 当前存在 Map 中的键值对个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Trie 树的根节点</span></span><br><span class="line">    <span class="keyword">private</span> TrieNode&lt;V&gt; root = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span>&lt;V&gt; &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">val</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        TrieNode&lt;V&gt;[] children = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[R];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 增/改 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 map 中添加或修改键值对</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, V val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">// 新增键值对</span></span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 需要一个额外的辅助函数，并接收其返回值</span></span><br><span class="line">        root = put(root, key, val, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：向以 node 为根的 Trie 树中插入 key[i..]，返回插入完成后的根节点</span></span><br><span class="line">    <span class="keyword">private</span> TrieNode&lt;V&gt; <span class="title function_">put</span><span class="params">(TrieNode&lt;V&gt; node, String key, V val, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果树枝不存在，新建</span></span><br><span class="line">            node = <span class="keyword">new</span> <span class="title class_">TrieNode</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == key.length()) &#123;</span><br><span class="line">            <span class="comment">// key 的路径已插入完成，将值 val 存入节点</span></span><br><span class="line">            node.val = val;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> key.charAt(i);</span><br><span class="line">        <span class="comment">// 递归插入子节点，并接收返回值</span></span><br><span class="line">        node.children[c] = put(node.children[c], key, val, i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 删 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 Map 中删除 key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归修改数据结构要接收函数的返回值</span></span><br><span class="line">        root = remove(root, key, <span class="number">0</span>);</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：在以 node 为根的 Trie 树中删除 key[i..]，返回删除后的根节点</span></span><br><span class="line">    <span class="keyword">private</span> TrieNode&lt;V&gt; <span class="title function_">remove</span><span class="params">(TrieNode&lt;V&gt; node, String key, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == key.length()) &#123;</span><br><span class="line">            <span class="comment">// 找到了 key 对应的 TrieNode，删除 val</span></span><br><span class="line">            node.val = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> key.charAt(i);</span><br><span class="line">            <span class="comment">// 递归去子树进行删除</span></span><br><span class="line">            node.children[c] = remove(node.children[c], key, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 后序位置，递归路径上的节点可能需要被清理</span></span><br><span class="line">        <span class="keyword">if</span> (node.val != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果该 TireNode 存储着 val，不需要被清理</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查该 TrieNode 是否还有后缀</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; R; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.children[c] != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 只要存在一个子节点（后缀树枝），就不需要被清理</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 既没有存储 val，也没有后缀树枝，则该节点需要被清理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 查 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索 key 对应的值，不存在则返回 null</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="comment">// 从 root 开始搜索 key</span></span><br><span class="line">        TrieNode&lt;V&gt; x = getNode(root, key);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span> || x.val == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// x 为空或 x 的 val 字段为空都说明 key 没有对应的值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 key 是否存在在 Map 中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> get(key) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是和否存在前缀为 prefix 的键</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPrefix</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="comment">// 只要能找到一个节点，就是存在前缀</span></span><br><span class="line">        <span class="keyword">return</span> getNode(root, prefix) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在所有键中寻找 query 的最短前缀</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">shortestPrefixOf</span><span class="params">(String query)</span> &#123;</span><br><span class="line">        TrieNode&lt;V&gt; p = root;</span><br><span class="line">        <span class="comment">// 从节点 node 开始搜索 key</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; query.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 无法向下搜索</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p.val != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 找到一个键是 query 的前缀</span></span><br><span class="line">                <span class="keyword">return</span> query.substring(<span class="number">0</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向下搜索</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> query.charAt(i);</span><br><span class="line">            p = p.children[c];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; p.val != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 query 本身就是一个键</span></span><br><span class="line">            <span class="keyword">return</span> query;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在所有键中寻找 query 的最长前缀</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPrefixOf</span><span class="params">(String query)</span> &#123;</span><br><span class="line">        TrieNode&lt;V&gt; p = root;</span><br><span class="line">        <span class="comment">// 记录前缀的最大长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max_len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从节点 node 开始搜索 key</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; query.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 无法向下搜索</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p.val != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 找到一个键是 query 的前缀，更新前缀的最大长度</span></span><br><span class="line">                max_len = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向下搜索</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> query.charAt(i);</span><br><span class="line">            p = p.children[c];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; p.val != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 query 本身就是一个键</span></span><br><span class="line">            <span class="keyword">return</span> query;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> query.substring(<span class="number">0</span>, max_len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索前缀为 prefix 的所有键</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">keysWithPrefix</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 找到匹配 prefix 在 Trie 树中的那个节点</span></span><br><span class="line">        TrieNode&lt;V&gt; x = getNode(root, prefix);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// DFS 遍历以 x 为根的这棵 Trie 树</span></span><br><span class="line">        traverse(x, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(prefix), res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历以 node 节点为根的 Trie 树，找到所有键</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TrieNode&lt;V&gt; node, StringBuilder path, List&lt;String&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 到达 Trie 树底部叶子结点</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.val != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到一个 key，添加到结果列表中</span></span><br><span class="line">            res.add(path.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回溯算法遍历框架</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; R; c++) &#123;</span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            path.append(c);</span><br><span class="line">            traverse(node.children[c], path, res);</span><br><span class="line">            <span class="comment">// 撤销选择</span></span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通配符 . 匹配任意字符</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">keysWithPattern</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        traverse(root, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(), pattern, <span class="number">0</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历函数，尝试在「以 node 为根的 Trie 树中」匹配 pattern[i..]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TrieNode&lt;V&gt; node, StringBuilder path, String pattern, <span class="type">int</span> i, List&lt;String&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 树枝不存在，即匹配失败</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == pattern.length()) &#123;</span><br><span class="line">            <span class="comment">// pattern 匹配完成</span></span><br><span class="line">            <span class="keyword">if</span> (node.val != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果这个节点存储着 val，则找到一个匹配的键</span></span><br><span class="line">                res.add(path.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> pattern.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// pattern[i] 是通配符，可以变化成任意字符</span></span><br><span class="line">            <span class="comment">// 多叉树（回溯算法）遍历框架</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; R; j++) &#123;</span><br><span class="line">                path.append(j);</span><br><span class="line">                traverse(node.children[j], path, pattern, i + <span class="number">1</span>, res);</span><br><span class="line">                path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// pattern[i] 是普通字符 c</span></span><br><span class="line">            path.append(c);</span><br><span class="line">            traverse(node.children[c], path, pattern, i + <span class="number">1</span>, res);</span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是和否存在前缀为 prefix 的键</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPattern</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">        <span class="comment">// 从 root 节点开始匹配 pattern[0..]</span></span><br><span class="line">        <span class="keyword">return</span> hasKeyWithPattern(root, pattern, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数定义：从 node 节点开始匹配 pattern[i..]，返回是否成功匹配</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPattern</span><span class="params">(TrieNode&lt;V&gt; node, String pattern, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 树枝不存在，即匹配失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == pattern.length()) &#123;</span><br><span class="line">            <span class="comment">// 模式串走到头了，看看匹配到的是否是一个键</span></span><br><span class="line">            <span class="keyword">return</span> node.val != <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> pattern.charAt(i);</span><br><span class="line">        <span class="comment">// 没有遇到通配符</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 从 node.children[c] 节点开始匹配 pattern[i+1..]</span></span><br><span class="line">            <span class="keyword">return</span> hasKeyWithPattern(node.children[c], pattern, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遇到通配符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; R; j++) &#123;</span><br><span class="line">            <span class="comment">// pattern[i] 可以变化成任意字符，尝试所有可能，只要遇到一个匹配成功就返回</span></span><br><span class="line">            <span class="keyword">if</span> (hasKeyWithPattern(node.children[j], pattern, i + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 都没有匹配</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从节点 node 开始搜索 key，如果存在返回对应节点，否则返回 null</span></span><br><span class="line">    <span class="keyword">private</span> TrieNode&lt;V&gt; <span class="title function_">getNode</span><span class="params">(TrieNode&lt;V&gt; node, String key)</span> &#123;</span><br><span class="line">        TrieNode&lt;V&gt; p = node;</span><br><span class="line">        <span class="comment">// 从节点 node 开始搜索 key</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; key.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 无法向下搜索</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向下搜索</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> key.charAt(i);</span><br><span class="line">            p = p.children[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来只要对 TrieMap 做简单的封装即可实现 TrieSet：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieSet</span> &#123;</span><br><span class="line">    <span class="comment">// 底层用一个 TrieMap，键就是 TrieSet，值仅仅起到占位的作用</span></span><br><span class="line">    <span class="comment">// 值的类型可以随便设置，我参考 Java 标准库设置成 Object</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TrieMap&lt;Object&gt; map = <span class="keyword">new</span> <span class="title class_">TrieMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 增 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在集合中添加元素 key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        map.put(key, <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 删 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从集合中删除元素 key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        map.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 查 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断元素 key 是否存在集合中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.containsKey(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在集合中寻找 query 的最短前缀</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">shortestPrefixOf</span><span class="params">(String query)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.shortestPrefixOf(query);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在集合中寻找 query 的最长前缀</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPrefixOf</span><span class="params">(String query)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.longestPrefixOf(query);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在集合中搜索前缀为 prefix 的所有元素</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">keysWithPrefix</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.keysWithPrefix(prefix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断集合中是否存在前缀为 prefix 的元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPrefix</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.hasKeyWithPrefix(prefix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通配符 . 匹配任意字符，返回集合中匹配 pattern 的所有元素</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">keysWithPattern</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.keysWithPattern(pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通配符 . 匹配任意字符，判断集合中是否存在匹配 pattern 的元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPattern</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.hasKeyWithPattern(pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回集合中元素的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9EUy8yMDguJUU1JUFFJTlFJUU3JThFJUIwLXRyaWUtJUU1JTg5JThEJUU3JUJDJTgwJUU2JUEwJTkxLmphdmE=">208.实现Trie(前缀树)<i class="fa fa-external-link-alt"></i></span> &amp;emsp;<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbXBsZW1lbnQtdHJpZS1wcmVmaXgtdHJlZS8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/21/40e71b8a0943206f.png"></p>
<p>题目让实现的几个函数就是 <code>TrieSet</code> 的部分 API，所以封装一个 <code>TrieSet</code> 就能解决这道题了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="comment">// 封装 TrieSet</span></span><br><span class="line">    <span class="type">TrieSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrieSet</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入一个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        set.add(word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断元素是否在集合中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> set.contains(word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断集合中是否有前缀为 prefix 的元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> set.hasKeyWithPrefix(prefix);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieSet</span> &#123; <span class="comment">/* 见上文 */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieMap</span> &#123; <span class="comment">/* 见上文 */</span> &#125;</span><br></pre></td></tr></table></figure>

</br>

<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9EUy82NDguJUU1JThEJTk1JUU4JUFGJThEJUU2JTlCJUJGJUU2JThEJUEyLmphdmE=">648.单词替换<i class="fa fa-external-link-alt"></i></span> &amp;emsp;<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXBsYWNlLXdvcmRzLw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/21/45426aae419cc007.png"></p>
<p>可以把输入的词根列表 <code>dict</code> 存入 <code>TrieSet</code>，然后直接复用实现的 <code>shortestPrefixOf</code> 函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">replaceWords</span><span class="params">(List&lt;String&gt; dict, String sentence)</span> &#123;</span><br><span class="line">    <span class="comment">// 先将词根都存入 TrieSet</span></span><br><span class="line">    <span class="type">TrieSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrieSet</span>();</span><br><span class="line">    <span class="keyword">for</span> (String key : dict) &#123;</span><br><span class="line">        set.add(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    String[] words = sentence.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="comment">// 处理句子中的单词</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 在 Trie 树中搜索最短词根（最短前缀）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> set.shortestPrefixOf(words[i]);</span><br><span class="line">        <span class="keyword">if</span> (!prefix.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 如果搜索到了，改写为词根</span></span><br><span class="line">            sb.append(prefix);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，原样放回</span></span><br><span class="line">            sb.append(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i != words.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 添加单词之间的空格</span></span><br><span class="line">            sb.append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieSet</span> &#123; <span class="comment">/* 见上文 */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieMap</span> &#123; <span class="comment">/* 见上文 */</span> &#125;</span><br></pre></td></tr></table></figure>

</br>

<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9EUy8yMTEuJUU2JUI3JUJCJUU1JThBJUEwJUU0JUI4JThFJUU2JTkwJTlDJUU3JUI0JUEyJUU1JThEJTk1JUU4JUFGJThELSVFNiU5NSVCMCVFNiU4RCVBRSVFNyVCQiU5MyVFNiU5RSU4NCVFOCVBRSVCRSVFOCVBRSVBMS5qYXZh">211.添加与搜索单词<i class="fa fa-external-link-alt"></i></span> &amp;emsp;<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZXNpZ24tYWRkLWFuZC1zZWFyY2gtd29yZHMtZGF0YS1zdHJ1Y3R1cmUv">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/21/13a39f5626b8b74f.png"></p>
<p>考点在于 <code>search</code> 函数进行通配符匹配，其实就是给 <code>TrieSet</code> 实现的 <code>hasKeyWithPattern</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WordDictionary</span> &#123;</span><br><span class="line">    <span class="type">TrieSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrieSet</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 TrieSet 中添加元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addWord</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        set.add(word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通配符匹配元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> set.hasKeyWithPattern(word);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieSet</span> &#123; <span class="comment">/* 见上文 */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieMap</span> &#123; <span class="comment">/* 见上文 */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>超时可以根据题目将 <code>R</code> 改小。</p>
</br>

<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9EUy8xODA0LiVFNSVBRSU5RSVFNyU4RSVCMC10cmllLSVFRiVCQyU4OCVFNSU4OSU4RCVFNyVCQyU4MCVFNiVBMCU5MSVFRiVCQyU4OS1paS5qYXZh">1804.实现Trie(前缀树) II<i class="fa fa-external-link-alt"></i></span> &amp;emsp;<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbXBsZW1lbnQtdHJpZS1paS1wcmVmaXgtdHJlZS8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/21/c0b6621db903d1c8.png"></p>
<p>这题就可以用到 <code>TrieMap</code>，每个插入的 <code>word</code> 就是键，插入的次数就是对应的值，然后复用 <code>TrieMap</code> 的 API 就能实现题目要求的这些函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="comment">// 封装实现的 TrieMap</span></span><br><span class="line">    TrieMap&lt;Integer&gt; map = <span class="keyword">new</span> <span class="title class_">TrieMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入 word 并记录插入次数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(word)) &#123;</span><br><span class="line">            map.put(word, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(word, map.get(word) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询 word 插入的次数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countWordsEqualTo</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(word)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累加前缀为 prefix 的键的插入次数总和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countWordsStartingWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String key : map.keysWithPrefix(prefix)) &#123;</span><br><span class="line">            res += map.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// word 的插入次数减一</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">erase</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">freq</span> <span class="operator">=</span> map.get(word);</span><br><span class="line">        <span class="keyword">if</span> (freq - <span class="number">1</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            map.remove(word);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(word, freq - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieMap</span> &#123; <span class="comment">/* 见上文 */</span> &#125;</span><br></pre></td></tr></table></figure>

</br>


<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9EUy82NzcuJUU5JTk0JUFFJUU1JTgwJUJDJUU2JTk4JUEwJUU1JUIwJTg0LmphdmE=">677.键值映射<i class="fa fa-external-link-alt"></i></span> &amp;emsp;<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXAtc3VtLXBhaXJzLw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/21/7432871a0c5dc392.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MapSum</span> &#123;</span><br><span class="line">    <span class="comment">// 封装实现的 TrieMap</span></span><br><span class="line">    TrieMap&lt;Integer&gt; map = <span class="keyword">new</span> <span class="title class_">TrieMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入键值对</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        map.put(key, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累加所有前缀为 prefix 的键的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        List&lt;String&gt; keys = map.keysWithPrefix(prefix);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            res += map.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieMap</span> &#123; <span class="comment">/* 见上文 */</span> &#125;</span><br></pre></td></tr></table></figure>

</br>

<h2 id="单调栈结构"><a href="#单调栈结构" class="headerlink" title="单调栈结构"></a>单调栈结构</h2><p>栈（stack）是一种简单的数据结构，先进后出的逻辑顺序，符合某些问题的特点，比如函数调用栈。单调栈实际上就是栈，只是利用了一些巧妙的逻辑，使得每次新元素入栈后，栈内的元素都保持有序（单调递增或单调递减）。</p>
</br>

<h3 id="单调栈模版"><a href="#单调栈模版" class="headerlink" title="单调栈模版"></a>单调栈模版</h3><p>输入一个数组 <code>nums</code>，返回一个等长的结果数组，结果数组中对应索引存储着下一个更大元素，如果没有更大的元素就存 -1。</p>
<p>比如输入一个数组 <code>nums = [2,1,2,4,3]</code>，返回数组 <code>[4,2,4,-1,-1]</code>。因为第一个 2 后面比 2 大的数是 4; 1 后面比 1 大的数是 2；第二个 2 后面比 2 大的数是 4; 4 后面没有比 4 大的数，填 -1；3 后面没有比 3 大的数，填 -1。</p>
<p>这道题的暴力解法很容易想到，就是对每个元素后面都进行扫描，找到第一个更大的元素就行了。但是暴力解法的时间复杂度是 <code>O(n^2)</code>。</p>
<p>这个问题可以抽象思考：把数组的元素想象成并列站立的人，元素大小想象成人的身高。这些人面对站成一列，如何求元素「2」的下一个更大元素？如果能够看到元素「2」，那么他后面可见的第一个人就是「2」的下一个更大元素，因为比「2」小的元素身高不够，都被「2」挡住了，第一个露出来的就是答案。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/22/6152a56df1837b8e.png"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// 存放答案的数组</span></span><br><span class="line">    <span class="type">int</span> res[] = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 倒着往栈里放</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 判定大小</span></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek() &lt;= nums[i]) &#123;</span><br><span class="line">            <span class="comment">// 小的出栈</span></span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nums[i] 后的更大元素</span></span><br><span class="line">        res[i] = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">        stack.push(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是单调队列解决问题的模板。for 循环从后往前扫描元素，因为借助的是栈的结构，倒着入栈就是是正着出栈。while 循环是把两个「个子高」元素之间的元素排除。</p>
<p>总共有 <code>n</code> 个元素，每个元素都被 <code>push</code> 入栈了一次，而最多会被 <code>pop</code> 一次，没有任何冗余操作。所以总的计算规模是和元素规模 <code>n</code> 成正比的，也就是 <code>O(n)</code> 的复杂度。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9EUy80OTYuJUU0JUI4JThCJUU0JUI4JTgwJUU0JUI4JUFBJUU2JTlCJUI0JUU1JUE0JUE3JUU1JTg1JTgzJUU3JUI0JUEwLWkuamF2YQ==">496.下一个更大元素 I<i class="fa fa-external-link-alt"></i></span> &amp;emsp;<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9uZXh0LWdyZWF0ZXItZWxlbWVudC1pLw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/22/ed461f444ea0ada1.png"></p>
<p>题目说 <code>nums1</code> 是 <code>nums2</code> 的子集，那么先把 <code>nums2</code> 中每个元素的下一个更大元素算出来存到一个映射里，然后再让 <code>nums1</code> 中的元素去查表即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="comment">// 记录 nums2 中每个元素的下一个更大元素</span></span><br><span class="line">    <span class="type">int</span>[] greater = nextGreaterElement(nums2);</span><br><span class="line">    <span class="comment">// 转化成映射：元素 x -&gt; x 的下一个最大元素</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; greaterMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums2.length; i++) &#123;</span><br><span class="line">        greaterMap.put(nums2[i], greater[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// nums1 是 nums2 的子集，所以根据 greaterMap 可以得到结果</span></span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">        res[i] = greaterMap.get(nums1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="comment">// 见上文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，对于下一个更大或相等的元素可以将 while 判断中将 <code>&lt;=</code> 改为 <code>&lt;</code> 即可；对于下一个更小的元素将 while 中 <code>&lt;=</code> 改为 <code>&gt;=</code>；对于下一个更小或相等的元素可以改为 <code>&gt;</code>。</p>
<p>若需寻找上一个，注意之前的 for 循环都是从数组的尾部开始往栈里添加元素，这样栈顶元素就是 <code>nums[i]</code> 之后的元素。所以只要我们<strong>从数组的头部开始</strong>往栈里添加元素，栈顶的元素就是 <code>nums[i]</code> 之前的元素，即可计算 <code>nums[i]</code> 的上一个更大元素。</p>
</br>

<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9EUy83MzkuJUU2JUFGJThGJUU2JTk3JUE1JUU2JUI4JUE5JUU1JUJBJUE2LmphdmE=">739.每日温度<i class="fa fa-external-link-alt"></i></span> &amp;emsp;<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kYWlseS10ZW1wZXJhdHVyZXMv">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/22/608e329dffe43942.png"></p>
<p>这里让求的是当前元素距离下一个更大元素的索引距离，对模版进行修改即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> temperatures.length;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="comment">// 存放元素索引，而不是元素</span></span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; temperatures[stack.peek()] &lt;= temperatures[i]) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        res[i] = stack.isEmpty() ? <span class="number">0</span> : (stack.peek() - i);</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h3 id="处理环形数组"><a href="#处理环形数组" class="headerlink" title="处理环形数组"></a>处理环形数组</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9EUy81MDMuJUU0JUI4JThCJUU0JUI4JTgwJUU0JUI4JUFBJUU2JTlCJUI0JUU1JUE0JUE3JUU1JTg1JTgzJUU3JUI0JUEwLWlpLmphdmE=">503.下一个更大元素 II<i class="fa fa-external-link-alt"></i></span> &amp;emsp;<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9uZXh0LWdyZWF0ZXItZWxlbWVudC1paS8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/22/2f04aa61fc3195cd.png"></p>
<p>输入一个「环形数组」，计算其中每个元素的下一个更大元素。比如输入 <code>[2,1,2,4,3]</code>，应该返回 <code>[4,2,4,-1,4]</code>，因为拥有了环形属性，最后一个元素 3 绕了一圈后找到了比自己大的元素 4。</p>
<p>我们一般是通过 <code>%</code> 运算符求模来模拟环形特效：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length, index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 在环形数组中转圈</span></span><br><span class="line">    print(arr[index % n]);</span><br><span class="line">    index++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如输入是 [2,1,2,4,3]，对于最后一个元素 3，如何找到元素 4 作为下一个更大元素。对于这种需求，常用套路就是将数组长度翻倍：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/22/322a026beeb1b1a5.png"></p>
<p>这样，元素 3 就可以找到元素 4 作为下一个更大元素了，而且其他的元素都可以被正确地计算。</p>
<p>有了思路，最简单的实现方式当然可以把这个双倍长度的数组构造出来，然后套用算法模板。但是也可以不用构造新数组，而是利用循环数组的技巧来模拟数组长度翻倍的效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElements(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组长度加倍模拟环形数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span> * n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 索引 i 要求模</span></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek() &lt;= nums[i % n]) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        res[i % n] = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">        stack.push(nums[i % n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>Buy me a coffee</div>
  <button onclick="document.querySelector('.post-reward').classList.toggle('active');">
    Donate
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="Ssssv11 WeChat Pay">
        <span>WeChat Pay</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"><i class="fa fa-tag"></i> 算法</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/05/18/JUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7/" rel="prev" title="JUC并发工具">
                  <i class="fa fa-chevron-left"></i> JUC并发工具
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ssssv</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script size="90" alpha="0.6" zIndex="-1" src="/js/ribbon/ribbon.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="/js/local-search.js"></script>






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>

<script src="/js/cursor/fireworks.js"></script>

