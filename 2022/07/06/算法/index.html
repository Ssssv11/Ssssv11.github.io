<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="baidu-site-verification" content="code-jbS6cVmQ2r">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.lug.ustc.edu.cn/css?family=Helvetica:300,300italic,400,400italic,700,700italic%7CMenlo:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ssssv11.github.io","root":"/","images":"/images","scheme":"Pisces","version":"8.2.2","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="LeetCode 刷题笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="算法笔记">
<meta property="og:url" content="https://ssssv11.github.io/2022/07/06/%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Ssssv">
<meta property="og:description" content="LeetCode 刷题笔记">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/11/j6jdt1.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/11/j6jN79.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/11/j6jakR.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/11/j6jt0J.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/11/j6jYm4.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/11/j6jBp6.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/11/j6jwfx.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/12/jgopFK.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/12/jgo9JO.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/12/jgoiSe.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/12/jgIxdx.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/12/jgIzo6.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/12/jgoCWD.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/12/jgoFQH.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/12/jgokyd.png">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/12/jgoAOA.png">
<meta property="og:image" content="https://files.catbox.moe/6eu9q1.png#crop=0&crop=0&crop=1&crop=1&id=YBUqQ&originHeight=1228&originWidth=1468&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://files.catbox.moe/dhbbub.png#crop=0&crop=0&crop=1&crop=1&id=YOt8K&originHeight=1234&originWidth=1460&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://files.catbox.moe/po3nwl.png#crop=0&crop=0&crop=1&crop=1&id=oeX9v&originHeight=736&originWidth=1142&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://files.catbox.moe/gcezr2.png#crop=0&crop=0&crop=1&crop=1&id=yEZdr&originHeight=768&originWidth=980&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://s2.loli.net/2022/07/14/Q84MnoJvxsPpeZW.png#crop=0&crop=0&crop=1&crop=1&id=xJBUU&originHeight=648&originWidth=1186&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s2.loli.net/2022/07/14/fi5Cq8gJ9banuwZ.png#crop=0&crop=0&crop=1&crop=1&id=QFF7q&originHeight=1020&originWidth=1450&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/14/jfM4Xt.png#crop=0&crop=0&crop=1&crop=1&id=VIdLS&originHeight=1110&originWidth=1462&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/14/jflmxs.png#crop=0&crop=0&crop=1&crop=1&id=hSuJi&originHeight=1116&originWidth=1468&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/14/jf1o0x.png#crop=0&crop=0&crop=1&crop=1&id=S0eJz&originHeight=1372&originWidth=1460&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/14/jf83If.png#crop=0&crop=0&crop=1&crop=1&id=Kb7Jh&originHeight=1262&originWidth=1462&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/14/jfY2Qg.png#crop=0&crop=0&crop=1&crop=1&id=y52JL&originHeight=1192&originWidth=1432&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/14/jftTHA.png#crop=0&crop=0&crop=1&crop=1&id=bHZZT&originHeight=335&originWidth=640&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/14/jftoBd.png#crop=0&crop=0&crop=1&crop=1&id=Ntqko&originHeight=181&originWidth=397&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/16/j4XVQs.jpg#crop=0&crop=0&crop=1&crop=1&id=p1vFh&originHeight=301&originWidth=423&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://s1.ax1x.com/2022/07/16/j4ji0x.png#crop=0&crop=0&crop=1&crop=1&id=Zu0Z5&originHeight=718&originWidth=1194&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/16/ce98179a2c5048b1.png#crop=0&crop=0&crop=1&crop=1&id=HkyLU&originHeight=301&originWidth=423&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://i.bmp.ovh/imgs/2022/07/16/93d0535f299a3f84.png#crop=0&crop=0&crop=1&crop=1&id=llY6T&originHeight=1152&originWidth=1438&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://i.bmp.ovh/imgs/2022/07/16/fc7f1a7787d947d1.png#crop=0&crop=0&crop=1&crop=1&id=WCmtw&originHeight=770&originWidth=1462&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://i.bmp.ovh/imgs/2022/07/16/d982dfeffc93194d.png#crop=0&crop=0&crop=1&crop=1&id=X0XWi&originHeight=746&originWidth=1450&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://i.bmp.ovh/imgs/2022/07/16/c72d2bb208786b4d.png#crop=0&crop=0&crop=1&crop=1&id=n6sqn&originHeight=674&originWidth=1494&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://i.bmp.ovh/imgs/2022/07/17/8cff726790465c70.png#crop=0&crop=0&crop=1&crop=1&id=pgD7S&originHeight=922&originWidth=960&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://i.bmp.ovh/imgs/2022/07/17/f70c199ad17d839d.png#crop=0&crop=0&crop=1&crop=1&id=oQkMq&originHeight=642&originWidth=1114&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://i.bmp.ovh/imgs/2022/07/17/9009c2c644e1cb1e.png#crop=0&crop=0&crop=1&crop=1&id=Yrwd3&originHeight=1360&originWidth=1432&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://i.bmp.ovh/imgs/2022/07/17/0bf7a7e4dcfa0edf.png#crop=0&crop=0&crop=1&crop=1&id=hFvS5&originHeight=1110&originWidth=1460&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://i.bmp.ovh/imgs/2022/07/17/f728d0b913a522eb.png#crop=0&crop=0&crop=1&crop=1&id=dQJAc&originHeight=744&originWidth=854&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/17/c0dc0dfc657d0867.png#crop=0&crop=0&crop=1&crop=1&id=ojq3K&originHeight=736&originWidth=840&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/17/a63c386fe86d030e.png#crop=0&crop=0&crop=1&crop=1&id=WIHzU&originHeight=310&originWidth=916&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/17/e4470285be9e73a5.png#crop=0&crop=0&crop=1&crop=1&id=zgTLF&originHeight=862&originWidth=2188&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/17/84fc607aef987b2c.png#crop=0&crop=0&crop=1&crop=1&id=q8s6Z&originHeight=928&originWidth=2192&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/17/ce502110e6817313.png#crop=0&crop=0&crop=1&crop=1&id=ike3X&originHeight=1028&originWidth=1226&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/17/6d93bfc2a8d5292c.png#crop=0&crop=0&crop=1&crop=1&id=mJjPQ&originHeight=366&originWidth=1458&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/17/b74a073b1f32239f.png#crop=0&crop=0&crop=1&crop=1&id=wnIQO&originHeight=1068&originWidth=1460&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/17/d9305aef676d77d3.png#crop=0&crop=0&crop=1&crop=1&id=rzot8&originHeight=1146&originWidth=1432&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/17/55715f2b73aa74f7.png#crop=0&crop=0&crop=1&crop=1&id=HvjrS&originHeight=696&originWidth=1070&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/07/17/6c03e9cdcc2194b5.png#crop=0&crop=0&crop=1&crop=1&id=nHKU5&originHeight=688&originWidth=1442&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title=">
<meta property="article:published_time" content="2022-07-06T08:26:01.683Z">
<meta property="article:modified_time" content="2022-07-17T08:30:25.300Z">
<meta property="article:author" content="Ssssv11">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s1.ax1x.com/2022/07/11/j6jdt1.png">


<link rel="canonical" href="https://ssssv11.github.io/2022/07/06/%E7%AE%97%E6%B3%95/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>
<title>算法笔记 | Ssssv</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Ssssv</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">26</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">43</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">2.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C%E3%80%81%E5%89%8D%E7%BC%80%E7%A7%AF"><span class="nav-number">2.1.</span> <span class="nav-text">前缀和、前缀积</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84"><span class="nav-number">2.2.</span> <span class="nav-text">差分数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">2.3.</span> <span class="nav-text">双指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="nav-number">2.3.1.</span> <span class="nav-text">快慢指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A6%E5%8F%B3%E6%8C%87%E9%92%88"><span class="nav-number">2.3.2.</span> <span class="nav-text">左右指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86%E9%97%AE%E9%A2%98"><span class="nav-number">2.4.</span> <span class="nav-text">二维数组的遍历问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-number">2.5.</span> <span class="nav-text">滑动窗口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">2.6.</span> <span class="nav-text">二分查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E4%B8%80%E4%B8%AA%E6%95%B0"><span class="nav-number">2.6.1.</span> <span class="nav-text">查找一个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E8%BE%B9%E7%95%8C%E7%9A%84%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2"><span class="nav-number">2.6.2.</span> <span class="nav-text">寻找边界的二分搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E9%97%AE%E9%A2%98%E7%9A%84%E6%B3%9B%E5%8C%96"><span class="nav-number">2.6.3.</span> <span class="nav-text">二分查找问题的泛化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">3.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88-1"><span class="nav-number">3.1.</span> <span class="nav-text">双指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E3%80%81%E5%88%86%E8%A7%A3%E9%93%BE%E8%A1%A8"><span class="nav-number">3.1.1.</span> <span class="nav-text">合并、分解链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">3.1.2.</span> <span class="nav-text">单链表的倒数第 k 个节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E7%82%B9"><span class="nav-number">3.1.3.</span> <span class="nav-text">单链表的中点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E7%8E%AF"><span class="nav-number">3.1.4.</span> <span class="nav-text">判断链表是否包含环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4"><span class="nav-number">3.1.5.</span> <span class="nav-text">两个链表是否相交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">3.1.6.</span> <span class="nav-text">反转链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="nav-number">3.1.7.</span> <span class="nav-text">回文链表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">4.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%B2%E9%A2%86"><span class="nav-number">5.1.</span> <span class="nav-text">纲领</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF"><span class="nav-number">5.2.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.3.</span> <span class="nav-text">构造二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">5.4.</span> <span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">5.5.</span> <span class="nav-text">二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%80%A7"><span class="nav-number">5.5.1.</span> <span class="nav-text">特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C"><span class="nav-number">5.5.2.</span> <span class="nav-text">基础操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0"><span class="nav-number">5.5.3.</span> <span class="nav-text">构造</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">5.6.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">5.7.</span> <span class="nav-text">最近公共祖先</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="nav-number">5.7.1.</span> <span class="nav-text">寻找一个元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">5.7.2.</span> <span class="nav-text">二叉树的最近公共祖先</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0"><span class="nav-number">5.8.</span> <span class="nav-text">完全二叉树的节点数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE"><span class="nav-number">6.</span> <span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E5%92%8C%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.1.</span> <span class="nav-text">图的逻辑结构和具体实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">6.2.</span> <span class="nav-text">图的遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">6.3.</span> <span class="nav-text">拓扑排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95-DFS"><span class="nav-number">6.3.1.</span> <span class="nav-text">环检测算法(DFS)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-DFS"><span class="nav-number">6.3.2.</span> <span class="nav-text">拓扑排序算法(DFS)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95-BFS"><span class="nav-number">6.3.3.</span> <span class="nav-text">环检测算法(BFS)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-BFS"><span class="nav-number">6.3.4.</span> <span class="nav-text">拓扑排序(BFS)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE%E5%88%A4%E5%AE%9A"><span class="nav-number">6.4.</span> <span class="nav-text">二分图判定</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE%E7%AE%80%E4%BB%8B"><span class="nav-number">6.4.1.</span> <span class="nav-text">二分图简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE%E5%88%A4%E5%AE%9A%E6%80%9D%E8%B7%AF"><span class="nav-number">6.4.2.</span> <span class="nav-text">二分图判定思路</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86-UNION-FIND-%E7%AE%97%E6%B3%95"><span class="nav-number">6.5.</span> <span class="nav-text">并查集(UNION-FIND)算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="nav-number">6.5.1.</span> <span class="nav-text">基本思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E6%80%A7%E4%BC%98%E5%8C%96"><span class="nav-number">6.5.2.</span> <span class="nav-text">平衡性优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9"><span class="nav-number">6.5.3.</span> <span class="nav-text">路径压缩</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ssssv11"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">Ssssv11</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTE=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Ssssv11"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ssssv11.github.io/2022/07/06/%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="Ssssv11">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ssssv">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          算法笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-07-06 16:26:01" itemprop="dateCreated datePublished" datetime="2022-07-06T16:26:01+08:00">2022-07-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-07-17 16:30:25" itemprop="dateModified" datetime="2022-07-17T16:30:25+08:00">2022-07-17</time>
      </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <center>LeetCode 刷题笔记</center>

<span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>算法学习的记录，LeetCode 刷题中…</p>
<p>感谢 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xhYnVsYWRvbmcvZnVja2luZy1hbGdvcml0aG0=">Labuladong<i class="fa fa-external-link-alt"></i></span> 、<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lvdW5neWFuZ3lhbmcwNC9sZWV0Y29kZS1tYXN0ZXI=">Carl<i class="fa fa-external-link-alt"></i></span> 等大佬免费的学习资料</p>
<p>Github: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZQ==">https://github.com/Ssssv11/AlgorithmNote<i class="fa fa-external-link-alt"></i></span></p>
<p>Gitee : <span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vU3Nzc3YxMS9BbGdvcml0aG1Ob3Rl">https://gitee.com/Ssssv11/AlgorithmNote<i class="fa fa-external-link-alt"></i></span></p>
<p>Blog : <a href="https://ssssv11.github.io/2022/07/06/%E7%AE%97%E6%B3%95/">https://ssssv11.github.io/2022/07/06/%E7%AE%97%E6%B3%95/</a></p>
</br>


<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="前缀和、前缀积"><a href="#前缀和、前缀积" class="headerlink" title="前缀和、前缀积"></a>前缀和、前缀积</h2><p><strong>前缀和技巧适用于快速、频繁地计算一个索引区间内的元素之和，它不会修改原始数组。</strong></p>
<p>核⼼思路是创建⼀个数组 <code>preSum</code>， <code>preSum[i]</code> 记录 <code>nums[0..i-1]</code> 的累加和(<code>preSum[0] = 0</code>)。若需要计算某个索引区间 <code>[i, j]</code> 内的元素之和，只需要计算 <code>preSum[j+1] - preSum[i]</code> 的值即可。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8zMDMuJUU1JThDJUJBJUU1JTlGJTlGJUU1JTkyJThDJUU2JUEzJTgwJUU3JUI0JUEyLSVFNiU5NSVCMCVFNyVCQiU4NCVFNCVCOCU4RCVFNSU4RiVBRiVFNSU4RiU5OC5qYXZh">303.区域和检索-数组不可变<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yYW5nZS1zdW0tcXVlcnktaW1tdXRhYmxlLw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8zMDQuJUU0JUJBJThDJUU3JUJCJUI0JUU1JThDJUJBJUU1JTlGJTlGJUU1JTkyJThDJUU2JUEzJTgwJUU3JUI0JUEyLSVFNyU5RiVBOSVFOSU5OCVCNSVFNCVCOCU4RCVFNSU4RiVBRiVFNSU4RiU5OC5qYXZh">304.二维区域和检索-矩阵不可变<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yYW5nZS1zdW0tcXVlcnktMmQtaW1tdXRhYmxlLw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<blockquote>
<p>具体解释见代码内注释</p>
</blockquote>
<p>这两道基础题分别从一维和二维层面运用前缀和来解决问题。主要需要弄清楚该计算从哪儿到哪儿的和以及其中任意索引区间内的元素之和该如何表示。<br />若使用前缀和(积)方法且前缀和(积)数组为了方便计算而将首位置为0(或1)，则需要时刻注意其起始索引为 1。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8yMzguJUU5JTk5JUE0JUU4JTg3JUFBJUU4JUJBJUFCJUU0JUJCJUE1JUU1JUE0JTk2JUU2JTk1JUIwJUU3JUJCJTg0JUU3JTlBJTg0JUU0JUI5JTk4JUU3JUE3JUFGLmphdmE=">238.除自身以外数组的乘积<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wcm9kdWN0LW9mLWFycmF5LWV4Y2VwdC1zZWxmLw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8xMzUyLiVFNiU5QyU4MCVFNSU5MCU4RS1rLSVFNCVCOCVBQSVFNiU5NSVCMCVFNyU5QSU4NCVFNCVCOSU5OCVFNyVBNyVBRi5qYXZh">1352.最后-k-个数的乘积<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wcm9kdWN0LW9mLXRoZS1sYXN0LWstbnVtYmVycy8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>与前缀和思想相似，这两道求积的问题也可以通过先求前缀积再根据具体情况考虑特殊之处。如 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8yMzguJUU5JTk5JUE0JUU4JTg3JUFBJUU4JUJBJUFCJUU0JUJCJUE1JUU1JUE0JTk2JUU2JTk1JUIwJUU3JUJCJTg0JUU3JTlBJTg0JUU0JUI5JTk4JUU3JUE3JUFGLmphdmE=">#238<i class="fa fa-external-link-alt"></i></span> 可以使用 <em>前缀积+后缀积</em> 的方式来实现不使用除法解答；<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8xMzUyLiVFNiU5QyU4MCVFNSU5MCU4RS1rLSVFNCVCOCVBQSVFNiU5NSVCMCVFNyU5QSU4NCVFNCVCOSU5OCVFNyVBNyVBRi5qYXZh">#1352<i class="fa fa-external-link-alt"></i></span> 需要在插入 0 后清空当前前缀积重新开始计算。</p>
</br>


<h2 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h2><p><strong>差分数组的主要适⽤场景是频繁对原始数组的某个区间的元素进⾏增减。</strong><br />若需要对数组 <code>nums[i..j]</code> 全部加 1，再给 <code>nums[k..l]</code> 全部减 2 等等一系列增减操作，最后返回增减后的数组。常规思路就是使用 for 循环对指定区间内的元素进行加减，但这样对 <code>nums</code> 的修改非常频繁且效率低下，时间复杂度为 <code>O(N)</code>。<br />使用差分数组与前缀和构造的 <code>preSum</code> 数组相似，可以为 <code>nums</code> 数组构造⼀个差分数组 <code>diff</code>， <code>diff[i]</code> 就是 <code>nums[i]</code> 和 <code>nums[i-1]</code> 的差：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nums[] = &#123;5, 7, 9, 2, 3&#125;</span></span><br><span class="line"><span class="comment">// diff[] = &#123;5, 2, 2, -7, 1&#125;</span></span><br><span class="line"><span class="type">int</span>[] diff = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line"><span class="comment">// 构造差分数组</span></span><br><span class="line">diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，如果需要通过 <code>diff</code> 数组构造结果数组 <code>nums</code>，只需要:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[diff.length];</span><br><span class="line"><span class="comment">// 根据差分数组构造结果数组</span></span><br><span class="line">res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; diff.length; i++) &#123;</span><br><span class="line">    res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过构造差分数组 <code>diff</code> 就可以快速地对指定区间内的元素进行增减操作。如果需要将区间 <code>nums[i..j]</code> 内的元素全部加 2，那么只需要让 <code>diff[i] += 2</code>，然后再让 <code>diff[j+1] -= 2</code> 即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nums[] = &#123;5, 7, 9, 2, 3&#125;</span></span><br><span class="line"><span class="comment">// diff[] = &#123;5, 4, 2, -7, -1&#125;</span></span><br><span class="line">                i      j</span><br><span class="line"><span class="comment">// res[] = &#123;5, 9, 11, 4, 3&#125;</span></span><br></pre></td></tr></table></figure>

<p>这是因为 <code>diff[i] += 2</code> 后就相当于为 <code>nums[i..]</code> 的所有元素都进行了加 2 操作，<code>diff[j+1] -= 2</code> 就相当于为 <code>nums[j+1..]</code> 的所有元素进行了减 2 操作，因此这样就相当于只对区间 <code>nums[i..j]</code> 进行了加 2 操作。<br />只需要花费 <code>O(1)</code> 的时间修改 <code>diff</code> 数组，就给 <code>nums</code> 的整个区间做了修改。多次修改 <code>diff</code> 后再通过计算就可以得到 <code>nums</code> 修改后的结果。</p>
<hr>
<p>考虑到差分数组代码的复用性，可以将其抽象为一个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Diff</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] diff;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create the diff array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Diff</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">assert</span> nums.length &gt; <span class="number">0</span>;</span><br><span class="line">        diff = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        diff[i] += val;</span><br><span class="line">        <span class="comment">// 若 j+1 &lt; diff.length 则表示修改是从 i 到最后</span></span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt; diff.length) &#123;</span><br><span class="line">            diff[j + <span class="number">1</span>] -= val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the result of the origin array by diff[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] result() &#123;</span><br><span class="line">        <span class="type">int</span> res[] = <span class="keyword">new</span> <span class="title class_">int</span>[diff.length];</span><br><span class="line">        res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; diff.length; i++) &#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8zNzAuJUU1JThDJUJBJUU5JTk3JUI0JUU1JThBJUEwJUU2JUIzJTk1LmphdmE=">370.区间加法<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yYW5nZS1hZGRpdGlvbi8=">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8xMTA5LiVFOCU4OCVBQSVFNyU4RiVBRCVFOSVBMiU4NCVFOCVBRSVBMiVFNyVCQiU5RiVFOCVBRSVBMS5qYXZh">1109.航班预订统计<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3Jwb3JhdGUtZmxpZ2h0LWJvb2tpbmdzLw==">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8xMDk0LiVFNiU4QiVCQyVFOCVCRCVBNi5qYXZh">1094.拼车<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jYXItcG9vbGluZy8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>这三道题都是典型的需要使用差分数组进行解答的题目，可以抽象出一个 <code>Diff</code> 差分数组工具类来提升代码的复用性。需要注意在初始化 <code>nums[]</code> 时其长度的选择：进行增减操作次数的最大值。</p>
</br>


<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p><strong>双指针技巧主要分为两类：左右指针和快慢指针。</strong></p>
<ul>
<li>左右指针：两个指针相向而行或者相背而行，一左一右。</li>
<li>快慢指针：两个指针同向而行，一快一慢。</li>
</ul>
<p>在数组中并没有真正意义上的指针，但可以把索引当做数组中的指针，这样也可以在数组中施展双指针技巧。</p>
</br>

<h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p><strong>快慢指针常用在数组问题中要求原地修改数组。</strong></p>
<p>原地修改即不允许 <code>new</code> 新数组，只能在原数组上操作，返回一个长度，通过返回的长度和原始数组得到结果。<br />快慢指针通过慢指针指向需要修改的元素，快指针遍历数组，当快指针找到符合条件的元素时，将慢指针指向的元素修改为新值，然后慢指针向后移动一位，快指针向后移动一位，继续遍历。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8yNi4lRTUlODglQTAlRTklOTklQTQlRTYlOUMlODklRTUlQkElOEYlRTYlOTUlQjAlRTclQkIlODQlRTQlQjglQUQlRTclOUElODQlRTklODclOEQlRTUlQTQlOEQlRTklQTElQjkuamF2YQ==">26.删除有序数组中的重复项<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtZHVwbGljYXRlcy1mcm9tLXNvcnRlZC1odHRwczovL2dpdGh1Yi5jb20vU3Nzc3YxMS9BbGdvcml0aG1Ob3RlL2Jsb2IvbWFzdGVyL0FycmF5Lw==">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8yNy4lRTclQTclQkIlRTklOTklQTQlRTUlODUlODMlRTclQjQlQTAuamF2YQ==">27.移除元素<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtZWxlbWVudC8=">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8yODMuJUU3JUE3JUJCJUU1JThBJUE4JUU5JTlCJUI2LmphdmE=">283.移动零<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tb3ZlLXplcm9lcy8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>这三道题非常相似，都使用快慢指针来实现原地修改。</p>
<br>


<h3 id="左右指针"><a href="#左右指针" class="headerlink" title="左右指针"></a>左右指针</h3><p><strong>左右指针常用在有序数组和字符串问题中。</strong></p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS81LiVFNiU5QyU4MCVFOSU5NSVCRiVFNSU5QiU5RSVFNiU5NiU4NyVFNSVBRCU5MCVFNCVCOCVCMi5qYXZh">5.最长回文子串<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXBhbGluZHJvbWljLXN1YnN0cmluZy8=">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8xMjUuJUU5JUFBJThDJUU4JUFGJTgxJUU1JTlCJTlFJUU2JTk2JTg3JUU0JUI4JUIyLmphdmE=">125.验证回文串<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZC1wYWxpbmRyb21lLw==">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8xNjcuJUU0JUI4JUE0JUU2JTk1JUIwJUU0JUI5JThCJUU1JTkyJThDLWlpLSVFOCVCRSU5MyVFNSU4NSVBNSVFNiU5QyU4OSVFNSVCQSU4RiVFNiU5NSVCMCVFNyVCQiU4NC5qYXZh">167.两数之和 II - 输入有序数组<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90d28tc3VtLWlpLWlucHV0LWFycmF5LWlzLXNvcnRlZC8=">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8zNDQuJUU1JThGJThEJUU4JUJEJUFDJUU1JUFEJTk3JUU3JUFDJUE2JUU0JUI4JUIyLmphdmE=">344.反转字符串<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLXN0cmluZy8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>左右指针比较简单，根据题意进行相应操作即可。在二分查找中也有体现左右指针的特性。</p>
<br>


<h2 id="二维数组的遍历问题"><a href="#二维数组的遍历问题" class="headerlink" title="二维数组的遍历问题"></a>二维数组的遍历问题</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS80OC4lRTYlOTclOEIlRTglQkQlQUMlRTUlOUIlQkUlRTUlODMlOEYuamF2YQ==">48.旋转图像<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yb3RhdGUtaW1hZ2Uv">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS81NC4lRTglOUUlQkElRTYlOTclOEIlRTclOUYlQTklRTklOTglQjUuamF2YQ==">54.螺旋矩阵<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zcGlyYWwtbWF0cml4Lw==">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS81OS4lRTglOUUlQkElRTYlOTclOEIlRTclOUYlQTklRTklOTglQjUtaWkuamF2YQ==">59.螺旋矩阵 II<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zcGlyYWwtbWF0cml4LWlpLw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>对于矩阵的各种遍历需要多归纳总结规律，如矩阵的逆时针旋转可以按副对角线进行镜像对称，这与 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS80OC4lRTYlOTclOEIlRTglQkQlQUMlRTUlOUIlQkUlRTUlODMlOEYuamF2YQ==">#48<i class="fa fa-external-link-alt"></i></span> 题相反。</p>
</br>


<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p><strong>滑动窗口常用于解决子串问题。</strong></p>
<p>滑动窗口也是利用双指针来实现的，一个用于延伸现有窗口的 <code>right</code> 指针，和一个用于收缩窗口的 <code>left</code> 指针。在任意时刻，只有一个指针运动，而另一个保持静止。</p>
<hr>
<p>对于解决滑动窗口问题的代码框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> String <span class="title function_">slidingWindow</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    HashMap&lt;Character, Integer&gt; window = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 左右指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.length()) &#123;</span><br><span class="line">        <span class="comment">// 移入窗口的字符</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">        <span class="comment">// 扩大窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 数据操作</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// debug 输出</span></span><br><span class="line">        System.out.println(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左窗口是否需要收缩</span></span><br><span class="line">        <span class="keyword">while</span>(window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// 移出窗口的字符</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">            <span class="comment">// 收缩窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 数据操作</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中两处 <code>...</code> 表示的更新窗口数据的地方</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS83Ni4lRTYlOUMlODAlRTUlQjAlOEYlRTglQTYlODYlRTclOUIlOTYlRTUlQUQlOTAlRTQlQjglQjIuamF2YQ==">76.最小覆盖子串<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLXdpbmRvdy1zdWJzdHJpbmcv">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS80MzguJUU2JTg5JUJFJUU1JTg4JUIwJUU1JUFEJTk3JUU3JUFDJUE2JUU0JUI4JUIyJUU0JUI4JUFEJUU2JTg5JTgwJUU2JTlDJTg5JUU1JUFEJTk3JUU2JUFGJThEJUU1JUJDJTgyJUU0JUJEJThEJUU4JUFGJThELmphdmE=">438.找到字符串中所有字母异位词<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWFsbC1hbmFncmFtcy1pbi1hLXN0cmluZy8=">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS81NjcuJUU1JUFEJTk3JUU3JUFDJUE2JUU0JUI4JUIyJUU3JTlBJTg0JUU2JThFJTkyJUU1JTg4JTk3LmphdmE=">567.字符串的排列<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wZXJtdXRhdGlvbi1pbi1zdHJpbmcv">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>通过滑动窗口的代码框架可以很容易地写出这三题，思路都基本相似。主要需要考虑三个问题：</p>
<ol>
<li>什么时候应该扩大窗口？ </li>
<li>什么时候应该缩小窗口？ </li>
<li>什么时候得到一个合法的答案？</li>
</ol>
<br>


<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</p>
<hr>
<p>二分查找代码框架（<strong>在有序数组中搜索指定元素</strong>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = ...;</span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8yNzguJUU3JUFDJUFDJUU0JUI4JTgwJUU0JUI4JUFBJUU5JTk0JTk5JUU4JUFGJUFGJUU3JTlBJTg0JUU3JTg5JTg4JUU2JTlDJUFDLmphdmE=">278.第一个错误的版本<i class="fa fa-external-link-alt"></i></span> &amp;emsp;<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maXJzdC1iYWQtdmVyc2lvbi8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>分析二分查找的一个技巧是：不要出现 <code>else</code>，而是把所有情况用 <code>else if</code> 写清楚，这样可以清楚地展现所有细节。</p>
<p>其中 <code>...</code> 标记的部分，就是可能出现细节问题的地方，当见到一个二分查找的代码时，首先注意这几个地方。</p>
<p><strong>计算 <code>mid</code> 时需要防止溢出，代码中 <code>left + (right - left) / 2</code>与 <code>(left + right) / 2</code> 等价，但是有效防止了 <code>left</code> 和 <code>right</code> 太大，直接相加导致溢出的情况。</strong></p>
<br>


<h3 id="查找一个数"><a href="#查找一个数" class="headerlink" title="查找一个数"></a>查找一个数</h3><p>二分查找最普通的用法，即搜索一个数，如果存在，返回其索引，否则返回 -1。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS83MDQuJUU0JUJBJThDJUU1JTg4JTg2JUU2JTlGJUE1JUU2JTg5JUJFLmphdmE=">704.二分查找<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktc2VhcmNoLw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>代码中的细节：</p>
<ol>
<li>为什么 while 循环的条件中是 &lt;&#x3D;，而不是 &lt; ？</li>
</ol>
<p>因为初始化 <code>right</code> 时赋值为 <code>nums.length - 1</code>，即最后一个元素的索引，而不是 <code>nums.length</code>。</p>
<p>这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 <code>[left, right]</code>，后者相当于左闭右开区间 [<code>left, right)</code>（索引大小为 <code>nums.length</code> 越界）。</p>
<p>这里使用的是前者 <code>[left, right]</code> 闭区间。这个区间就是每次进行搜索的区间。</p>
<p>而 <code>while(left &lt;= right)</code> 的终止条件是 <code>left == right + 1</code>，即 <code>[right + 1, right]</code>，这时区间为空。所以 while 循环终止是正确的，直接返回 -1。</p>
<p><code>while(left &lt; right)</code> 的终止条件是 <code>left == right</code>，即 <code>[right, right]</code>，区间中还有 <code>right</code>，但此时 while 循环终止了。也就是说此时区间中索引 <code>right</code> 没有被搜索，如果这时候直接返回 -1 就是错误的。</p>
<p>若需使用 <code>while(left &lt; right)</code>，也可以在返回时再次搜索 <code>right</code> 处值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>为什么 <code>left = mid + 1</code>，<code>right = mid - 1</code> ？</li>
</ol>
<p>当查到 <code>mid &gt; target</code> 时，说明 <code>target</code> 在 <code>mid</code> 右边，所以 <code>left = mid + 1</code>，即搜索右半部分。同理，当查到 <code>mid &lt; target</code> 时，说明 <code>target</code> 在 <code>mid</code> 左边，所以 <code>right = mid - 1</code>，即搜索左半部分。</p>
<ol start="3">
<li>此算法的缺陷 ？</li>
</ol>
<p>如有序数组 <code>nums = [1,2,2,2,3]</code>，<code>target</code> 为 2，此算法返回的索引为 2。但如果想得到 <code>target</code> 的左侧边界，即索引 1，或者 <code>target</code> 的右侧边界，即索引 3 的话此算法是无法处理的。</p>
<p>但是如果当找到一个 <code>target</code>，然后向左或向右线性搜索又难以保证二分查找对数级的复杂度。</p>
<br>


<h3 id="寻找边界的二分搜索"><a href="#寻找边界的二分搜索" class="headerlink" title="寻找边界的二分搜索"></a>寻找边界的二分搜索</h3><p>对普通二分查找算法稍加改动就可以实现寻找边界的二分查找。重点是在查找到 <code>target</code> 时并不马上返回，而是继续缩小范围继续查找左边或右边是否还有 <code>target。</code></p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8zNC4lRTUlOUMlQTglRTYlOEUlOTIlRTUlQkElOEYlRTYlOTUlQjAlRTclQkIlODQlRTQlQjglQUQlRTYlOUYlQTUlRTYlODklQkUlRTUlODUlODMlRTclQjQlQTAlRTclOUElODQlRTclQUMlQUMlRTQlQjglODAlRTQlQjglQUElRTUlOTIlOEMlRTYlOUMlODAlRTUlOTAlOEUlRTQlQjglODAlRTQlQjglQUElRTQlQkQlOEQlRTclQkQlQUUuamF2YQ==">34.在排序数组中查找元素的第一个和最后一个位置<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWZpcnN0LWFuZC1sYXN0LXBvc2l0aW9uLW9mLWVsZW1lbnQtaW4tc29ydGVkLWh0dHBzOi8vZ2l0aHViLmNvbS9Tc3NzdjExL0FsZ29yaXRobU5vdGUvYmxvYi9tYXN0ZXIvQXJyYXkv">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><strong>二分思维的精髓就是：通过已知信息尽可能多地收缩（折半）搜索空间，从而增加穷举效率，快速找到目标。</strong></p>
<br>


<h3 id="二分查找问题的泛化"><a href="#二分查找问题的泛化" class="headerlink" title="二分查找问题的泛化"></a>二分查找问题的泛化</h3><p>什么问题可以运用二分搜索算法技巧？</p>
<p>首先要从题目中抽象出一个自变量 <code>x</code>，一个关于 <code>x</code> 的函数 <code>f(x)</code>，以及一个目标值 <code>target</code>。</p>
<p>同时，<code>x</code>, <code>f(x)</code>, <code>target</code> 还要满足以下条件：</p>
<ol>
<li><code>f(x)</code> 必须是在 <code>x</code> 上的单调函数。 </li>
<li>题目要求计算满足约束条件 <code>f(x) == target</code> 时的 <code>x</code> 的值。</li>
</ol>
<hr>
<p>二分查找代码框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数 f 是关于自变量 x 的单调函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数，在 f(x) == target 的约束下求 x 的最值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> ...;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> ... + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (f(mid) == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f(mid) &lt; target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f(mid) &gt; target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>...</code> 根据具体业务编写代码。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS84NzUuJUU3JTg4JUIxJUU1JTkwJTgzJUU5JUE2JTk5JUU4JTk1JTg5JUU3JTlBJTg0JUU3JThGJTgyJUU3JThGJTgyLmphdmE=">875.爱吃香蕉的珂珂<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9rb2tvLWVhdGluZy1iYW5hbmFzLw==">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS80MTAuJUU1JTg4JTg2JUU1JTg5JUIyJUU2JTk1JUIwJUU3JUJCJTg0JUU3JTlBJTg0JUU2JTlDJTgwJUU1JUE0JUE3JUU1JTgwJUJDLmphdmE=">410.分割数组的最大值<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zcGxpdC1hcnJheS1sYXJnZXN0LXN1bS8=">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8xMDExLiVFNSU5QyVBOEQlRTUlQTQlQTklRTUlODYlODUlRTklODAlODElRTglQkUlQkUlRTUlOEMlODUlRTglQTMlQjklRTclOUElODQlRTglODMlQkQlRTUlOEElOUIuamF2YQ==">1011.在D天内送达包裹的能力<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jYXBhY2l0eS10by1zaGlwLXBhY2thZ2VzLXdpdGhpbi1kLWRheXMv">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>最重要的是从题目中抽象出满足使用二分查找的自变量 <code>x</code>，以及关于 <code>x</code> 的函数 <code>f(x)</code>，以及目标值 <code>target</code>。其次是考虑如何编写 <code>f(x)</code> 以满足题目需求。</p>
<br>


<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h2><h3 id="合并、分解链表"><a href="#合并、分解链表" class="headerlink" title="合并、分解链表"></a>合并、分解链表</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9MaW5rZWRMaXN0LzIxLiVFNSU5MCU4OCVFNSVCOSVCNiVFNCVCOCVBNCVFNCVCOCVBQSVFNiU5QyU4OSVFNSVCQSU4RiVFOSU5MyVCRSVFOCVBMSVBOC5qYXZh">21.合并两个有序链表<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS10d28tc29ydGVkLWxpc3RzLw==">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9MaW5rZWRMaXN0LzIzLiVFNSU5MCU4OCVFNSVCOSVCNmslRTQlQjglQUElRTUlOEQlODclRTUlQkElOEYlRTklOTMlQkUlRTglQTElQTguamF2YQ==">23.合并k个升序链表<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS1rLXNvcnRlZC1saXN0cy8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>主要是要弄清楚如何找到最小的节点，合并两个有序链表时可以使用双指针来对比哪个更小，合并 k 个时使用优先队列来让更小的节点先出队。</p>
<p>另外，代码中还用到一个链表的算法题中是很常见的<strong>虚拟头结点技巧</strong>，也就是 <code>dummy</code> 节点。如果不使用 <code>dummy</code> 虚拟节点，代码会复杂很多，而有了 <code>dummy</code> 节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9MaW5rZWRMaXN0Lzg2LiVFNSU4OCU4NiVFOSU5QSU5NCVFOSU5MyVCRSVFOCVBMSVBOC5qYXZh">86.分隔链表<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXJ0aXRpb24tbGlzdC8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<br>


<h3 id="单链表的倒数第-k-个节点"><a href="#单链表的倒数第-k-个节点" class="headerlink" title="单链表的倒数第 k 个节点"></a>单链表的倒数第 k 个节点</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9MaW5rZWRMaXN0LzE5LiVFNSU4OCVBMCVFOSU5OSVBNCVFOSU5MyVCRSVFOCVBMSVBOCVFNyU5QSU4NCVFNSU4MCU5MiVFNiU5NSVCMCVFNyVBQyVBQy1uLSVFNCVCOCVBQSVFNyVCQiU5MyVFNyU4MiVCOS5qYXZh">19.删除链表的倒数第n个结点<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtbnRoLW5vZGUtZnJvbS1lbmQtb2YtbGlzdC8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>如何找到链表的倒数第 <code>k</code> 个节点是本题的重点，一般可以先遍历一次计算出链表的长度，第二次遍历删除第 <code>n - k</code> 个节点即可。但这样需要遍历两次链表。若使用两个指针 <code>p1</code>、<code>p2</code>，先让 <code>p1</code> 前进 <code>k</code> 步，再让 <code>p2</code> 与 <code>p1</code> 一起前进，那么当 <code>p1</code> 到达链表末端时 <code>p2</code> 所处的位置就是第 <code>n - k</code> 个节点处，即倒数第 <code>k</code> 个节点处。这样只需要一次遍历就能找到倒数第 <code>k</code> 个节点了。</p>
<br>


<h3 id="单链表的中点"><a href="#单链表的中点" class="headerlink" title="单链表的中点"></a>单链表的中点</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9MaW5rZWRMaXN0Lzg3Ni4lRTklOTMlQkUlRTglQTElQTglRTclOUElODQlRTQlQjglQUQlRTklOTclQjQlRTclQkIlOTMlRTclODIlQjkuamF2YQ==">876.链表的中间结点<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taWRkbGUtb2YtdGhlLWxpbmtlZC1saXN0Lw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>常规方法是先遍历链表得到 <code>n</code>，再遍历一次得到 <code>n / 2</code> 个节点。如果想一次遍历得到中间节点，可以使用<code>快慢指针</code>。让两个指针 <code>slow</code> 和 <code>fast</code> 同时从 <code>head</code> 出发，每当慢指针 <code>slow</code> 前进一步，快指针 <code>fast</code> 就前进两步。这样，当 <code>fast</code> 到达链表末尾时，<code>slow</code> 刚好指向了链表的中点。</p>
<br>


<h3 id="判断链表是否包含环"><a href="#判断链表是否包含环" class="headerlink" title="判断链表是否包含环"></a>判断链表是否包含环</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9MaW5rZWRMaXN0LzE0MS4lRTclOEUlQUYlRTUlQkQlQTIlRTklOTMlQkUlRTglQTElQTguamF2YQ==">141.环形链表<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9saW5rZWQtbGlzdC1jeWNsZS8=">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9MaW5rZWRMaXN0LzE0Mi4lRTclOEUlQUYlRTUlQkQlQTIlRTklOTMlQkUlRTglQTElQTgtSUkuamF2YQ==">142.环形链表 II<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9saW5rZWQtbGlzdC1jeWNsZS1paS8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>判断链表是否有环的问题也需要使用到寻找链表中点的思想。每当慢指针 <code>slow</code> 前进一步，快指针 <code>fast</code> 就前进两步，如果 <code>fast</code> 最终为 <code>null</code>，说明链表中没有环；如果最终 <code>fast</code> 和 <code>slow</code> 相遇，说明链表中有环。</p>
<p>若需要计算环的起点，可以在当快慢指针相遇时，让其中任一个指针指向头节点，然后让它们以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。</p>
<blockquote>
<p>假设指针相遇时，慢指针 <code>slow</code> 走了 <code>k</code> 步，那么快指针 <code>fast</code> 一定走了 <code>2k</code> 步。<code>fast</code> 一定比 <code>slow</code> 多走了 <code>k</code> 步，这多走的 <code>k</code> 步就是 <code>fast</code> 指针在环里转圈，所以 <code>k</code> 的值就是环长度的「整数倍」。<br />假设相遇点距环起点的距离为 <code>m</code>，那么环起点距头结点 <code>head</code> 的距离为 <code>k - m</code>，也就是说如果从 <code>head</code> 前进 <code>k - m</code> 步就能到达环起点。<br />如果从相遇点继续前进 <code>k - m</code> 步，也恰好到达环起点。因为 <code>fast</code> 指针从相遇点开始走 <code>k</code> 步可以转回到相遇点，那走 <code>k - m</code> 步肯定就走到环起点了。<br />所以，只要把快慢指针中的任一个重新指向 <code>head</code>，然后两个指针同速前进，<code>k - m</code> 步后一定会相遇，相遇之处就是环的起点了。</p>
</blockquote>
<br>

<h3 id="两个链表是否相交"><a href="#两个链表是否相交" class="headerlink" title="两个链表是否相交"></a>两个链表是否相交</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9MaW5rZWRMaXN0LzE2MC4lRTclOUIlQjglRTQlQkElQTQlRTklOTMlQkUlRTglQTElQTguamF2YQ==">160.相交链表<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnRlcnNlY3Rpb24tb2YtdHdvLWxpbmtlZC1saXN0cy8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>这个题直接的想法可能是用 <code>HashSet</code> 记录一个链表的所有节点，然后和另一条链表对比，但这就需要额外的空间。</p>
<p>若不使用额外空间而使用双指针 <code>p1</code>、<code>p2</code>，主要需要解决它们分别在两条链表上前进而不能同时走到公共节点，也就无法得到相交节点的问题，即如何让 <code>p1</code> 和 <code>p2</code> 两个指针能够同时到达相交节点。<br />因此可以让 <code>p1</code>、<code>p2</code> 遍历完当前链表后继续遍历对方的链表。这样就相当于两条链表在逻辑上连接在了一起，<code>p1</code>、<code>p2</code> 就可以同时进入相交节点。</p>
<hr>
<p>另外，也可以使两个指针到达尾部的距离相同来保证两个指针能够同时到达相交节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lenA</span> <span class="operator">=</span> <span class="number">0</span>, lenB = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算两条链表的长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> headA; p1 != <span class="literal">null</span>; p1 = p1.next) &#123;</span><br><span class="line">        lenA++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> headB; p2 != <span class="literal">null</span>; p2 = p2.next) &#123;</span><br><span class="line">        lenB++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 让 p1 和 p2 到达尾部的距离相同</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> headA, p2 = headB;</span><br><span class="line">    <span class="keyword">if</span> (lenA &gt; lenB) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lenA - lenB; i++) &#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lenB - lenA; i++) &#123;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 看两个指针是否会相同，p1 == p2 时有两种情况：</span></span><br><span class="line">    <span class="comment">// 1. 两条链表不相交，同时走到尾部空指针</span></span><br><span class="line">    <span class="comment">// 2. 两条链表相交，走到两条链表的相交点</span></span><br><span class="line">    <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><ol>
<li>递归反转整个链表</li>
</ol>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9MaW5rZWRMaXN0LzIwNi4lRTUlOEYlOEQlRTglQkQlQUMlRTklOTMlQkUlRTglQTElQTguamF2YQ==">206.反转链表<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLWxpbmtlZC1saXN0Lw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>反转单链表的迭代实现非常简单，而递归实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：输入一个单链表头结点，将该链表反转，返回新的头结点</span></span><br><span class="line">ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> reverse(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先 <code>reverse(head.next)</code> 执行完成后，整个链表除了头节点，其他节点都进行了反转且尾节点指向了 <code>null</code>，剩下只需要将尾节点指向头节点，头节点指向 <code>null</code> 即可。</p>
<ol start="2">
<li>反转链表的前 N 个节点</li>
</ol>
<p>若要实现如下函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将链表的前 n 个节点反转（n &lt;= 链表长度）</span></span><br><span class="line">ListNode <span class="title function_">reverseN</span><span class="params">(ListNode head, <span class="type">int</span> n)</span></span><br></pre></td></tr></table></figure>

<p>解决思路和反转整个链表差不多：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ListNode</span> <span class="variable">successor</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 后驱节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转以 head 为起点的 n 个节点，返回新的头结点</span></span><br><span class="line">ListNode <span class="title function_">reverseN</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 记录第 n + 1 个节点</span></span><br><span class="line">        successor = head.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以 head.next 为起点，需要反转前 n - 1 个节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> reverseN(head.next, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    head.next.next = head;</span><br><span class="line">    <span class="comment">// 让反转之后的 head 节点和后面的节点连起来</span></span><br><span class="line">    head.next = successor;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刚才直接把 <code>head.next</code> 设置为 <code>null</code>，因为整个链表反转后原来的 <code>head</code> 变成了整个链表的最后一个节点。但现在 <code>head</code> 节点在递归反转之后不一定是最后一个节点了，所以要记录后驱 <code>successor</code>（第 n + 1 个节点），反转之后将 <code>head</code> 连接上。</p>
<ol start="3">
<li>反转链表的一部分</li>
</ol>
<p>给一个索引区间 <code>[m, n]</code>（索引从 1 开始），仅仅反转区间中的链表元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> m, <span class="type">int</span> n)</span></span><br></pre></td></tr></table></figure>

<p>如果 <code>m == 1</code>，就相当于反转链表开头的 n 个元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 相当于反转前 n 个元素</span></span><br><span class="line">        <span class="keyword">return</span> reverseN(head, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <code>m != 1</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> reverseN(head, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前进到反转的起点触发 base case</span></span><br><span class="line">    head.next = reverseBetween(head.next, m - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9MaW5rZWRMaXN0LzkyLiVFNSU4RiU4RCVFOCVCRCVBQyVFOSU5MyVCRSVFOCVBMSVBOC1paS5qYXZh">92.反转链表 II<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLWxpbmtlZC1saXN0LWlpLw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>虽然迭代实现的时间复杂度与递归实现的时间复杂度相同，且递归实现的空间复杂度更高，但递归的思想很值得学习。</p>
<ol start="4">
<li>K 个一组反转链表</li>
</ol>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9MaW5rZWRMaXN0LzI1LmstJUU0JUI4JUFBJUU0JUI4JTgwJUU3JUJCJTg0JUU3JUJGJUJCJUU4JUJEJUFDJUU5JTkzJUJFJUU4JUExJUE4LmphdmE=">25.K 个一组反转链表<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLW5vZGVzLWluLWstZ3JvdXAv">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>由于对链表每次都进行 K 个一组的反转后，剩下的节点同样是一条链表，且规模较原链表小，因此递归同样适用于这个问题。先反转以 <code>head</code> 为头节点的 K 个节点，之后将第 <code>K + 1</code> 个节点作为 <code>head</code> 继续递归反转再将结果拼接即可。</p>
<p>迭代地反转一个区间内的节点：首先若反转整个链表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反转以 a 为头结点的链表</span></span><br><span class="line">ListNode <span class="title function_">reverse</span><span class="params">(ListNode a)</span> &#123;</span><br><span class="line">    ListNode pre, cur, nxt;</span><br><span class="line">    pre = <span class="literal">null</span>; cur = a; nxt = a;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        nxt = cur.next;</span><br><span class="line">        <span class="comment">// 逐个结点反转</span></span><br><span class="line">        cur.next = pre;</span><br><span class="line">        <span class="comment">// 更新指针位置</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = nxt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回反转后的头结点</span></span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反转以 a 为头结点的链表其实就是反转 a 到 <code>null</code> 之间的结点，同理，反转 a 到 b 之间的结点只需要：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (cur != b) &#123;</span><br><span class="line">        nxt = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = nxt;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对于 <code>reverseKGroup</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 区间 [a, b) 包含 k 个待反转元素</span></span><br><span class="line">    ListNode a, b;</span><br><span class="line">    a = b = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="comment">// 不足 k 个，不需要反转，base case</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        b = b.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反转前 k 个元素</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverse(a, b);</span><br><span class="line">    <span class="comment">// 递归反转后续链表并连接起来</span></span><br><span class="line">    a.next = reverseKGroup(b, k);</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9MaW5rZWRMaXN0LzIzNC4lRTUlOUIlOUUlRTYlOTYlODclRTklOTMlQkUlRTglQTElQTguamF2YQ==">234.回文链表<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYWxpbmRyb21lLWxpbmtlZC1saXN0Lw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>与二叉树遍历相似，链表也可以用递归的方式遍历，这里使用后序遍历就可以倒叙遍历链表，再与从头节点开始遍历比较是否相同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左侧指针</span></span><br><span class="line">ListNode left;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    left = head;</span><br><span class="line">    <span class="keyword">return</span> traverse(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">traverse</span><span class="params">(ListNode right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> traverse(right.next);</span><br><span class="line">    <span class="comment">// 后序遍历代码</span></span><br><span class="line">    res = res &amp;&amp; (right.val == left.val);</span><br><span class="line">    left = left.next;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这养做的核心逻辑就是把链表节点放入一个栈，然后再拿出来，这时候元素顺序就是反的。</p>
<p>但是这样的空间复杂度为 <code>O(N)</code>。若要不使用额外空间，可以先通过双指针中的快慢指针找到链表的中点，再从 <code>slow</code> 开始反转后面的链表，然后进行比较。</p>
<p>需要注意的是，若链表长度为奇数即 <code>fast</code> 指针没有指向 <code>null</code>，<code>slow</code> 还需要再前进一步。且此方法需要修改原链表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    ListNode slow, fast;</span><br><span class="line">    slow = fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (fast != <span class="literal">null</span>)</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    </span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> reverse(slow);</span><br><span class="line">    <span class="keyword">while</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left.val != right.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        left = left.next;</span><br><span class="line">        right = right.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9TdHJpbmcvNy4lRTYlOTUlQjQlRTYlOTUlQjAlRTUlOEYlOEQlRTglQkQlQUMuamF2YQ==">7.整数反转<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLWludGVnZXIv">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9TdHJpbmcvOC4lRTUlQUQlOTclRTclQUMlQTYlRTQlQjglQjIlRTglQkQlQUMlRTYlOEQlQTIlRTYlOTUlQjQlRTYlOTUlQjAtYXRvaS5qYXZh">8.字符串转换整数<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdHJpbmctdG8taW50ZWdlci1hdG9pLw==">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9TdHJpbmcvMTQuJUU2JTlDJTgwJUU5JTk1JUJGJUU1JTg1JUFDJUU1JTg1JUIxJUU1JTg5JThEJUU3JUJDJTgwLmphdmE=">14.最长公共前缀<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LWNvbW1vbi1wcmVmaXgv">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9TdHJpbmcvMjguJUU1JUFFJTlFJUU3JThFJUIwLXN0ci1zdHIuamF2YQ==">28.实现strStr()<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbXBsZW1lbnQtc3Ryc3RyLw==">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9TdHJpbmcvMzguJUU1JUE0JTk2JUU4JUE3JTgyJUU2JTk1JUIwJUU1JTg4JTk3LmphdmE=">38.外观数列<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3VudC1hbmQtc2F5Lw==">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9TdHJpbmcvMjQyLiVFNiU5QyU4OSVFNiU5NSU4OCVFNyU5QSU4NCVFNSVBRCU5NyVFNiVBRiU4RCVFNSVCQyU4MiVFNCVCRCU4RCVFOCVBRiU4RC5qYXZh">242.有效的字母异位词<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZC1hbmFncmFtLw==">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8zNDQuJUU1JThGJThEJUU4JUJEJUFDJUU1JUFEJTk3JUU3JUFDJUE2JUU0JUI4JUIyLmphdmE=">344.反转字符串<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLXN0cmluZy8=">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9TdHJpbmcvMzg3LiVFNSVBRCU5NyVFNyVBQyVBNiVFNCVCOCVCMiVFNCVCOCVBRCVFNyU5QSU4NCVFNyVBQyVBQyVFNCVCOCU4MCVFNCVCOCVBQSVFNSU5NCVBRiVFNCVCOCU4MCVFNSVBRCU5NyVFNyVBQyVBNi5qYXZh">387.字符串中的第一个唯一字符<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maXJzdC11bmlxdWUtY2hhcmFjdGVyLWluLWEtc3RyaW5nLw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>其中 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9TdHJpbmcvMjQyLiVFNiU5QyU4OSVFNiU5NSU4OCVFNyU5QSU4NCVFNSVBRCU5NyVFNiVBRiU4RCVFNSVCQyU4MiVFNCVCRCU4RCVFOCVBRiU4RC5qYXZh">#242<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9TdHJpbmcvMzg3LiVFNSVBRCU5NyVFNyVBQyVBNiVFNCVCOCVCMiVFNCVCOCVBRCVFNyU5QSU4NCVFNyVBQyVBQyVFNCVCOCU4MCVFNCVCOCVBQSVFNSU5NCVBRiVFNCVCOCU4MCVFNSVBRCU5NyVFNyVBQyVBNi5qYXZh">#387<i class="fa fa-external-link-alt"></i></span> 很相似，都是通过 Hash 映射比较异同，遇到这类题首先可以考虑使用 Hash。而 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9TdHJpbmcvNy4lRTYlOTUlQjQlRTYlOTUlQjAlRTUlOEYlOEQlRTglQkQlQUMuamF2YQ==">#7<i class="fa fa-external-link-alt"></i></span> 与 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9TdHJpbmcvOC4lRTUlQUQlOTclRTclQUMlQTYlRTQlQjglQjIlRTglQkQlQUMlRTYlOEQlQTIlRTYlOTUlQjQlRTYlOTUlQjAtYXRvaS5qYXZh">#8<i class="fa fa-external-link-alt"></i></span> 需要仔细考虑溢出问题。</p>
<br>

<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="纲领"><a href="#纲领" class="headerlink" title="纲领"></a>纲领</h2><p>二叉树解题的思维模式分两类：</p>
<ol>
<li><p>是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 <code>traverse</code> 函数配合外部变量来实现，这叫「遍历」的思维模式。</p>
</li>
<li><p>是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。</p>
</li>
</ol>
<p>无论使用哪种思维模式，都需要思考：</p>
<p>如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前&#x2F;中&#x2F;后序位置）做？递归函数会在所有节点上执行相同的操作，因此只需考虑一个节点。</p>
<p>前序位置，就是刚进入一个节点（元素）的时候，后序位置就是即将离开一个节点（元素）的时候，把代码写在不同位置，代码执行的时机也不同。</p>
<p><strong>前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点</strong>，绝不仅仅是三个顺序不同的 <code>List</code>。</p>
<p><strong>二叉树的所有问题，就是在前中后序位置注入巧妙的代码逻辑，去达到自己的目的。我们只需要单独思考每一个节点应该做什么，其他的交给二叉树遍历框架，递归会在所有节点上做相同的操作。</strong></p>
<ul>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzEwMS4lRTUlQUYlQjklRTclQTclQjAlRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTEuamF2YQ==">101.对称二叉树<i class="fa fa-external-link-alt"></i></span> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zeW1tZXRyaWMtdHJlZS8=">🔗<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzEwNC4lRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTElRTclOUElODQlRTYlOUMlODAlRTUlQTQlQTclRTYlQjclQjElRTUlQkElQTYuamF2YQ==">104.二叉树的最大深度<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWRlcHRoLW9mLWJpbmFyeS10cmVlLw==">🔗<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzEwMi4lRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTElRTclOUElODQlRTUlQjElODIlRTUlQkElOEYlRTklODElOEQlRTUlOEUlODYuamF2YQ==">102.二叉树的层序遍历<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1sZXZlbC1vcmRlci10cmF2ZXJzYWwv">🔗<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
<p>如 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzEwNC4lRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTElRTclOUElODQlRTYlOUMlODAlRTUlQTQlQTclRTYlQjclQjElRTUlQkElQTYuamF2YQ==">#104<i class="fa fa-external-link-alt"></i></span>，显然遍历一遍二叉树，用一个外部变量记录每个节点所在的深度，取最大值就可以得到最大深度，这就是遍历二叉树计算答案的思路。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 记录最大深度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录遍历到的节点的深度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历二叉树</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历位置</span></span><br><span class="line">        depth++;</span><br><span class="line">        <span class="comment">// 遍历的过程中记录最大深度</span></span><br><span class="line">        res = res &lt; depth ? depth : res;</span><br><span class="line">        traverse(root.left);</span><br><span class="line">        traverse(root.right);</span><br><span class="line">        <span class="comment">// 后序遍历位置</span></span><br><span class="line">        depth--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个解法很好理解，但为什么需要在前序位置增加 <code>depth</code>，在后序位置减小 <code>depth</code>？</p>
<p>因为前序位置是进入一个节点的时候，后序位置是离开一个节点的时候，<code>depth</code> 记录当前递归到的节点深度，把 <code>traverse</code> 理解成在二叉树上游走的一个指针，所以当然要这样维护。</p>
<p>至于对 <code>res</code> 的更新放到前中后序位置都可以，只要保证在进入节点之后，离开节点之前（即 <code>depth</code> 自增之后，自减之前）就行了。</p>
<p>一棵二叉树的最大深度也可以通过子树的最大深度推导出来，这就是分解问题计算答案的思路。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：输入根节点，返回这棵二叉树的最大深度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 利用定义，计算左右子树的最大深度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">    <span class="comment">// 整棵树的最大深度等于左右子树的最大深度取最大值，</span></span><br><span class="line">    <span class="comment">// 然后再加上根节点自己</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(leftMax, rightMax) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要明确递归函数的定义，这个解法也不难理解，但为什么主要的代码逻辑集中在后序位置？</p>
<p>因为这个思路正确的核心在于通过子树的最大深度推导出原树的深度首先需要利用递归函数的定义算出左右子树的最大深度，然后推出原树的最大深度，主要逻辑自然放在后序位置。</p>
<p>可以发现前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的。</p>
<p>因此，<strong>前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据</strong>。</p>
<p>举具体的例子，有一棵二叉树：</p>
<ol>
<li><p>如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？</p>
</li>
<li><p>如何打印出每个节点的左右子树各有多少节点？</p>
</li>
</ol>
<p>第一个问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树遍历函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    printf(<span class="string">&quot;节点 %s 在第 %d 层&quot;</span>, root, level);</span><br><span class="line">    traverse(root.left, level + <span class="number">1</span>);</span><br><span class="line">    traverse(root.right, level + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">traverse(root, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>第二个问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：输入一棵二叉树，返回这棵二叉树的节点总数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftCount</span> <span class="operator">=</span> count(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightCount</span> <span class="operator">=</span> count(root.right);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">    printf(<span class="string">&quot;节点 %s 的左子树有 %d 个节点，右子树有 %d 个节点&quot;</span>,</span><br><span class="line">            root, leftCount, rightCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> leftCount + rightCount + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个问题的根本区别在于：一个节点在第几层，从根节点遍历过来的过程就能顺带记录；而以一个节点为根的整棵子树有多少个节点，需要遍历完子树之后才能数清楚。</p>
<p><strong>一旦发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。</strong></p>
<ul>
<li><a href="Tree/652.%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E6%A0%91.java">652.寻找重复的子树</a>   <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWR1cGxpY2F0ZS1zdWJ0cmVlcy8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<br>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>运用纲领中的二叉树解题的思维模式：</p>
<ul>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzExNC4lRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTElRTUlQjElOTUlRTUlQkMlODAlRTQlQjglQkElRTklOTMlQkUlRTglQTElQTguamF2YQ==">114.二叉树展开为链表<i class="fa fa-external-link-alt"></i></span>   <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZmxhdHRlbi1iaW5hcnktdHJlZS10by1saW5rZWQtbGlzdC8=">🔗<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzExNi4lRTUlQTElQUIlRTUlODUlODUlRTYlQUYlOEYlRTQlQjglQUElRTglOEElODIlRTclODIlQjklRTclOUElODQlRTQlQjglOEIlRTQlQjglODAlRTQlQjglQUElRTUlOEYlQjMlRTQlQkUlQTclRTglOEElODIlRTclODIlQjklRTYlOEMlODclRTklOTIlODguamF2YQ==">116.填充每个节点的下一个右侧节点指针<i class="fa fa-external-link-alt"></i></span>   <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wb3B1bGF0aW5nLW5leHQtcmlnaHQtcG9pbnRlcnMtaW4tZWFjaC1ub2RlLw==">🔗<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzIyNi4lRTclQkYlQkIlRTglQkQlQUMlRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTEuamF2YQ==">226.翻转二叉树<i class="fa fa-external-link-alt"></i></span>   <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnZlcnQtYmluYXJ5LXRyZWUv">🔗<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
<p>每道二叉树的题都需要思考纲领中提到的：</p>
<ol>
<li><p>是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 <code>traverse</code> 函数配合外部变量来实现，这叫「遍历」的思维模式。</p>
</li>
<li><p>是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。</p>
</li>
</ol>
<p>无论使用哪种思维模式，都需要思考：</p>
<p>如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前&#x2F;中&#x2F;后序位置）做？递归函数会在所有节点上执行相同的操作，因此只需考虑一个节点。</p>
<p>对于 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzExNC4lRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTElRTUlQjElOTUlRTUlQkMlODAlRTQlQjglQkElRTklOTMlQkUlRTglQTElQTguamF2YQ==">#114<i class="fa fa-external-link-alt"></i></span> 由于函数的返回值限定为 <code>void</code>，因此无法通过简单的二叉树遍历来解决这道题。此时就应该考虑分解问题的思路。对于 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzExNi4lRTUlQTElQUIlRTUlODUlODUlRTYlQUYlOEYlRTQlQjglQUElRTglOEElODIlRTclODIlQjklRTclOUElODQlRTQlQjglOEIlRTQlQjglODAlRTQlQjglQUElRTUlOEYlQjMlRTQlQkUlQTclRTglOEElODIlRTclODIlQjklRTYlOEMlODclRTklOTIlODguamF2YQ==">#116<i class="fa fa-external-link-alt"></i></span> 可以使用遍历而不能使用分解问题的思路。对于 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzIyNi4lRTclQkYlQkIlRTglQkQlQUMlRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTEuamF2YQ==">#226<i class="fa fa-external-link-alt"></i></span> 两种思路都可以。</p>
</br>

<h2 id="构造二叉树"><a href="#构造二叉树" class="headerlink" title="构造二叉树"></a>构造二叉树</h2><p><strong>二叉树的构造问题一般都是使用「分解问题」的思路：构造整棵树 &#x3D; 根节点 + 构造左子树 + 构造右子树。</strong></p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzY1NC4lRTYlOUMlODAlRTUlQTQlQTclRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTEuamF2YQ==">654.最大二叉树<i class="fa fa-external-link-alt"></i></span>   <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW11bS1iaW5hcnktdHJlZS8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>每个二叉树节点都可以认为是一棵子树的根节点，对于根节点，首先要做的是把想办法把自己先构造出来，然后想办法构造自己的左右子树。</p>
<p>所以需要遍历数组找到最大值 <code>maxVal</code>，从而把根节点 <code>root</code> 做出来，然后对 <code>maxVal</code> 左边的数组和右边的数组进行递归构建，作为 <code>root</code> 的左右子树。</p>
<p>伪码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums is empty) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 找到数组中的最大值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxVal</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; maxVal) &#123;</span><br><span class="line">            maxVal = nums[i];</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(maxVal);</span><br><span class="line">    <span class="comment">// 递归调用构造左右子树</span></span><br><span class="line">    root.left = constructMaximumBinaryTree(nums[<span class="number">0.</span>.index-<span class="number">1</span>]);</span><br><span class="line">    root.right = constructMaximumBinaryTree(nums[index+<span class="number">1.</span>.nums.length-<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前 <code>nums</code> 中的最大值就是根节点，然后根据索引递归调用左右数组构造左右子树即可。</p>
</br>

<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzEwNS4lRTQlQkIlOEUlRTUlODklOEQlRTUlQkElOEYlRTQlQjglOEUlRTQlQjglQUQlRTUlQkElOEYlRTklODElOEQlRTUlOEUlODYlRTUlQkElOEYlRTUlODglOTclRTYlOUUlODQlRTklODAlQTAlRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTEuamF2YQ==">105.从前序与中序遍历序列构造二叉树<i class="fa fa-external-link-alt"></i></span>   <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29uc3RydWN0LWJpbmFyeS10cmVlLWZyb20tcHJlb3JkZXItYW5kLWlub3JkZXItdHJhdmVyc2FsLw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>与上一题类似，需要确定根节点，然后递归构造左右子树。</p>
<p>根据前序遍历的特点可以很容易的找到根节点——前序遍历的第一个数字 <code>preorder[0]</code>。关键在于如何通过根节点的值，将 <code>preorder</code> 和 <code>inorder</code> 数组划分成两半，构造根节点的左右子树</p>
<p>即下面代码中的 <code>？</code> 应该如何确定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储 inorder 中值到索引的映射</span></span><br><span class="line">HashMap&lt;Integer, Integer&gt; valToIndex = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">        valToIndex.put(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> build(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    build 函数的定义：</span></span><br><span class="line"><span class="comment">    若前序遍历数组为 preorder[preStart..preEnd]，</span></span><br><span class="line"><span class="comment">    中序遍历数组为 inorder[inStart..inEnd]，</span></span><br><span class="line"><span class="comment">    构造二叉树，返回该二叉树的根节点 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span> preStart, <span class="type">int</span> preEnd, <span class="type">int</span>[] inorder, <span class="type">int</span> inStart, <span class="type">int</span> inEnd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> preorder[preStart];</span><br><span class="line">    <span class="comment">// 避免 for 循环寻找 rootVal</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> valToIndex.get(rootVal);</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">    <span class="comment">// 递归构造左右子树</span></span><br><span class="line">    root.left = build(preorder, ?, ?, inorder, ?, ?);</span><br><span class="line"></span><br><span class="line">    root.right = build(preorder, ?, ?, inorder, ?, ?);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于左右子树对应的 <code>inorder</code> 数组的起始索引和终止索引比较容易确定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root.left = build(preorder, ?, ?, inorder, inStart, index - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">root.right = build(preorder, ?, ?, inorder, index + <span class="number">1</span>, inEnd);</span><br></pre></td></tr></table></figure>

<p>中序遍历的根节点左边就是左子树的节点值，右边就是右子树的节点值。</p>
<p>而对于 <code>preorder</code> 数组，可以通过左子树的节点数推导出来，假设左子树的节点数为 <code>leftSize</code>，那么可以根据 <code>inorder</code> 数组计算出 <code>leftSize</code>，而 <code>preStart + leftSize</code> 就是左子树的终止索引。</p>
<p>这样就可以完成代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> index - inStart;</span><br><span class="line"></span><br><span class="line">root.left = build(preorder, preStart + <span class="number">1</span>, preStart + leftSize, inorder, inStart, index - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">root.right = build(preorder, preStart + leftSize + <span class="number">1</span>, preEnd, inorder, index + <span class="number">1</span>, inEnd);</span><br></pre></td></tr></table></figure>

</br>

<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzEwNi4lRTQlQkIlOEUlRTQlQjglQUQlRTUlQkElOEYlRTQlQjglOEUlRTUlOTAlOEUlRTUlQkElOEYlRTklODElOEQlRTUlOEUlODYlRTUlQkElOEYlRTUlODglOTclRTYlOUUlODQlRTklODAlQTAlRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTEuamF2YQ==">106.从中序与后序遍历序列构造二叉树<i class="fa fa-external-link-alt"></i></span>   <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29uc3RydWN0LWJpbmFyeS10cmVlLWZyb20taW5vcmRlci1hbmQtcG9zdG9yZGVyLXRyYXZlcnNhbC8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>与 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzEwNS4lRTQlQkIlOEUlRTUlODklOEQlRTUlQkElOEYlRTQlQjglOEUlRTQlQjglQUQlRTUlQkElOEYlRTklODElOEQlRTUlOEUlODYlRTUlQkElOEYlRTUlODglOTclRTYlOUUlODQlRTklODAlQTAlRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTEuamF2YQ==">#105<i class="fa fa-external-link-alt"></i></span> 类似，可以通过后序遍历数组 <code>postorder</code> 推导出根节点的值，然后递归构造左右子树。后序遍历数组的最后一个元素就是根节点的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储 inorder 中值到索引的映射</span></span><br><span class="line">HashMap&lt;Integer, Integer&gt; valToIndex = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">        valToIndex.put(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> build(inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>, postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    build 函数的定义：</span></span><br><span class="line"><span class="comment">    后序遍历数组为 postorder[postStart..postEnd]，</span></span><br><span class="line"><span class="comment">    中序遍历数组为 inorder[inStart..inEnd]，</span></span><br><span class="line"><span class="comment">    构造二叉树，返回该二叉树的根节点 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span> inStart, <span class="type">int</span> inEnd, <span class="type">int</span>[] postorder, <span class="type">int</span> postStart, <span class="type">int</span> postEnd)</span> &#123;</span><br><span class="line">    <span class="comment">// root 节点对应的值就是后序遍历数组的最后一个元素</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> postorder[postEnd];</span><br><span class="line">    <span class="comment">// rootVal 在中序遍历数组中的索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> valToIndex.get(rootVal);</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">    <span class="comment">// 递归构造左右子树</span></span><br><span class="line">    root.left = build(inorder, ?, ?, postorder, ?, ?);</span><br><span class="line"></span><br><span class="line">    root.right = build(inorder, ?, ?, postorder, ?, ?);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先可以确定左右子树对应的 <code>inorder</code> 数组的起始索引和终止索引：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root.left = build(inorder, inStart, index - <span class="number">1</span>, postorder, ?, ?);</span><br><span class="line"></span><br><span class="line">root.right = build(inorder, index + <span class="number">1</span>, inEnd, postorder, ?, ?);</span><br></pre></td></tr></table></figure>

<p>同样可以通过中序遍历数组求出左子树的长度 <code>leftSize</code>，在 <code>postorder</code> 数组中左子树就从 <code>postStart</code> 到 <code>postStart + leftSize - 1</code>，而右子树就从 <code>postStart + leftSize</code> 到 <code>postEnd - 1</code> (<code>postEnd</code> 是根节点)。</p>
<p>这样就完成了代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> index - inStart;</span><br><span class="line"></span><br><span class="line">root.left = build(inorder, inStart, index - <span class="number">1</span>, postorder, postStart, postStart + leftSize - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">root.right = build(inorder, index + <span class="number">1</span>, inEnd, postorder, postStart + leftSize, postEnd - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

</br>

<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzg4OS4lRTYlQTAlQjklRTYlOEQlQUUlRTUlODklOEQlRTUlQkElOEYlRTUlOTIlOEMlRTUlOTAlOEUlRTUlQkElOEYlRTklODElOEQlRTUlOEUlODYlRTYlOUUlODQlRTklODAlQTAlRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTEuamF2YQ==">889.根据前序和后序遍历构造二叉树<i class="fa fa-external-link-alt"></i></span>   <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb25zdHJ1Y3QtYmluYXJ5LXRyZWUtZnJvbS1wcmVvcmRlci1hbmQtcG9zdG9yZGVyLXRyYXZlcnNhbC8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>我们可以通过一棵树的前序和中序、中序和后序遍历来唯一确定一棵原始二叉树。但通过前序后序遍历结果无法确定唯一的原始二叉树。</p>
<p>用前序遍历和后序遍历结果还原二叉树，解法逻辑上和 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzEwNS4lRTQlQkIlOEUlRTUlODklOEQlRTUlQkElOEYlRTQlQjglOEUlRTQlQjglQUQlRTUlQkElOEYlRTklODElOEQlRTUlOEUlODYlRTUlQkElOEYlRTUlODglOTclRTYlOUUlODQlRTklODAlQTAlRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTEuamF2YQ==">#105<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzEwNi4lRTQlQkIlOEUlRTQlQjglQUQlRTUlQkElOEYlRTQlQjglOEUlRTUlOTAlOEUlRTUlQkElOEYlRTklODElOEQlRTUlOEUlODYlRTUlQkElOEYlRTUlODglOTclRTYlOUUlODQlRTklODAlQTAlRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTEuamF2YQ==">#106<i class="fa fa-external-link-alt"></i></span> 差别不大，也是通过控制左右子树的索引来构建：</p>
<ol>
<li><p>首先把前序遍历结果的第一个元素或者后序遍历结果的最后一个元素确定为根节点的值。</p>
</li>
<li><p>然后把前序遍历结果的第二个元素作为左子树的根节点的值。</p>
</li>
<li><p>在后序遍历结果中寻找左子树根节点的值，从而确定了左子树的索引边界，进而确定右子树的索引边界，递归构造左右子树即可。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 存储 postorder 中值到索引的映射</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; valToIndex = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructFromPrePost</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; postorder.length; i++) &#123;</span><br><span class="line">            valToIndex.put(postorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：根据 preorder[preStart..preEnd] 和 postorder[postStart..postEnd]</span></span><br><span class="line">    <span class="comment">// 构建二叉树，并返回根节点。</span></span><br><span class="line">    TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span> preStart, <span class="type">int</span> preEnd, <span class="type">int</span>[] postorder, <span class="type">int</span> postStart, <span class="type">int</span> postEnd)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (preStart &gt; preEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (preStart == preEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[preStart]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// root 节点对应的值就是前序遍历数组的第一个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> preorder[preStart];</span><br><span class="line">        <span class="comment">// root.left 的值是前序遍历第二个元素</span></span><br><span class="line">        <span class="comment">// 通过前序和后序遍历构造二叉树的关键在于通过左子树的根节点</span></span><br><span class="line">        <span class="comment">// 确定 preorder 和 postorder 中左右子树的元素区间</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftRootVal</span> <span class="operator">=</span> preorder[preStart + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// leftRootVal 在后序遍历数组中的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> valToIndex.get(leftRootVal);</span><br><span class="line">        <span class="comment">// 左子树的元素个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> index - postStart + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先构造出当前根节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">        <span class="comment">// 递归构造左右子树</span></span><br><span class="line">        <span class="comment">// 根据左子树的根节点索引和元素个数推导左右子树的索引边界</span></span><br><span class="line">        root.left = build(preorder, preStart + <span class="number">1</span>, preStart + leftSize, postorder, postStart, index);</span><br><span class="line">        root.right = build(preorder, preStart + leftSize + <span class="number">1</span>, preEnd, postorder, index + <span class="number">1</span>, postEnd - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>造成前序和后序遍历构造二叉树结果不唯一的关键就在于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">leftRootVal</span> <span class="operator">=</span> preorder[preStart + <span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>假设前序遍历的第二个元素是左子树的根节点，但实际上左子树有可能是空指针，那么这个元素就应该是右子树的根节点。由于这里无法确切进行判断，所以导致了最终答案的不唯一。</p>
<p><strong>总之，二叉树的构造问题一般都是使用「分解问题」的思路：构造整棵树 &#x3D; 根节点 + 构造左子树 + 构造右子树。先找出根节点，然后根据根节点的值找到左右子树的元素，进而递归构建出左右子树。</strong></p>
</br>



<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序代码框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：排序 nums[lo..hi]</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lo == hi) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (lo + hi) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 利用定义，排序 nums[lo..mid]</span></span><br><span class="line">    sort(nums, lo, mid);</span><br><span class="line">    <span class="comment">// 利用定义，排序 nums[mid+1..hi]</span></span><br><span class="line">    sort(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">    <span class="comment">// 此时两部分子数组已经被排好序</span></span><br><span class="line">    <span class="comment">// 合并两个有序数组，使 nums[lo..hi] 有序</span></span><br><span class="line">    merge(nums, lo, mid, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将有序数组 nums[lo..mid] 和有序数组 nums[mid+1..hi]</span></span><br><span class="line"><span class="comment">// 合并为有序数组 nums[lo..hi]</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> mid, <span class="type">int</span> hi)</span>;</span><br></pre></td></tr></table></figure>

<p>归并排序就是先把左半边数组排好序，再把右半边数组排好序，然后把两半数组合并。</p>
<p>上述代码和二叉树的后序遍历很像：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二叉树遍历框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">    print(root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出归并排序利用的是分解问题的思路，归并排序的过程可以在逻辑上抽象成一棵二叉树，树上的每个节点的值可以认为是 nums[lo..hi]，叶子节点的值就是数组中的单个元素：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/j6jdt1"><img src="https://s1.ax1x.com/2022/07/11/j6jdt1.png" alt="j6jdt1.png"></a></p>
<p>然后，在每个节点的后序位置（左右子节点已经被排好序）的时候执行 <code>merge</code> 函数，合并两个子节点上的子数组：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/j6jN79"><img src="https://s1.ax1x.com/2022/07/11/j6jN79.png" alt="j6jN79.png"></a></p>
<p>这个 <code>merge</code> 操作会在二叉树的每个节点上都执行一遍，执行顺序是二叉树后序遍历的顺序。</p>
<p>因此可以写出代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Merge</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于辅助合并有序数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 先给辅助数组开辟内存空间</span></span><br><span class="line">        temp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="comment">// 排序整个数组（原地修改）</span></span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：将子数组 nums[lo..hi] 进行排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lo == hi) &#123;</span><br><span class="line">            <span class="comment">// 单个元素不用排序</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这样写是为了防止溢出，效果等同于 (hi + lo) / 2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 先对左半部分数组 nums[lo..mid] 排序</span></span><br><span class="line">        sort(nums, lo, mid);</span><br><span class="line">        <span class="comment">// 再对右半部分数组 nums[mid+1..hi] 排序</span></span><br><span class="line">        sort(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="comment">// 将两部分有序数组合并成一个有序数组</span></span><br><span class="line">        merge(nums, lo, mid, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 nums[lo..mid] 和 nums[mid+1..hi] 这两个有序数组合并成一个有序数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> mid, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="comment">// 先把 nums[lo..hi] 复制到辅助数组中</span></span><br><span class="line">        <span class="comment">// 以便合并后的结果能够直接存入 nums</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo; i &lt;= hi; i++) &#123;</span><br><span class="line">            temp[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组双指针技巧，合并两个有序数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> lo; p &lt;= hi; p++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == mid + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 左半边数组已全部被合并</span></span><br><span class="line">                nums[p] = temp[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == hi + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 右半边数组已全部被合并</span></span><br><span class="line">                nums[p] = temp[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp[i] &gt; temp[j]) &#123;</span><br><span class="line">                nums[p] = temp[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[p] = temp[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sort</code> 函数对 <code>nums[lo..mid]</code> 和 <code>nums[mid+1..hi]</code> 递归排序完成之后，我们没有办法原地把它们合并，所以需要 <code>copy</code> 到 <code>temp</code> 数组里面，然后通过类似于合并有序链表的双指针技巧将 <code>nums[lo..hi]</code> 合并成一个有序数组：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/j6jakR"><img src="https://s1.ax1x.com/2022/07/11/j6jakR.png" alt="j6jakR.png"></a></p>
<p>注意，这里不是在 <code>merge</code> 函数执行的时候 <code>new</code> 辅助数组，而是提前把 <code>temp</code> 辅助数组 <code>new</code> 出来了，这样就避免了在递归中频繁分配和释放内存可能产生的性能问题。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS85MTIuJUU2JThFJTkyJUU1JUJBJThGJUU2JTk1JUIwJUU3JUJCJTg0LmphdmE=">912.排序数组<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zb3J0LWFuLWFycmF5Lw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>除了最基本的排序问题，归并排序还可以用来解决：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzMxNS4lRTglQUUlQTElRTclQUUlOTclRTUlOEYlQjMlRTQlQkUlQTclRTUlQjAlOEYlRTQlQkElOEUlRTUlQkQlOTMlRTUlODklOEQlRTUlODUlODMlRTclQjQlQTAlRTclOUElODQlRTQlQjglQUElRTYlOTUlQjAuamF2YQ==">315.计算右侧小于当前元素的个数<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3VudC1vZi1zbWFsbGVyLW51bWJlcnMtYWZ0ZXItc2VsZi8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/j6jt0J"><img src="https://s1.ax1x.com/2022/07/11/j6jt0J.png" alt="j6jt0J.png"></a></p>
<p>在使用 <code>merge</code> 函数合并两个有序数组时可以知道一个元素 <code>nums[i]</code> 后边有多少个元素比 <code>nums[i]</code> 小：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/j6jYm4"><img src="https://s1.ax1x.com/2022/07/11/j6jYm4.png" alt="j6jYm4.png"></a></p>
<p>此时应该把 <code>temp[i]</code> 放到 <code>nums[p]</code> 上，因为 <code>temp[i] &lt; temp[j]</code>。</p>
<p>在这个场景下还可以知道：5 后面比 5 小的元素个数就是 左闭右开区间 <code>[mid + 1, j)</code> 中的元素个数，即 2 和 4 这两个元素。这是因为 <code>temp</code> 被 <code>mid</code> 划分成了两个已经排好序的数组，而在左边的数组中，<code>i</code> 的右边显然不会有比 <code>temp[i]</code> 更小的元素，因此比它小的只能在 <code>mid</code> 之后，即从 <code>mid + 1</code> 开始；又因为 <code>temp[i] &lt; temp[j]</code>，而此时 <code>temp[j - 1]</code> 是与 <code>temp[i]</code> 比较过并放入 <code>nums[p]</code> 中的，因此在 <code>j</code> 结束且不包含 <code>j</code>。</p>
<p>即在对 <code>nuns[lo..hi]</code> 合并的过程中，每当执行 <code>nums[p] = temp[i]</code> 时，就可以确定 <code>temp[i]</code> 这个元素后面比它小的元素个数为 <code>j - mid - 1</code>。</p>
<p>这样只需要修改 <code>merge</code> 方法即可完成该题。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzMyNy4lRTUlOEMlQkElRTklOTclQjQlRTUlOTIlOEMlRTclOUElODQlRTQlQjglQUElRTYlOTUlQjAuamF2YQ==">327.区间和的个数<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3VudC1vZi1yYW5nZS1zdW0v">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/j6jBp6"><img src="https://s1.ax1x.com/2022/07/11/j6jBp6.png" alt="j6jBp6.png"></a></p>
<p>要求计算计算元素和落在 <code>[lower, upper]</code> 中的所有子数组的个数。可以创建一个前缀和数组 <code>preSum</code> 来辅助计算区间和。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzQ5My4lRTclQkYlQkIlRTglQkQlQUMlRTUlQUYlQjkuamF2YQ==">493.翻转对<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLXBhaXJzLw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/j6jwfx"><img src="https://s1.ax1x.com/2022/07/11/j6jwfx.png" alt="j6jwfx.png"></a></p>
<p>与 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzMxNS4lRTglQUUlQTElRTclQUUlOTclRTUlOEYlQjMlRTQlQkUlQTclRTUlQjAlOEYlRTQlQkElOEUlRTUlQkQlOTMlRTUlODklOEQlRTUlODUlODMlRTclQjQlQTAlRTclOUElODQlRTQlQjglQUElRTYlOTUlQjAuamF2YQ==">#315<i class="fa fa-external-link-alt"></i></span> 非常相似，只是判断的条件发生了改变，这里求的是 <code>nums[i] &gt; 2*nums[j]</code>。</p>
<p>所以解题思路还是要在 <code>merge</code> 函数中修改，当 <code>nums[lo..mid]</code> 和 <code>nums[mid+1..hi]</code> 两个子数组完成排序后，对于 <code>nums[lo..mid]</code> 中的每个元素 <code>nums[i]</code>，去 <code>nums[mid+1..hi]</code> 中寻找符合条件的 <code>nums[j]</code> 就可以。</p>
<p><strong>所有递归的算法，本质上都是在遍历一棵（递归）树，然后在节点（前中后序位置）上执行代码。要写递归算法，本质上就是要告诉每个节点需要做什么。</strong></p>
<p><strong>如归并排序算法，递归的 <code>sort</code> 函数就是二叉树的遍历函数，而 <code>merge</code> 函数就是在每个节点上做的事情。</strong></p>
</br>

<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>二叉搜索树（Binary Search Tree，BST）的特点：</p>
<ol>
<li>对于 BST 的每一个节点 <code>node</code>，左子树节点的值都比 <code>node</code> 的值要小，右子树节点的值都比 <code>node</code> 的值大。 </li>
<li>对于 BST 的每一个节点 <code>node</code>，它的左侧子树和右侧子树都是 BST。</li>
</ol>
<p><strong>除了它的定义，还有一个重要的性质：BST 的中序遍历结果是有序的（升序）。</strong></p>
<p>也就是说，如果输入一棵 BST，可以将 BST 中每个节点的值升序打印出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    traverse(root.left);</span><br><span class="line">    <span class="comment">// 中序遍历代码位置</span></span><br><span class="line">    print(root.val);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<ul>
<li><a href="Tree/230.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0.java">230.二叉搜索树中第K小的元素</a>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9rdGgtc21hbGxlc3QtZWxlbWVudC1pbi1hLWJzdC8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jgopFK"><img src="https://s1.ax1x.com/2022/07/12/jgopFK.png" alt="jgopFK.png"></a></p>
<p>利用 BST 的这个特性就可以轻松完成这道题：中序遍历 BST 升序得到结果，并获取第 <code>k</code> 个元素即可:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 记录结果以及位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, rank = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 利用 BST 的中序遍历特性</span></span><br><span class="line">        traverse(root, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(root.left, k);</span><br><span class="line">        <span class="comment">// 中序遍历代码位置</span></span><br><span class="line">        <span class="keyword">if</span>(++rank == k) &#123;</span><br><span class="line">            <span class="comment">// 找到第 k 小的元素</span></span><br><span class="line">            res = root.val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(root.right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>


<ul>
<li><a href="Tree/538.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91.java">538.把二叉搜索树转换为累加树</a>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb252ZXJ0LWJzdC10by1ncmVhdGVyLXRyZWUv">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><a href="Tree/1038.%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%88%B0%E6%9B%B4%E5%A4%A7%E5%92%8C%E6%A0%91.java">1038.从二叉搜索树到更大和树</a>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktc2VhcmNoLXRyZWUtdG8tZ3JlYXRlci1zdW0tdHJlZS8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jgo9JO"><img src="https://s1.ax1x.com/2022/07/12/jgo9JO.png" alt="jgo9JO.png"></a></p>
<p>这两题完全相同，需要将每个节点的值更改为大于等于该节点的值之和，对于 BST 来说，每个节点的左子树都比该节点的值小，右子树都比该节点的值大，因此可以为每个节点加上其右子树的所有值即可。同样利用 BST 中序遍历的特点，但需要降序，即从右到左遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 先递归遍历右子树</span></span><br><span class="line">    traverse(root.right);</span><br><span class="line">    <span class="comment">// 中序遍历代码位置</span></span><br><span class="line">    print(root.val);</span><br><span class="line">    <span class="comment">// 后递归遍历左子树</span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码可以降序打印 BST 节点的值，如果维护一个外部累加变量 <code>sum</code>，然后把 <code>sum</code> 赋值给 BST 中的每一个节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    traverse(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录累加和</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    traverse(root.right);</span><br><span class="line">    <span class="comment">// 维护累加和</span></span><br><span class="line">    sum += root.val;</span><br><span class="line">    <span class="comment">// 将 BST 转化成累加树</span></span><br><span class="line">    root.val = sum;</span><br><span class="line">    traverse(root.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心还是 BST 的中序遍历特性，只不过修改了递归顺序，降序遍历 BST 的元素值，从而契合题目累加树的要求。</p>
<p>BST 相关的问题，要么利用 BST 左小右大的特性提升算法效率，要么利用中序遍历的特性满足题目的要求。</p>
</br>

<h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><p>BST 的基础操作主要依赖「左小右大」的特性，可以在二叉树中做类似二分搜索的操作，寻找一个元素的效率很高。</p>
<ol>
<li>判断 BST 的合法性</li>
</ol>
<ul>
<li><a href="Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.java">98.验证二叉搜索树</a>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZGF0ZS1iaW5hcnktc2VhcmNoLXRyZWUv">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jgoiSe"><img src="https://s1.ax1x.com/2022/07/12/jgoiSe.png" alt="jgoiSe.png"></a></p>
<p>按照 BST 左小右大的特性，每个节点想要判断自己是否是合法的 BST 节点，比较自己和左右子树即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.left != <span class="literal">null</span> &amp;&amp; root.left.val &gt;= root.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.right != <span class="literal">null</span> &amp;&amp; root.right.val &lt;= root.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样会出现问题：BST 的每个节点应该要小于右边子树的所有节点，下面这个二叉树显然不是 BST，因为节点 10 的右子树中有一个节点 6，但是我们的算法会把它判定为合法 BST：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jgIxdx"><img src="https://s1.ax1x.com/2022/07/12/jgIxdx.png" alt="jgIxdx.png"></a></p>
<p>出现问题的原因在于，对于每一个节点 <code>root</code>，代码值检查了它的左右孩子节点是否符合左小右大的原则；但是根据 BST 的定义，<code>root</code> 的整个左子树都要小于 <code>root.val</code>，整个右子树都要大于 <code>root.val</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 限定以 root 为根的子树节点必须满足 max.val &gt; root.val &gt; min.val</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root, TreeNode min, TreeNode max)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST</span></span><br><span class="line">    <span class="keyword">if</span>(min != <span class="literal">null</span> &amp;&amp; root.val &lt;= min.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(max != <span class="literal">null</span> &amp;&amp; root.val &gt;= max.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 限定左子树的最大值是 root.val，右子树的最小值是 root.val</span></span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.left, min, root) &amp;&amp; isValidBST(root.right, root, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用辅助函数，增加函数参数列表，在参数中携带额外信息，将这种约束传递给子树的所有节点。</p>
</br>


<ol start="2">
<li>在 BST 中搜索元素</li>
</ol>
<ul>
<li><a href="Tree/700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.java">700.二叉搜索树中的搜索</a>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZWFyY2gtaW4tYS1iaW5hcnktc2VhcmNoLXRyZWUv">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jgIzo6"><img src="https://s1.ax1x.com/2022/07/12/jgIzo6.png" alt="jgIzo6.png"></a></p>
<p>如果是在一棵普通的二叉树中寻找：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val == val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前节点没找到就递归地去左右子树寻找</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> searchBST(root.left, val);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> searchBST(root.right, val);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这段代码相当于穷举了所有节点，适用于所有二叉树。而这里题目给的是二叉搜索树，因此应该使用二叉搜索树的特点进行查找。不需要递归地搜索两边，类似二分查找思想，根据 <code>val</code> 和 <code>root.val</code> 的大小比较，就能排除一边：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 类似二分查找</span></span><br><span class="line">    <span class="keyword">if</span>(root.val == val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; val) &#123;</span><br><span class="line">        <span class="keyword">return</span> searchBST(root.left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchBST(root.right, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对数据结构的操作无非遍历 + 访问，遍历就是「找」，访问就是「改」。一旦涉及「改」，就类似二叉树的构造问题，函数要返回 <code>TreeNode</code> 类型，并且要对递归调用的返回值进行接收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="comment">// 找到空位置插入新节点</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">    <span class="comment">// BST 中一般不会插入已存在元素</span></span><br><span class="line">    <span class="comment">// if (root.val == val)</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; val) </span><br><span class="line">        root.right = insertIntoBST(root.right, val);</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; val) </span><br><span class="line">        root.left = insertIntoBST(root.left, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>


<ol start="3">
<li>在 BST 中删除一个数</li>
</ol>
<p>与插入操作类似，先「找」再「改」，代码框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">        <span class="comment">// 找到进行删除</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; key) &#123;</span><br><span class="line">        <span class="comment">// 在左子树找</span></span><br><span class="line">        root.left = deleteNode(root.left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; key) &#123;</span><br><span class="line">        <span class="comment">// 在右子树找</span></span><br><span class="line">        root.right = deleteNode(root.right, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点在于如何删除该节点且不破坏 BST 的性质。删除一个节点有三种情况：</p>
<p>情况 1：删除的是叶子结点，没有子树。直接删除。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jgoCWD"><img src="https://s1.ax1x.com/2022/07/12/jgoCWD.png" alt="jgoCWD.png"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>情况 2：删除的是只有一个子树的节点。则让其子树节点代替该节点的位置。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jgoFQH"><img src="https://s1.ax1x.com/2022/07/12/jgoFQH.png" alt="jgoFQH.png"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排除了情况 1 后</span></span><br><span class="line"><span class="keyword">if</span> (root.left == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> root.right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> root.left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>情况 3：删除的是有两个子树的节点。为了不破坏 BST 的性质，需要用左子树中最大的节点，或右子树中最小的节点来代替该节点的位置。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jgokyd"><img src="https://s1.ax1x.com/2022/07/12/jgokyd.png" alt="jgokyd.png"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 找到右子树的最小节点</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">minNode</span> <span class="operator">=</span> getMin(root.right);</span><br><span class="line">    <span class="comment">// 删除 minNode</span></span><br><span class="line">    root.right = deleteNode(root.right, minNode.val);</span><br><span class="line">    <span class="comment">// 把 root 改成 minNode</span></span><br><span class="line">    root.val = minNode.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<ul>
<li><a href="Tree/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.java">450.删除二叉搜索树中的节点</a>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWxldGUtbm9kZS1pbi1hLWJzdC8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jgoAOA"><img src="https://s1.ax1x.com/2022/07/12/jgoAOA.png" alt="jgoAOA.png"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.val == key) &#123;</span><br><span class="line">        <span class="comment">// 处理情况1、2</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理情况3</span></span><br><span class="line">        <span class="comment">// 获取右子树最小的节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">minNode</span> <span class="operator">=</span> getMin(root.right);</span><br><span class="line">        <span class="comment">// 删除右子树最小的节点</span></span><br><span class="line">        root.right = deleteNode(root.right, minNode.val);</span><br><span class="line">        <span class="comment">// 用右子树最小的节点替换 root 节点</span></span><br><span class="line">        minNode.left = root.left;</span><br><span class="line">        minNode.right = root.right;</span><br><span class="line">        root = minNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root .val &gt; key) &#123;</span><br><span class="line">        root.left = deleteNode(root.left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root.right = deleteNode(root.right, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">getMin</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// BST 中最左边的节点就是最小的</span></span><br><span class="line">    <span class="keyword">while</span>(root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        root = root.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在交换 <code>root</code> 和 <code>minNode</code> 时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理情况3</span></span><br><span class="line"><span class="comment">// 获取右子树最小的节点</span></span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">minNode</span> <span class="operator">=</span> getMin(root.right);</span><br><span class="line"><span class="comment">// 删除右子树最小的节点</span></span><br><span class="line">root.right = deleteNode(root.right, minNode.val);</span><br><span class="line"><span class="comment">// 用右子树最小的节点替换 root 节点</span></span><br><span class="line">minNode.left = root.left;</span><br><span class="line">minNode.right = root.right;</span><br><span class="line">root = minNode;</span><br></pre></td></tr></table></figure>

<p>先删除了右子树最小的节点再进行替换，避免在修改完右子树后再去删除，这样会导致超时。并且没有使用更简单的直接将 <code>root.val</code> 替换为 <code>minNode.val</code>，而是进行了一系列复杂链表操作，仅对于这道算法题来说是可以的，但一般不会通过修改节点内部的值来交换节点。因为在实际应用中，BST 节点内部的数据域是用户自定义的，可以非常复杂，而 BST 作为数据结构，其操作应该和内部存储的数据域解耦，所以更倾向于使用指针操作来交换节点而不关心内部数据。</p>
</br>

<h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzk2LiVFNCVCOCU4RCVFNSU5MCU4QyVFNyU5QSU4NCVFNCVCQSU4QyVFNSU4RiU4OSVFNiU5MCU5QyVFNyVCNCVBMiVFNiVBMCU5MS5qYXZh">96.不同的二叉搜索树<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy91bmlxdWUtYmluYXJ5LXNlYXJjaC10cmVlcy8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://files.catbox.moe/6eu9q1.png#crop=0&crop=0&crop=1&crop=1&id=YBUqQ&originHeight=1228&originWidth=1468&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>如输入 <code>n = 5</code>，也就是说用 <code>&#123;1,2,3,4,5&#125;</code> 构造 BST。 首先每个数字都可以作为根节点，假如说 3 作为根节点，左子树节点就是 <code>&#123;1,2&#125;</code> 的组合，右子树就是 <code>&#123;4,5&#125;</code> 的组合。左子树的组合数和右子树的组合数乘积就是 3 作为根节点时的 BST 个数。其他节点也用同样的方法就可以求出该题的答案。</p>
<p>使用递归可以写出代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 计算闭区间 [1, n] 组成的 BST 个数</span></span><br><span class="line">    <span class="keyword">return</span> count(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算闭区间 [lo, hi] 组成的 BST 个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(<span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (lo &gt; hi) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo; i &lt;= hi; i++) &#123;</span><br><span class="line">        <span class="comment">// i 的值作为根节点 root</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> count(lo, i - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> count(i + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="comment">// 左右子树的组合数乘积是 BST 的总数</span></span><br><span class="line">        res += left * right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 base case，显然当 <code>lo &gt; hi</code> 闭区间 <code>[lo, hi]</code> 肯定是个空区间，也就对应着空节点 <code>null</code>，虽然是空节点，但是也是一种情况，所以要返回 1 而不能返回 0。</p>
<p>但这样的时间复杂度非常高，有些已经计算过的在后面再次需要使用时仍会再次计算，因此可以加一个备忘录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 备忘录</span></span><br><span class="line"><span class="type">int</span>[][] memo;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 备忘录的值初始化为 0</span></span><br><span class="line">    memo = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> count(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(<span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (lo &gt; hi) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(memo[lo][hi] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 已经计算过就直接返回</span></span><br><span class="line">        <span class="keyword">return</span> memo[lo][hi];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo; i &lt;= hi; i++) &#123;</span><br><span class="line">        <span class="comment">// i 的值作为根节点 root</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> count(lo, i - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> count(i + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="comment">// 左右子树的组合数乘积是 BST 的总数</span></span><br><span class="line">        res += left * right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将结果存入备忘录</span></span><br><span class="line">    memo[lo][hi] = res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzk1LiVFNCVCOCU4RCVFNSU5MCU4QyVFNyU5QSU4NCVFNCVCQSU4QyVFNSU4RiU4OSVFNiU5MCU5QyVFNyVCNCVBMiVFNiVBMCU5MS1paS5qYXZh">95.不同的二叉搜索树 II<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy91bmlxdWUtYmluYXJ5LXNlYXJjaC10cmVlcy1paS8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://files.catbox.moe/dhbbub.png#crop=0&crop=0&crop=1&crop=1&id=YOt8K&originHeight=1234&originWidth=1460&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>除了与 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzk2LiVFNCVCOCU4RCVFNSU5MCU4QyVFNyU5QSU4NCVFNCVCQSU4QyVFNSU4RiU4OSVFNiU5MCU5QyVFNyVCNCVBMiVFNiVBMCU5MS5qYXZh">#96<i class="fa fa-external-link-alt"></i></span> 相似的需要求可以构造的 BST 数量，还要求将该树都构造出来并将它们的根节点存入一个列表返回。</p>
<p>思路也相似：</p>
<ol>
<li>穷举 <code>root</code> 节点的所有可能。 </li>
<li>递归构造出左右子树的所有合法 BST。 </li>
<li>给 <code>root</code> 节点穷举所有左右子树的组合。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 构造闭区间 [1, n] 组成的 BST </span></span><br><span class="line">    <span class="keyword">return</span> build(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;TreeNode&gt; <span class="title function_">build</span><span class="params">(<span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">    List&lt;TreeNode&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(lo &gt; hi) &#123;</span><br><span class="line">        res.add(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.穷举 root 节点的所有可能</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo; i &lt;= hi; i++) &#123;</span><br><span class="line">        <span class="comment">// 2.递归构造出左右子树的所有合法 BST</span></span><br><span class="line">        List&lt;TreeNode&gt; leftTree = build(lo, i - <span class="number">1</span>);</span><br><span class="line">        List&lt;TreeNode&gt; rightTree = build(i + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="comment">// 3.给 root 节点穷举所有左右子树的组合</span></span><br><span class="line">        <span class="keyword">for</span>(TreeNode left : leftTree) &#123;</span><br><span class="line">            <span class="keyword">for</span>(TreeNode right : rightTree) &#123;</span><br><span class="line">                <span class="comment">// i 作为根节点 root 的值</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(i);</span><br><span class="line">                root.left = left;</span><br><span class="line">                root.right = right;</span><br><span class="line">                res.add(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序代码框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对 nums[lo..hi] 进行切分</span></span><br><span class="line">    <span class="comment">// 使得 nums[lo..p-1] &lt;= nums[p] &lt; nums[p+1..hi]</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(nums, lo, hi);</span><br><span class="line">    <span class="comment">// 去左右子数组进行切分</span></span><br><span class="line">    sort(nums, lo, p - <span class="number">1</span>);</span><br><span class="line">    sort(nums, p + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现快速排序就是一个二叉树的前序遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    print(root.val);</span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>快速排序是先将一个元素排好序，然后再将剩下的元素排好序。</strong></p>
<p>快速排序的核心就是 <code>partition</code> 函数， <code>partition</code> 函数的作用是在 <code>nums[lo..hi]</code> 中寻找一个分界点 <code>p</code>，通过交换元素使得 <code>nums[lo..p-1]</code> 都小于等于 <code>nums[p]</code>，且 <code>nums[p+1..hi]</code> 都大于 <code>nums[p]</code>：</p>
<p><img src="https://files.catbox.moe/po3nwl.png#crop=0&crop=0&crop=1&crop=1&id=oeX9v&originHeight=736&originWidth=1142&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>通过 <code>partition</code> 就可以将 <code>nums[p]</code> 放在正确的位置。再用同样的方法把 <code>p</code> 左边和右边的子数组进行递归用 <code>partition</code> 把剩下的元素也排好序。</p>
<p><strong>从二叉树的视角，我们可以把子数组 nums[lo..hi] 理解成二叉树节点上的值，sort 函数理解成二叉树的遍历函数。</strong></p>
<p>这样，根据每次排序的元素的顺序，快速排序最后形成的二叉树就是一颗二叉搜索树：</p>
<p><img src="https://files.catbox.moe/gcezr2.png#crop=0&crop=0&crop=1&crop=1&id=yEZdr&originHeight=768&originWidth=980&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>但这样就需要考虑二叉搜索树不平衡的问题，在极端情况下会退化成链表，导致操作效率大幅降低。为了避免这种情况，需要引入随机性。常见的方式是在进行排序之前对整个数组执行 「洗牌算法」 进行打乱，或者在 <code>partition</code> 函数中随机选择数组元素作为分界点。</p>
<p>洗牌算法可以参考 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS8zODQuJUU2JTg5JTkzJUU0JUI5JUIxJUU2JTk1JUIwJUU3JUJCJTg0LmphdmE=">#384<i class="fa fa-external-link-alt"></i></span></p>
<p>这样就可以使用代码实现快速排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quick</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 为了避免出现耗时的极端情况，先随机打乱</span></span><br><span class="line">        shuffle(nums);</span><br><span class="line">        <span class="comment">// 排序整个数组（原地修改）</span></span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(lo &gt;= hi) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对 nums[lo..hi] 进行切分</span></span><br><span class="line">        <span class="comment">// 使得 nums[lo..p-1] &lt;= nums[p] &lt; nums[p+1..hi]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(nums, lo, hi);</span><br><span class="line"></span><br><span class="line">        sort(nums, lo, p - <span class="number">1</span>);</span><br><span class="line">        sort(nums, p + <span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[lo];</span><br><span class="line">        <span class="comment">// 这里把 i, j 定义为开区间，同时定义：</span></span><br><span class="line">        <span class="comment">// [lo, i) &lt;= pivot；(j, hi] &gt; pivot</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo + <span class="number">1</span>, j = hi;</span><br><span class="line">        <span class="comment">// 当 i &gt; j 时结束循环，以保证区间 [lo, hi] 都被覆盖</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; hi &amp;&amp; nums[i] &lt;= pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="comment">// 此 while 结束时恰好 nums[i] &gt; pivot</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; lo &amp;&amp; nums[j] &gt; pivot) &#123;</span><br><span class="line">                j--;</span><br><span class="line">                <span class="comment">// 此 while 结束时恰好 nums[j] &lt;= pivot</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时 [lo, i) &lt;= pivot &amp;&amp; (j, hi] &gt; pivot</span></span><br><span class="line">            <span class="comment">// 交换 nums[j] 和 nums[i]</span></span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">            <span class="comment">// 此时 [lo, i] &lt;= pivot &amp;&amp; [j, hi] &gt; pivot</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后将 pivot 放到合适的位置，即 pivot 左边元素较小，右边元素较大</span></span><br><span class="line">        swap(nums, lo, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 洗牌算法，将输入的数组随机打乱</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 生成 [i, n - 1] 的随机数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> i + rand.nextInt(n - i);</span><br><span class="line">            swap(nums, i, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原地交换数组中的两个元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以解决：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzIxNS4lRTYlOTUlQjAlRTclQkIlODQlRTQlQjglQUQlRTclOUElODQlRTclQUMlQUNrJUU0JUI4JUFBJUU2JTlDJTgwJUU1JUE0JUE3JUU1JTg1JTgzJUU3JUI0JUEwLmphdmE=">215. 数组中的第K个最大元素<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMva3RoLWxhcmdlc3QtZWxlbWVudC1pbi1hbi1hcnJheS8=">🔗<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9BcnJheS85MTIuJUU2JThFJTkyJUU1JUJBJThGJUU2JTk1JUIwJUU3JUJCJTg0LmphdmE=">912. 排序数组<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc29ydC1hbi1hcnJheS8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</br>

<h2 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h2><p><code>git pull</code> 这个命令我们经常会用，它默认是使用 <code>merge</code> 方式将远端别人的修改拉到本地；如果带上参数<code>git pull -r</code>，就会使用 <code>rebase</code> 的方式将远端修改拉到本地。</p>
<p>这二者最直观的区别就是：<code>merge</code> 方式合并的分支会看到很多「分叉」，而 <code>rebase</code> 方式合并的分支就是一条直线。但无论哪种方式，如果存在冲突，Git 都会检测出来并让你手动解决冲突。</p>
<p>Git 是如何检测两条分支是否存在冲突的呢？</p>
<p>以 <code>rebase</code> 命令为例，如下图的情况，在 <code>dev</code> 分支执行 <code>git rebase master</code>，<code>dev</code> 就会接到 <code>master</code> 分支之上：</p>
<p><img src="https://s2.loli.net/2022/07/14/Q84MnoJvxsPpeZW.png#crop=0&crop=0&crop=1&crop=1&id=xJBUU&originHeight=648&originWidth=1186&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>首先找到这两条分支的最近公共祖先 LCA，然后从 <code>master</code> 节点开始，重演 LCA 到 <code>dev</code> 几个 <code>commit</code> 的修改，如果这些修改和 LCA 到 <code>master</code> 的 <code>commit</code> 有冲突，就会提示你手动解决冲突，最后的结果就是把 <code>dev</code> 的分支完全接到 <code>master</code> 上面。</p>
</br>

<h3 id="寻找一个元素"><a href="#寻找一个元素" class="headerlink" title="寻找一个元素"></a>寻找一个元素</h3><p>输入一棵没有重复元素的二叉树根节点 <code>root</code> 和一个目标值 <code>val</code>，写一个函数寻找树中值为 <code>val</code> 的节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：在以 root 为根的二叉树中寻找值为 val 的节点</span></span><br><span class="line">TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val == val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// root 不是目标节点，去左子树找</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> find(root.left, val);</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左子树找不到，去左子树找</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> find(root.right, val);</span><br><span class="line">    <span class="keyword">if</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找不到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于这段代码进行修改，首先修改 <code>return</code> 的位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    <span class="keyword">if</span> (root.val == val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// root 不是目标节点，去左右子树找</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> find(root.left, val);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> find(root.right, val);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码也可以达到目的，但实际运行的效率会低一些。这是因为，如果能够在左子树找到目标节点，这段代码还是会去右子树找，所以效率相对差一些。</p>
<p>更进一步，把对 <code>root.val</code> 的判断从前序位置移动到后序位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先去左右子树寻找</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> find(root.left, val);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> find(root.right, val);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">    <span class="keyword">if</span> (root.val == val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码相当于遍历了二叉树的所有节点，就算找到了目标值也需要先去去遍历左右子树，因此效率进一步降低。</p>
<p>现在若将题目修改为寻找值为 <code>val1</code> 或 <code>val2</code> 的节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：在以 root 为根的二叉树中寻找值为 val1 或 val2 的节点</span></span><br><span class="line">TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, <span class="type">int</span> val1, <span class="type">int</span> val2)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    <span class="keyword">if</span> (root.val == val1 || root.val == val2) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去左右子树寻找</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> find(root.left, val1, val2);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> find(root.right, val1, val2);</span><br><span class="line">    <span class="comment">// 后序位置，已经知道左右子树是否存在目标值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>写这个查找的目的在于：最近公共祖先系列问题的解法都是把这个函数作为框架的。</strong></p>
</br>


<h3 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzIzNi4lRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTElRTclOUElODQlRTYlOUMlODAlRTglQkYlOTElRTUlODUlQUMlRTUlODUlQjElRTclQTUlOTYlRTUlODUlODguamF2YQ==">236.二叉树的最近公共祖先<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb3dlc3QtY29tbW9uLWFuY2VzdG9yLW9mLWEtYmluYXJ5LXRyZWUv">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s2.loli.net/2022/07/14/fi5Cq8gJ9banuwZ.png#crop=0&crop=0&crop=1&crop=1&id=QFF7q&originHeight=1020&originWidth=1450&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>如图示例：</p>
<ol>
<li>如果 <code>p</code> 是节点 6，<code>q</code> 是节点 7，那么它们的 LCA 就是节点 5。 </li>
<li>当然，<code>p</code> 和 <code>q</code> 本身也可能是 LCA，比如 <code>p</code> 是节点 4，<code>q</code> 是节点 5， <code>q</code> 本身就是 LCA 节点。</li>
</ol>
<p>两个节点的最近公共祖先其实就是这两个节点向根节点的「延长线」的交汇点。如果一个节点能够在它的左右子树中分别找到 <code>p</code> 和 <code>q</code>，则该节点为 LCA 节点。</p>
<p>因此可以使用前面实现的 <code>find</code> 方法，只需在后序位置添加一个判断逻辑，即可改造成寻找最近公共祖先的解法代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> find(root, p, q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在二叉树中寻找 p 和 q 的最近公共祖先节点</span></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    <span class="keyword">if</span>(root.val == p.val || root.val == q.val) &#123;</span><br><span class="line">        <span class="comment">// 遇到目标值，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> find(root.left, p, q);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> find(root.right, p, q);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序位置，已经知道左右子树是否存在目标值</span></span><br><span class="line">    <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前节点是 LCA 节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>find</code> 函数的后序位置，如果发现 <code>left</code> 和 <code>right</code> 都非空，就说明当前节点是 LCA 节点，即解决了第一种情况。</p>
<p>在 <code>find</code> 函数的前序位置，如果找到一个值为 <code>p</code> 或 <code>q</code> 的节点则直接返回，恰好解决了第二种情况。这是因为题目的 <code>p</code> 和 <code>q</code> 一定存在于二叉树中，所以即便遇到 <code>q</code> 就直接返回，根本没遍历到 <code>p</code>，也依然可以断定 <code>p</code> 在 <code>q</code> 底下，<code>q</code> 就是 LCA 节点。</p>
</br>


<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzE2NzYuJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxJUU3JTlBJTg0JUU2JTlDJTgwJUU4JUJGJTkxJUU1JTg1JUFDJUU1JTg1JUIxJUU3JUE1JTk2JUU1JTg1JTg4LWl2LmphdmE=">1676.二叉树的最近公共祖先 IV<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb3dlc3QtY29tbW9uLWFuY2VzdG9yLW9mLWEtYmluYXJ5LXRyZWUtaXYv">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s1.ax1x.com/2022/07/14/jfM4Xt.png#crop=0&crop=0&crop=1&crop=1&id=VIdLS&originHeight=1110&originWidth=1462&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>与 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzIzNi4lRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTElRTclOUElODQlRTYlOUMlODAlRTglQkYlOTElRTUlODUlQUMlRTUlODUlQjElRTclQTUlOTYlRTUlODUlODguamF2YQ==">#236<i class="fa fa-external-link-alt"></i></span> 不同的是，这道题输入的节点不止两个，而是一个节点列表（所有节点都存在于树中），要寻找列表中所有节点的最近公共祖先。</p>
<p>如图所示，输入 <code>nodes = [7,4,6]</code>，那么函数应该返回节点 5。</p>
<p>解法逻辑与上题类似，只需将 <code>nodes</code> 存入哈希集合来判断遍历到的元素是否存在于 <code>nodes</code> 中（详细见代码）。</p>
<p>需要注意的是，这两道题的题目都明确告诉我们这些节点必定存在于二叉树中，如果没有这个前提条件，就需要修改代码了。</p>
</br>


<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzE2NDQuJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxJUU3JTlBJTg0JUU2JTlDJTgwJUU4JUJGJTkxJUU1JTg1JUFDJUU1JTg1JUIxJUU3JUE1JTk2JUU1JTg1JTg4LWlpLmphdmE=">1644.二叉树的最近公共祖先 II<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb3dlc3QtY29tbW9uLWFuY2VzdG9yLW9mLWEtYmluYXJ5LXRyZWUtaWkv">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s1.ax1x.com/2022/07/14/jflmxs.png#crop=0&crop=0&crop=1&crop=1&id=hSuJi&originHeight=1116&originWidth=1468&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>此时 <code>p</code> 和 <code>q</code> 可能不存在于该二叉树中，因此前面解决标准最近公共祖先问题时 <code>find</code> 方法中前序位置的判断就不可行了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序位置</span></span><br><span class="line"><span class="keyword">if</span> (root.val == val1 || root.val == val2) &#123;</span><br><span class="line">    <span class="comment">// 遇到目标值，直接返回</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这道题来说，<code>p</code> 和 <code>q</code> 不一定存在于树中，所以不能遇到一个目标值就直接返回，而应该对二叉树进行完全搜索（遍历每一个节点），如果发现 <code>p</code> 或 <code>q</code> 不存在于树中，那么是不存在 LCA 的。</p>
<p>在 <a href="#%E5%AF%BB%E6%89%BE%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0">寻找一个元素</a> 小节我们写了几种 <code>find</code> 方法，其中一种是对二叉树进行完整遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先去左右子树寻找</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> find(root.left, val);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> find(root.right, val);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">    <span class="keyword">if</span> (root.val == val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题的也类似，只需要将前序位置的判断放到后序位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录 p、q 是否存在于树中</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">foundP</span> <span class="operator">=</span> <span class="literal">false</span>, foundQ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">res</span> <span class="operator">=</span> find(root, p, q);</span><br><span class="line">    <span class="keyword">if</span> (!foundP || !foundQ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p 和 q 都存在二叉树中，才有公共祖先</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> find(root.left, p, q);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> find(root.right, p, q);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序位置，判断当前节点是不是 LCA 节点</span></span><br><span class="line">    <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root.val == left.val || root.val == right.val) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root.val == left.val) &#123;</span><br><span class="line">            foundP = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val == right.val) &#123;</span><br><span class="line">            foundQ = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对二叉树进行完全搜索，同时记录 <code>p</code> 和 <code>q</code> 是否同时存在树中，从而满足题目的要求。</p>
</br>


<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzIzNS4lRTQlQkElOEMlRTUlOEYlODklRTYlOTAlOUMlRTclQjQlQTIlRTYlQTAlOTElRTclOUElODQlRTYlOUMlODAlRTglQkYlOTElRTUlODUlQUMlRTUlODUlQjElRTclQTUlOTYlRTUlODUlODguamF2YQ==">235. 二叉搜索树的最近公共祖先<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb3dlc3QtY29tbW9uLWFuY2VzdG9yLW9mLWEtYmluYXJ5LXNlYXJjaC10cmVlLw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s1.ax1x.com/2022/07/14/jf1o0x.png#crop=0&crop=0&crop=1&crop=1&id=S0eJz&originHeight=1372&originWidth=1460&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>用前面标准最近公共祖先问题的代码同样可以解决这道题，但没有用到 BST 左小右大的性质，显然不是最优解。</p>
<p>在标准的最近公共祖先问题中，我们要在后序位置通过左右子树的搜索结果来判断当前节点是不是 LCA：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> find(root.left, val1, val2);</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> find(root.right, val1, val2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序位置，判断当前节点是不是 LCA 节点</span></span><br><span class="line"><span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>但对于 BST 来说，根本不需要遍历子树，由于 BST 左小右大的性质，将当前节点的值与 <code>val1</code> 和 <code>val2</code> 作对比即可判断当前节点是不是 LCA：</strong></p>
<p>假设 <code>val1 &lt; val2</code>，那么 <code>val1 &lt;= root.val &lt;= val2</code> 则说明当前节点就是 LCA；若 <code>root.val</code> 比 <code>val1</code> 小，则需要去值更大的右子树寻找 LCA；若 <code>root.val</code> 比 <code>val2</code> 还，则需要去值更小的左子树寻找 LCA。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">val1</span> <span class="operator">=</span> p.val &lt; q.val ? p.val : q.val;</span><br><span class="line">    <span class="type">int</span> <span class="variable">val2</span> <span class="operator">=</span> p.val &gt; q.val ? p.val : q.val;</span><br><span class="line">    <span class="keyword">return</span> find(root, val1, val2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 BST 中寻找 val1 和 val2 的最近公共祖先节点</span></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, <span class="type">int</span> val1, <span class="type">int</span> val2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.val &lt; val1) &#123;</span><br><span class="line">        <span class="comment">// 当前节点太小，去右子树找</span></span><br><span class="line">        <span class="keyword">return</span> find(root.right, val1, val2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.val &gt; val2) &#123;</span><br><span class="line">        <span class="comment">// 当前节点太大，去左子树找</span></span><br><span class="line">        <span class="keyword">return</span> find(root.left, val1, val2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时 val1 &lt;= root.val &lt;= val2</span></span><br><span class="line">    <span class="comment">// 则该节点就是最近公共祖先</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就把 BST 的性质利用上了。</p>
</br>


<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzE2NTAuJUU0JUJBJThDJUU1JThGJTg5JUU2JUEwJTkxJUU3JTlBJTg0JUU2JTlDJTgwJUU4JUJGJTkxJUU1JTg1JUFDJUU1JTg1JUIxJUU3JUE1JTk2JUU1JTg1JTg4LWlpaS5qYXZh">1650.二叉树的最近公共祖先 III<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG93ZXN0LWNvbW1vbi1hbmNlc3Rvci1vZi1hLWJpbmFyeS10cmVlLWlpaS8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s1.ax1x.com/2022/07/14/jf83If.png#crop=0&crop=0&crop=1&crop=1&id=Kb7Jh&originHeight=1262&originWidth=1462&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>由于节点 <code>Node</code> 包含其父节点的引用，因此不需要输入根节点。这道题也就可以转化为单链表相交的问题：<code>parent</code> 就是 <code>next</code> 指针，需要返回两个节点的交点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">lowestCommonAncestor</span><span class="params">(Node p, Node q)</span> &#123;</span><br><span class="line">   <span class="type">Node</span> <span class="variable">a</span> <span class="operator">=</span> p, b = q;</span><br><span class="line">   <span class="keyword">while</span>(a != b) &#123;</span><br><span class="line">       <span class="keyword">if</span>(a == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">// a 走一步，如果走到根节点，转到 q 节点</span></span><br><span class="line">           a = q;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           a = a.parent;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(b == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">// a 走一步，如果走到根节点，转到 q 节点</span></span><br><span class="line">           b = p;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           b = b.parent;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;   </span><br><span class="line">   <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于单链表的交点问题在之前篇章已经讲过，这里不再赘述（<a href="#%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4">#链表相交问题</a>）。</p>
</br>


<h2 id="完全二叉树的节点数"><a href="#完全二叉树的节点数" class="headerlink" title="完全二叉树的节点数"></a>完全二叉树的节点数</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9UcmVlLzIyMi4lRTUlQUUlOEMlRTUlODUlQTglRTQlQkElOEMlRTUlOEYlODklRTYlQTAlOTElRTclOUElODQlRTglOEElODIlRTclODIlQjklRTQlQjglQUElRTYlOTUlQjAuamF2YQ==">222.完全二叉树的节点个数<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY291bnQtY29tcGxldGUtdHJlZS1ub2Rlcy8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s1.ax1x.com/2022/07/14/jfY2Qg.png#crop=0&crop=0&crop=1&crop=1&id=y52JL&originHeight=1192&originWidth=1432&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>第一时间可以想到遍历整棵树来计算节点个数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> traverse(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> traverse(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> traverse(root.right);</span><br><span class="line">    <span class="keyword">return</span> left + right + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这样的时间复杂度为 <code>O(N)</code>，而且并没有利用到它是一颗完全二叉树这个前提。</p>
<p>首先要明确一下两个关于二叉树的名词「完全二叉树」和「满二叉树」。</p>
<p>完全二叉树如下图，每一层都是紧凑靠左排列的：</p>
<p><img src="https://s1.ax1x.com/2022/07/14/jftTHA.png#crop=0&crop=0&crop=1&crop=1&id=bHZZT&originHeight=335&originWidth=640&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>满二叉树如下图，是一种特殊的完全二叉树，每层都是是满的，像一个稳定的三角形：</p>
<p><img src="https://s1.ax1x.com/2022/07/14/jftoBd.png#crop=0&crop=0&crop=1&crop=1&id=Ntqko&originHeight=181&originWidth=397&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>若要求一颗普通的树的节点数，可以通过上面代码遍历所有节点进行统计:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + countNodes(root.left) + countNodes(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而若要求一颗满二叉树的节点数，节点总数就和树的高度呈指数关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算树的高度</span></span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        root = root.left;</span><br><span class="line">        h++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 节点总数就是 2^h - 1</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">2</span>, h) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完全二叉树比普通二叉树特殊，但又没有满二叉树那么特殊，计算它的节点总数，可以是普通二叉树和完全二叉树的结合版：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">l</span> <span class="operator">=</span> root, r = root;</span><br><span class="line">    <span class="comment">// 沿最左侧和最右侧分别计算高度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hl</span> <span class="operator">=</span> <span class="number">0</span>, hr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l != <span class="literal">null</span>) &#123;</span><br><span class="line">        l = l.left;</span><br><span class="line">        hl++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">        r = r.right;</span><br><span class="line">        hr++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果左右侧计算的高度相同，则是一棵满二叉树</span></span><br><span class="line">    <span class="keyword">if</span> (hl == hr) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">2</span>, hl) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果左右侧的高度不同，则按照普通二叉树的逻辑计算</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + countNodes(root.left) + countNodes(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分情况来选择不同的方式计算节点数，时间复杂度是 <code>O(logN*logN)</code>。</p>
</br>

<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="图的逻辑结构和具体实现"><a href="#图的逻辑结构和具体实现" class="headerlink" title="图的逻辑结构和具体实现"></a>图的逻辑结构和具体实现</h2><p>一幅图是由节点和边构成的，逻辑结构如下：</p>
<p><img src="https://s1.ax1x.com/2022/07/16/j4XVQs.jpg#crop=0&crop=0&crop=1&crop=1&id=p1vFh&originHeight=301&originWidth=423&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>根据这个逻辑结构，可以认为每个节点的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图节点的逻辑结构</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    Vertex[] neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它和多叉树节点几乎完全一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本的 N 叉树节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode[] children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，图本质上就是个高级的多叉树，适用于树的 DFS&#x2F;BFS 遍历算法，全部适用于图。</p>
<p>不过上面的这种实现是「逻辑上的」，实际上很少用 <code>Vertex</code> 类实现图，而是用邻接表和邻接矩阵来实现。</p>
<p>如上图所示的图，用邻接表和邻接矩阵的存储方式如下：</p>
<p><img src="https://s1.ax1x.com/2022/07/16/j4ji0x.png#crop=0&crop=0&crop=1&crop=1&id=Zu0Z5&originHeight=718&originWidth=1194&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>邻接表很直观，把每个节点 <code>x</code> 的邻居都存到一个列表里，然后把 <code>x</code> 和这个列表关联起来，这样就可以通过一个节点 <code>x</code> 找到它的所有相邻节点。</p>
<p>邻接矩阵则是一个二维布尔数组，称为 <code>matrix</code>，如果节点 <code>x</code> 和 <code>y</code> 是相连的，那么就把 <code>matrix[x][y]</code> 设为 <code>true</code>（上图中绿色的方格代表 <code>true</code>）。如果想找节点 <code>x</code> 的邻居，去扫一圈 <code>matrix[x][..]</code> 就可以了。</p>
<p>如果用代码的形式来表现，邻接表和邻接矩阵大概长这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 邻接表</span></span><br><span class="line"><span class="comment">// graph[x] 存储 x 的所有邻居节点</span></span><br><span class="line">List&lt;Integer&gt;[] graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="comment">// matrix[x][y] 记录 x 是否有一条指向 y 的边</span></span><br><span class="line"><span class="type">boolean</span>[][] matrix;</span><br></pre></td></tr></table></figure>

<p>对于邻接表，优点是占用的空间少。但邻接表无法快速判断两个节点是否相邻。</p>
<p>对于邻接表，优点是可以快速判断两个节点是否相邻，只需要判断 <code>matrix[i][j]</code> 是否为 <code>true</code>。但占用的空间大。</p>
<blockquote>
<p>在常规的算法题中，邻接表的使用会更频繁一些，主要是因为操作起来较为简单，但这不意味着邻接矩阵应该被轻视。矩阵是一个强有力的数学工具，图的一些隐晦性质可以借助精妙的矩阵运算展现出来。</p>
</blockquote>
<p>图论中的度(degree)：在无向图中，「度」就是每个节点相连的边的条数。</p>
<p>由于有向图的边有方向，所以有向图中每个节点「度」被细分为入度（indegree）和出度（outdegree），如下图：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/16/ce98179a2c5048b1.png#crop=0&crop=0&crop=1&crop=1&id=HkyLU&originHeight=301&originWidth=423&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>其中节点 <code>3</code> 的入度为 3（有三条边指向它），出度为 1（它有 1 条边指向别的节点）。</p>
<p>其他更复杂的模型都是基于这个最简单的图衍生出来的。</p>
</br>


<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>参考多叉树的 DFS 遍历框架如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多叉树遍历框架</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode child : root.children) &#123;</span><br><span class="line">        traverse(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图和多叉树最大的区别是，图是可能包含环的，从图的某一个节点开始遍历，有可能走了一圈又回到这个节点，而树不会出现这种情况，从某个节点出发必然走到叶子节点，不会回到它自身。</p>
<p>所以，如果图包含环，遍历框架就要一个 <code>visited</code> 数组进行辅助：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录被遍历过的节点</span></span><br><span class="line"><span class="type">boolean</span>[] visited;</span><br><span class="line"><span class="comment">// 记录从起点到当前节点的路径</span></span><br><span class="line"><span class="type">boolean</span>[] onPath;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图遍历框架</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Graph graph, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (visited[s]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 经过节点 s，标记为已遍历</span></span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 做选择：标记节点 s 在路径上</span></span><br><span class="line">    onPath[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> neighbor : graph.neighbors(s)) &#123;</span><br><span class="line">        traverse(graph, neighbor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 撤销选择：节点 s 离开路径</span></span><br><span class="line">    onPath[s] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 <code>visited</code> 和 <code>onPath</code> 数组的区别，前者用于记录节点是否被遍历过，后者用于记录从起点到当前节点的路径。<code>onPath</code> 在处理路径相关的问题时可以用到。</p>
</br>


<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9HcmFwaC83OTcuJUU2JTg5JTgwJUU2JTlDJTg5JUU1JThGJUFGJUU4JTgzJUJEJUU3JTlBJTg0JUU4JUI3JUFGJUU1JUJFJTg0LmphdmE=">797.所有可能的路径<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hbGwtcGF0aHMtZnJvbS1zb3VyY2UtdG8tdGFyZ2V0Lw==">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://i.bmp.ovh/imgs/2022/07/16/93d0535f299a3f84.png#crop=0&crop=0&crop=1&crop=1&id=llY6T&originHeight=1152&originWidth=1438&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>以 <code>0</code> 为起点遍历图，同时记录遍历过的路径，当遍历到终点时将路径记录下来即可。由于输入的图是无环图，因此不需要使用 <code>visited</code> 数组辅助：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录所有路径</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">allPathsSourceTarget</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">    <span class="comment">// 维护递归过程中经过的路径</span></span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    traverse(graph, <span class="number">0</span>, path);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图的遍历框架</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(<span class="type">int</span>[][] graph, <span class="type">int</span> s, LinkedList&lt;Integer&gt; path)</span> &#123;</span><br><span class="line">    <span class="comment">// 添加节点 s 到路径</span></span><br><span class="line">    path.addLast(s);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> graph.length;</span><br><span class="line">    <span class="keyword">if</span>(s == n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 到达终点</span></span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">        path.removeLast();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归每个相邻节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v : graph[s]) &#123;</span><br><span class="line">        traverse(graph, v, path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从路径移出节点 s</span></span><br><span class="line">    path.removeLast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 Java 的语言特性，因为 Java 函数参数传的是对象引用，所以向 <code>res</code> 中添加 <code>path</code> 时需要拷贝一个新的列表，否则最终 <code>res</code> 中的列表都是空的。</p>
</br>


<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h3 id="环检测算法-DFS"><a href="#环检测算法-DFS" class="headerlink" title="环检测算法(DFS)"></a>环检测算法(DFS)</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9HcmFwaC8yMDcuJUU4JUFGJUJFJUU3JUE4JThCJUU4JUExJUE4LmphdmE=">207.课程表<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3Vyc2Utc2NoZWR1bGU=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://i.bmp.ovh/imgs/2022/07/16/fc7f1a7787d947d1.png#crop=0&crop=0&crop=1&crop=1&id=WCmtw&originHeight=770&originWidth=1462&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>当存在循环依赖时，无法修完所有课程。<strong>依赖问题首先想到的是把问题转化成「有向图」，只要图中存在环，那就说明存在循环依赖。</strong></p>
<p>可以把课程看成「有向图」中的节点，节点编号分别是 <code>0, 1, ..., numCourses-1</code>，把课程之间的依赖关系看做节点之间的有向边。如必须修完课程 <code>1</code> 才能修课程 <code>3</code>，那么就有一条有向边从节点 <code>1</code> 指向 <code>3</code>。</p>
<p>如果生成当有向图中存在环，说明课程之间存在循环依赖，无法全部上完；反之，如果没有环，就可以完成全部课程。</p>
<p>使用邻接表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt;[] graph;</span><br></pre></td></tr></table></figure>

<p><code>graph[s]</code> 是一个列表，存储着节点 <code>s</code> 所指向的节点。生成图：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt;[] buildGraph(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">    <span class="comment">// 图中共有 numCourses 个节点</span></span><br><span class="line">    List&lt;Integer&gt;[] graph = <span class="keyword">new</span> <span class="title class_">LinkedList</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        graph[i] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] edge : prerequisites) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edge[<span class="number">1</span>], to = edge[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 添加一条从 from 指向 to 的有向边</span></span><br><span class="line">        <span class="comment">// 边的方向是「被依赖」关系，即修完课程 from 才能修课程 to</span></span><br><span class="line">        graph[from].add(to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历图：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防止重复遍历同一个节点</span></span><br><span class="line"><span class="type">boolean</span>[] visited;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt;[] graph = buildGraph(numCourses, prerequisites);</span><br><span class="line">    </span><br><span class="line">    visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        traverse(graph, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从节点 s 开始 DFS 遍历，将遍历过的节点标记为 true</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(List&lt;Integer&gt;[] graph, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(visited[s]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 前序遍历代码位置 */</span></span><br><span class="line">    <span class="comment">// 将当前节点标记为已遍历</span></span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t : graph[s]) &#123;</span><br><span class="line">        traverse(graph, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 后序遍历代码位置 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意图中并不是所有节点都相连，所以要用一个 for 循环将所有节点都作为起点调用一次 DFS 搜索算法。<br>只需要再添加一个布尔数组 <code>onPath</code> 记录当前 <code>traverse</code> 经过的路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span>[] onPath;</span><br><span class="line"><span class="type">boolean</span>[] visited;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">hasCycle</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(List&lt;Integer&gt;[] graph, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (onPath[s]) &#123;</span><br><span class="line">        <span class="comment">// 发现环</span></span><br><span class="line">        hasCycle = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (visited[s] || hasCycle) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将节点 s 标记为已遍历</span></span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 开始遍历节点 s</span></span><br><span class="line">    onPath[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t : graph[s]) &#123;</span><br><span class="line">        traverse(graph, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 节点 s 遍历完成</span></span><br><span class="line">    onPath[s] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在进入节点 <code>s</code> 的时候将 <code>onPath[s]</code> 标记为 <code>true</code>，离开时标记回 <code>false</code>，如果发现 <code>onPath[s]</code> 已经被标记，说明出现了环。</p>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录遍历过的节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span>[] visited;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录一次递归堆栈中的节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span>[] onPath;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录图中是否有环</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">hasCycle</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt;[] graph = buildGraph(numCourses, prerequisites);</span><br><span class="line"></span><br><span class="line">    visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[numCourses];</span><br><span class="line">    onPath = <span class="keyword">new</span> <span class="title class_">boolean</span>[numCourses];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        traverse(graph, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !hasCycle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;Integer&gt;[] buildGraph(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">    List&lt;Integer&gt;[] graph = <span class="keyword">new</span> <span class="title class_">LinkedList</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        graph[i] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>[] edge : prerequisites) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edge[<span class="number">1</span>], to = edge[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 边的方向是「被依赖」关系，即修完课程 from 才能修课程 to</span></span><br><span class="line">        graph[from].add(to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(List&lt;Integer&gt;[] graph, <span class="type">int</span> s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(onPath[s]) &#123;</span><br><span class="line">        <span class="comment">// 存在环</span></span><br><span class="line">        hasCycle = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(visited[s] || hasCycle) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    onPath[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t : graph[s])&#123;</span><br><span class="line">        traverse(graph, t);</span><br><span class="line">    &#125;</span><br><span class="line">    onPath[s] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h3 id="拓扑排序算法-DFS"><a href="#拓扑排序算法-DFS" class="headerlink" title="拓扑排序算法(DFS)"></a>拓扑排序算法(DFS)</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9HcmFwaC8yMTAuJUU4JUFGJUJFJUU3JUE4JThCJUU4JUExJUE4LWlpLmphdmE=">210.课程表 II<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY291cnNlLXNjaGVkdWxlLWlp">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://i.bmp.ovh/imgs/2022/07/16/d982dfeffc93194d.png#crop=0&crop=0&crop=1&crop=1&id=X0XWi&originHeight=746&originWidth=1450&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>与 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9HcmFwaC8yMDcuJUU4JUFGJUJFJUU3JUE4JThCJUU4JUExJUE4LmphdmE=">#207<i class="fa fa-external-link-alt"></i></span> 不同的事，需要进一步返回一个合理的上课顺序，保证开始修每个课程时，前置的课程都已经修完。</p>
<p>如果一幅有向图中存在环，是无法进行 <span class="exturl" data-url="aHR0cHM6Ly9iYWlqaWFoYW8uYmFpZHUuY29tL3M/aWQ9MTcxNzY1Mjk5OTg3NDE1NDkwOSZ3ZnI9c3BpZGVyJmZvcj1wYw==">拓扑排序<i class="fa fa-external-link-alt"></i></span> 的。如果把课程抽象成节点，课程之间的依赖关系抽象成有向边，那么拓扑排序结果就是上课顺序。</p>
<p><strong>将后序遍历的结果进行反转，就是拓扑排序的结果。</strong></p>
<blockquote>
<p>是否需要反转看的是对边的定义，即依赖与被依赖关系。</p>
</blockquote>
<p>对于环的判断，可以使用上提的主函数，完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录后序遍历结果</span></span><br><span class="line">List&lt;Integer&gt; postorder = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 记录是否存在环</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">hasCycle</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">boolean</span>[] visited, onPath;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">    List&lt;Integer&gt;[] graph = buildGraph(numCourses, prerequisites);</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[numCourses];</span><br><span class="line">    onPath = <span class="keyword">new</span> <span class="title class_">boolean</span>[numCourses];</span><br><span class="line">    <span class="comment">// 遍历图</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        traverse(graph, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有环图无法进行拓扑排序</span></span><br><span class="line">    <span class="keyword">if</span> (hasCycle) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 逆后序遍历结果即为拓扑排序结果</span></span><br><span class="line">    Collections.reverse(postorder);</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        res[i] = postorder.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图遍历函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(List&lt;Integer&gt;[] graph, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (onPath[s]) &#123;</span><br><span class="line">        <span class="comment">// 发现环</span></span><br><span class="line">        hasCycle = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (visited[s] || hasCycle) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序遍历位置</span></span><br><span class="line">    onPath[s] = <span class="literal">true</span>;</span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t : graph[s]) &#123;</span><br><span class="line">        traverse(graph, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后序遍历位置</span></span><br><span class="line">    postorder.add(s);</span><br><span class="line">    onPath[s] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt;[] buildGraph(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h3 id="环检测算法-BFS"><a href="#环检测算法-BFS" class="headerlink" title="环检测算法(BFS)"></a>环检测算法(BFS)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">    <span class="comment">// 建图，有向边代表「被依赖」关系</span></span><br><span class="line">    List&lt;Integer&gt;[] graph = buildGraph(numCourses, prerequisites);</span><br><span class="line">    <span class="comment">// 构建入度数组</span></span><br><span class="line">    <span class="type">int</span>[] indegree = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] edge : prerequisites) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edge[<span class="number">1</span>], to = edge[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 节点 to 的入度加一</span></span><br><span class="line">        indegree[to]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据入度初始化队列中的节点</span></span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 节点 i 没有入度，即没有依赖的节点</span></span><br><span class="line">            <span class="comment">// 可以作为拓扑排序的起点，加入队列</span></span><br><span class="line">            q.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录遍历的节点个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 开始执行 BFS 循环</span></span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 弹出节点 cur，并将它指向的节点的入度减一</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> next : graph[cur]) &#123;</span><br><span class="line">            indegree[next]--;</span><br><span class="line">            <span class="keyword">if</span> (indegree[next] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果入度变为 0，说明 next 依赖的节点都已被遍历</span></span><br><span class="line">                q.offer(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有节点都被遍历过，说明不成环</span></span><br><span class="line">    <span class="type">return</span> <span class="variable">count</span> <span class="operator">=</span>= numCourses;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt;[] buildGraph(<span class="type">int</span> n, <span class="type">int</span>[][] edges) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>构建邻接表，边的方向表示「被依赖」关系。 </li>
<li>构建一个 <code>indegree</code> 数组记录每个节点的入度，即 <code>indegree[i]</code> 记录节点 <code>i</code> 的入度。 </li>
<li>对 BFS 队列进行初始化，将入度为 0 的节点首先装入队列。 </li>
<li>开始执行 BFS 循环，不断弹出队列中的节点，减少相邻节点的入度，并将入度变为 0 的节点加入队列。 </li>
<li>如果最终所有节点都被遍历过（<code>count</code> 等于节点数），则说明不存在环，反之则说明存在环。</li>
</ol>
<p><img src="https://i.bmp.ovh/imgs/2022/07/16/c72d2bb208786b4d.png#crop=0&crop=0&crop=1&crop=1&id=n6sqn&originHeight=674&originWidth=1494&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>如果存在节点没有被遍历即，那么说明图中存在环。</p>
</br>


<h3 id="拓扑排序-BFS"><a href="#拓扑排序-BFS" class="headerlink" title="拓扑排序(BFS)"></a>拓扑排序(BFS)</h3><p>由上面的思路可以发现，图中每个节点入队的顺序就是一个可行的拓扑排序结果。</p>
<p>因此只需要修改 BFS 版本的环检测算法，记录节点的遍历顺序即可得到拓扑排序的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">    <span class="comment">// 建图，和环检测算法相同</span></span><br><span class="line">    List&lt;Integer&gt;[] graph = buildGraph(numCourses, prerequisites);</span><br><span class="line">    <span class="comment">// 计算入度，和环检测算法相同</span></span><br><span class="line">    <span class="type">int</span>[] indegree = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] edge : prerequisites) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edge[<span class="number">1</span>], to = edge[<span class="number">0</span>];</span><br><span class="line">        indegree[to]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据入度初始化队列中的节点，和环检测算法相同</span></span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            q.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录拓扑排序结果</span></span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">    <span class="comment">// 记录遍历节点的顺序（索引）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 开始执行 BFS 算法</span></span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">        <span class="comment">// 弹出节点的顺序即为拓扑排序结果</span></span><br><span class="line">        res[count] = cur;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> next : graph[cur]) &#123;</span><br><span class="line">            indegree[next]--;</span><br><span class="line">            <span class="keyword">if</span> (indegree[next] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.offer(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count != numCourses) &#123;</span><br><span class="line">        <span class="comment">// 存在环，拓扑排序不存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建图函数</span></span><br><span class="line">List&lt;Integer&gt;[] buildGraph(<span class="type">int</span> n, <span class="type">int</span>[][] edges) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 BFS 算法是通过 <code>indegree</code> 数组实现的 <code>visited</code> 数组的作用，只有入度为 <code>0</code> 的节点才能入队，从而保证不会出现死循环。</p>
</br>

<h2 id="二分图判定"><a href="#二分图判定" class="headerlink" title="二分图判定"></a>二分图判定</h2><h3 id="二分图简介"><a href="#二分图简介" class="headerlink" title="二分图简介"></a>二分图简介</h3><p>百度百科对「二分图」的定义：</p>
<blockquote>
<p>二分图的顶点集可分割为两个互不相交的子集，图中每条边依附的两个顶点都分属于这两个子集，且两个子集内的顶点不相邻。</p>
</blockquote>
<p><img src="https://i.bmp.ovh/imgs/2022/07/17/8cff726790465c70.png#crop=0&crop=0&crop=1&crop=1&id=pgD7S&originHeight=922&originWidth=960&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>其实就是「双色问题」：用两种颜色将图中的所有顶点着色，且使得任意一条边的两个端点的颜色都不相同。</p>
<p>这个问题就等同于二分图的判定问题，如果能够成功地将图染色，那么这幅图就是一幅二分图，反之则不是：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/07/17/f70c199ad17d839d.png#crop=0&crop=0&crop=1&crop=1&id=oQkMq&originHeight=642&originWidth=1114&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>二分图作为一种特殊的图模型，会被很多高级图算法（比如最大流算法）用到。二分图结构在某些场景可以更高效地存储数据。</p>
<h3 id="二分图判定思路"><a href="#二分图判定思路" class="headerlink" title="二分图判定思路"></a>二分图判定思路</h3><p>判定二分图就是用代码解决「双色问题」：<strong>遍历一遍图，一边遍历一边染色，看看能不能用两种颜色给所有节点染色，且相邻节点的颜色都不相同。</strong></p>
<p>首先可以写出图的遍历框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span>[] visited;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Graph graph, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(visited[v]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(TreeNode neighbor : graph.neighbors(v)) &#123;</span><br><span class="line">        traverse(graph, neighbor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为图中可能存在环，所以用 <code>visited</code> 数组防止死循环。</p>
<p>也可以把判断是否走过放在其他地方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span>[] visited;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Graph graph, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="comment">// 前序遍历位置，标记节点 v 已访问</span></span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> neighbor : graph.neighbors(v)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">            <span class="comment">// 只遍历没标记过的相邻节点</span></span><br><span class="line">            traverse(graph, neighbor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法把对 <code>visited</code> 的判断放到递归调用之前，和之前的写法唯一的不同是需要保证调用 <code>traverse(v)</code> 的时候，<code>visited[v] == false</code>。</p>
<p>这样就可以写出二分图判定的代码逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Graph graph, <span class="type">boolean</span>[] visited, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 遍历节点 v 的所有相邻节点 neighbor</span></span><br><span class="line">    <span class="keyword">for</span>(TreeNode neighbor : graph.neighbors(v)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">            <span class="comment">// 如果没访问过，就给节点 neighbor 涂上与 v 不同的颜色</span></span><br><span class="line">            traverse(graph, visited, neighbor);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 相邻节点 neighbor 已经被访问过</span></span><br><span class="line">            <span class="comment">// 那么应该比较节点 neighbor 和节点 v 的颜色</span></span><br><span class="line">            <span class="comment">// 若相同，则此图不是二分图</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9HcmFwaC83ODUuJUU1JTg4JUE0JUU2JTk2JUFEJUU0JUJBJThDJUU1JTg4JTg2JUU1JTlCJUJFLmphdmE=">785.判断二分图<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pcy1ncmFwaC1iaXBhcnRpdGUv">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://i.bmp.ovh/imgs/2022/07/17/9009c2c644e1cb1e.png#crop=0&crop=0&crop=1&crop=1&id=Yrwd3&originHeight=1360&originWidth=1432&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>可以额外使用一个 color 数组来记录每个节点的颜色：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录图是否符合二分图性质</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">ok</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 记录图中节点的颜色，false 和 true 代表两种不同颜色</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span>[] color;</span><br><span class="line"><span class="comment">// 记录图中节点是否被访问过</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span>[] visited;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBipartite</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">    color = <span class="keyword">new</span> <span class="title class_">boolean</span>[graph.length];</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[graph.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为图不一定是联通的，可能存在多个子图</span></span><br><span class="line">    <span class="comment">// 所以要把每个节点都作为起点进行一次遍历</span></span><br><span class="line">    <span class="comment">// 如果发现任何一个子图不是二分图，整幅图都不算二分图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i]) &#123;</span><br><span class="line">            traverse(graph, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(<span class="type">int</span>[][] graph, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!ok) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> w : graph[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[w]) &#123;</span><br><span class="line">            <span class="comment">// 相邻节点 w 没有被访问过</span></span><br><span class="line">            <span class="comment">// 给节点 w 涂上和节点 v 不同的颜色</span></span><br><span class="line">            color[w] = !color[v];</span><br><span class="line">            <span class="comment">// 继续遍历 w</span></span><br><span class="line">            traverse(graph, w);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 相邻节点 w 已经被访问过</span></span><br><span class="line">            <span class="comment">// 根据 v 和 w 的颜色判断是否是二分图</span></span><br><span class="line">            <span class="keyword">if</span>(color[w] == color[v]) &#123;</span><br><span class="line">                <span class="comment">// 若相同，则此图不是二分图</span></span><br><span class="line">                ok = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9HcmFwaC84ODYuJUU1JThGJUFGJUU4JTgzJUJEJUU3JTlBJTg0JUU0JUJBJThDJUU1JTg4JTg2JUU2JUIzJTk1LmphdmE=">886.可能的二分法<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wb3NzaWJsZS1iaXBhcnRpdGlvbi8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://i.bmp.ovh/imgs/2022/07/17/0bf7a7e4dcfa0edf.png#crop=0&crop=0&crop=1&crop=1&id=hFvS5&originHeight=1110&originWidth=1460&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>如果把每个人看做图中的节点，相互讨厌的关系看做图中的边，那么 <code>dislikes</code> 数组就可以构成一幅图。</p>
<p>又因为互相讨厌的人不能放在同一组里，相当于图中的所有相邻节点都要放进两个不同的组。</p>
<p>这就回到了「双色问题」，如果能够用两种颜色着色所有节点，且相邻节点颜色都不同，那么按照颜色把这些节点分成两组就可以了。</p>
<p>把 <code>dislikes</code> 构造成一幅图，然后执行二分图的判定算法即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">ok</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span>[] color;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span>[] visited;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">possibleBipartition</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] dislikes)</span> &#123;</span><br><span class="line">    <span class="comment">// 图节点编号从 1 开始</span></span><br><span class="line">    color = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转化成邻接表表示图结构</span></span><br><span class="line">    List&lt;Integer&gt;[] graph = buildGraph(n, dislikes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i]) &#123;</span><br><span class="line">            traverse(graph, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;Integer&gt;[] buildGraph(<span class="type">int</span> n, <span class="type">int</span>[][] dislikes) &#123;</span><br><span class="line">    <span class="comment">// 图节点编号为 1...n</span></span><br><span class="line">    List&lt;Integer&gt;[] graph = <span class="keyword">new</span> <span class="title class_">LinkedList</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        graph[i] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>[] edge : dislikes) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> edge[<span class="number">1</span>], w = edge[<span class="number">0</span>];</span><br><span class="line">        graph[v].add(w);</span><br><span class="line">        graph[w].add(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(List&lt;Integer&gt;[] graph, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!ok) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> w : graph[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[w]) &#123;</span><br><span class="line">            color[w] = !color[v];</span><br><span class="line">            traverse(graph, w);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(color[w] == color[v]) &#123;</span><br><span class="line">                ok = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h2 id="并查集-UNION-FIND-算法"><a href="#并查集-UNION-FIND-算法" class="headerlink" title="并查集(UNION-FIND)算法"></a>并查集(UNION-FIND)算法</h2><p>Union-Find 算法，也就是常说的并查集（Disjoint Set）结构，主要是解决图论中「动态连通性」问题的。</p>
<p>动态连通性其实可以抽象成给一幅图连线。比如下面这幅图，总共有 10 个节点，他们互不相连，分别用 0~9 标记：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/07/17/f728d0b913a522eb.png#crop=0&crop=0&crop=1&crop=1&id=dQJAc&originHeight=744&originWidth=854&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>Union-Find 算法主要需要实现这两个 API：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">    <span class="comment">/* 将 p 和 q 连接 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>;</span><br><span class="line">    <span class="comment">/* 判断 p 和 q 是否连通 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>;</span><br><span class="line">    <span class="comment">/* 返回图中有多少个连通分量 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里所说的「连通」是一种等价关系，也就是说具有如下三个性质：</p>
<ol>
<li>自反性：节点 <code>p</code> 和 <code>p</code> 是连通的。 </li>
<li>对称性：如果节点 <code>p</code> 和 <code>q</code> 连通，那么 <code>q</code> 和 <code>p</code> 也连通。 </li>
<li>传递性：如果节点 <code>p</code> 和 <code>q</code> 连通，<code>q</code> 和 <code>r</code> 连通，那么 <code>p</code> 和 <code>r</code> 也连通。</li>
</ol>
<p>比如 0～9 任意两个不同的点都不连通，调用 <code>connected</code> 都会返回 <code>false</code>，连通分量为 10 个。</p>
<p>如果调用 <code>union(0, 1)</code>，那么 0 和 1 被连通，连通分量降为 9 个。</p>
<p>再调用 <code>union(1, 2)</code>，这时 0, 1, 2 都被连通，调用 <code>connected(0, 2)</code> 也会返回 <code>true</code>，连通分量变为 8 个。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/17/c0dc0dfc657d0867.png#crop=0&crop=0&crop=1&crop=1&id=ojq3K&originHeight=736&originWidth=840&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>判断这种「等价关系」非常实用，如编译器判断同一个变量的不同引用、社交网络中的朋友圈计算等。</p>
</br>


<h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>可以使用森林（若干棵树）来表示图的动态连通性，用数组来具体实现这个森林。</p>
<p>设定树的每个节点有一个指针指向其父节点，如果是根节点的话，这个指针指向自己。如上图一开始的时候没有相互连通：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/17/a63c386fe86d030e.png#crop=0&crop=0&crop=1&crop=1&id=WIHzU&originHeight=310&originWidth=916&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">    <span class="comment">// 记录连通分量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="comment">// 节点 x 的父节点是 parent[x]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造函数，n 为图的节点总数 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UF</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 一开始互不联通</span></span><br><span class="line">        <span class="built_in">this</span>.count = n;</span><br><span class="line">        <span class="comment">// 父节点指针初始指向自己</span></span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果某两个节点被连通，则让其中的（任意）一个节点的根节点接到另一个节点的根节点上：</strong></p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/17/e4470285be9e73a5.png#crop=0&crop=0&crop=1&crop=1&id=zgTLF&originHeight=862&originWidth=2188&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">    <span class="keyword">if</span>(rootP == rootQ) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将两棵树合并为一棵</span></span><br><span class="line">    parent[rootP] = rootQ;</span><br><span class="line">    <span class="comment">// 也可以使用 parent[rootQ] = rootP </span></span><br><span class="line">    <span class="comment">// 两个分量合二为一，连通分量减一</span></span><br><span class="line">    count--; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 返回某个节点 x 的根节点 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// 根节点的 parent[x] == x</span></span><br><span class="line">    <span class="keyword">while</span>(parent[x] != x) &#123;</span><br><span class="line">        x = parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回当前的连通分量个数 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，如果节点 <code>p</code> 和 <code>q</code> 连通的话，它们一定拥有相同的根节点：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/17/84fc607aef987b2c.png#crop=0&crop=0&crop=1&crop=1&id=q8s6Z&originHeight=928&originWidth=2192&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">    <span class="type">return</span> <span class="variable">rootP</span> <span class="operator">=</span>= rootQ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，Union-Find 算法就基本完成了。</p>
</br>


<h3 id="平衡性优化"><a href="#平衡性优化" class="headerlink" title="平衡性优化"></a>平衡性优化</h3><p>这个算法的主要 API <code>connected</code> 和 <code>union</code> 中的复杂度都是 <code>find</code> 函数造成的，所以说它们的复杂度和 <code>find</code> 一样。</p>
<p><code>find</code> 主要功能就是从某个节点向上遍历到树根，其时间复杂度就是树的高度。我们可能习惯性地认为树的高度就是 <code>logN</code>，但这并不一定。<code>logN</code> 的高度只存在于平衡二叉树，对于一般的树可能出现极端不平衡的情况，使得「树」几乎退化成「链表」，树的高度最坏情况下可能变成 <code>N</code>。</p>
<p>所以上面这种解法 <code>find</code> , <code>union</code> , <code>connected</code> 的时间复杂度都是 <code>O(N)</code>。</p>
<p>因此需要考虑如何避免树的不平衡，关键在于 <code>union</code> 过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">    <span class="keyword">if</span> (rootP == rootQ) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    parent[rootP] = rootQ;</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里直接把 <code>p</code> 所在的树接到 <code>q</code> 所在的树的根节点下面，就可能出现「头重脚轻」的不平衡状况，比如下面这种局面：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/17/ce502110e6817313.png#crop=0&crop=0&crop=1&crop=1&id=ike3X&originHeight=1028&originWidth=1226&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>长此以往，树可能生长得很不平衡。我们希望小一些的树接到大一些的树下面，这样就能避免头重脚轻，更平衡一些。解决方法是额外使用一个 <code>size</code> 数组，记录每棵树包含的节点数，不妨称为「重量」：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="comment">// 新增一个数组记录树的“重量”</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UF</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">// 最初每棵树只有一个节点</span></span><br><span class="line">        <span class="comment">// 重量应该初始化 1</span></span><br><span class="line">        size = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            size[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 其他函数 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如 <code>size[3] = 5</code> 表示，以节点 <code>3</code> 为根的树总共有 5 个节点。修改一下 <code>union</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">    <span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 小树接到大树下面，较平衡</span></span><br><span class="line">    <span class="keyword">if</span> (size[rootP] &gt; size[rootQ]) &#123;</span><br><span class="line">        parent[rootQ] = rootP;</span><br><span class="line">        size[rootP] += size[rootQ];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent[rootP] = rootQ;</span><br><span class="line">        size[rootQ] += size[rootP];</span><br><span class="line">    &#125;</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，通过比较树的重量，就可以保证树的生长相对平衡，树的高度大致在 <code>logN</code> 这个数量级，极大提升执行效率。</p>
<p>此时 <code>find</code> , <code>union</code> , <code>connected</code> 的时间复杂度都下降为 <code>O(logN)</code>。</p>
</br>


<h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p><strong>其实我们并不在乎每棵树的结构长什么样，只在乎根节点。</strong></p>
<p>因为无论树长什么样，树上的每个节点的根节点都是相同的，所以可以进一步压缩每棵树的高度，使树高始终保持为常数。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/17/6d93bfc2a8d5292c.png#crop=0&crop=0&crop=1&crop=1&id=mJjPQ&originHeight=366&originWidth=1458&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>这样每个节点的父节点就是整棵树的根节点，<code>find</code> 就能以 <code>O(1)</code> 的时间找到某一节点的根节点，相应的，<code>connected</code> 和 <code>union</code> 复杂度都下降为 <code>O(1)</code>。</p>
<p>要做到这一点主要是修改 <code>find</code> 函数逻辑.</p>
<p>第一种是在 <code>find</code> 中加一行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (parent[x] != x) &#123;</span><br><span class="line">        <span class="comment">// 这行代码进行路径压缩</span></span><br><span class="line">        parent[x] = parent[parent[x]];</span><br><span class="line">        x = parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次 while 循环都会把一对父子节点改到同一层，这样每次调用 <code>find</code> 函数向树根遍历的同时就将树高缩短了。</p>
<p>路径压缩的第二种写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">        parent[x] = find(parent[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>翻译成迭代：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// 先找到根节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> x;</span><br><span class="line">    <span class="keyword">while</span> (parent[root] != root) &#123;</span><br><span class="line">        root = parent[root];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 然后把 x 到根节点之间的所有节点直接接到根节点下面</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">old_parent</span> <span class="operator">=</span> parent[x];</span><br><span class="line">    <span class="keyword">while</span> (x != root) &#123;</span><br><span class="line">        parent[x] = root;</span><br><span class="line">        x = old_parent;</span><br><span class="line">        old_parent = parent[old_parent];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比起第一种路径压缩，显然这种方法压缩得更彻底，直接把一整条树枝压平。就算一些极端情况下产生了一棵比较高的树，只要一次路径压缩就能大幅降低树高，从摊还分析的角度来看，所有操作的平均时间复杂度依然是 <code>O(1)</code>。</p>
<p>另外，如果使用路径压缩技巧，那么 size 数组的平衡优化就不是特别必要了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">    <span class="comment">// 连通分量个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="comment">// 存储每个节点的父节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// n 为图中节点的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UF</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将节点 p 和节点 q 连通</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        parent[rootQ] = rootP;</span><br><span class="line">        <span class="comment">// 两个连通分量合并成一个连通分量</span></span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断节点 p 和节点 q 是否连通</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">        <span class="type">return</span> <span class="variable">rootP</span> <span class="operator">=</span>= rootQ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">            parent[x] = find(parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回图中的连通分量个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Union-Find 算法的复杂度的分析：构造函数初始化数据结构需要 <code>O(N)</code> 的时间和空间复杂度；连通两个节点 <code>union</code>、判断两个节点的连通性 <code>connected</code>、计算连通分量 <code>count</code> 所需的时间复杂度均为 <code>O(1)</code>。</p>
<p>优化算法的过程：</p>
<ol>
<li>用 <code>parent</code> 数组记录每个节点的父节点，相当于指向父节点的指针，所以 <code>parent</code> 数组内实际存储着一个森林（若干棵多叉树）。 </li>
<li>用 <code>size</code> 数组记录着每棵树的重量，目的是让 <code>union</code> 后树依然拥有平衡性，保证各个 API 时间复杂度为 <code>O(logN)</code>，而不会退化成链表影响操作效率。 </li>
<li>在 <code>find</code> 函数中进行路径压缩，保证任意树的高度保持在常数，使得各个 API 时间复杂度为 <code>O(1)</code>。使用了路径压缩之后，可以不使用 size 数组的平衡优化。</li>
</ol>
</br>


<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9HcmFwaC8zMjMuJUU2JTk3JUEwJUU1JTkwJTkxJUU1JTlCJUJFJUU0JUI4JUFEJUU4JUJGJTlFJUU5JTgwJTlBJUU1JTg4JTg2JUU5JTg3JThGJUU3JTlBJTg0JUU2JTk1JUIwJUU3JTlCJUFFLmphdmE=">323.无向图中连通分量的数目<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9udW1iZXItb2YtY29ubmVjdGVkLWNvbXBvbmVudHMtaW4tYW4tdW5kaXJlY3RlZC1ncmFwaC8=">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/17/b74a073b1f32239f.png#crop=0&crop=0&crop=1&crop=1&id=wnIQO&originHeight=1068&originWidth=1460&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>可以直接使用 UF 类来解决：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countComponents</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line">    <span class="type">UF</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UF</span>(n);</span><br><span class="line">    <span class="comment">// 将每个节点进行连通</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] e : edges) &#123;</span><br><span class="line">        uf.union(e[<span class="number">0</span>], e[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回连通分量的个数</span></span><br><span class="line">    <span class="keyword">return</span> uf.count();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<p>另外，一些使用 DFS 深度优先算法解决的问题，也可以用 Union-Find 算法解决。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9HcmFwaC8xMzAuJUU4JUEyJUFCJUU1JTlCJUI0JUU3JUJCJTk1JUU3JTlBJTg0JUU1JThDJUJBJUU1JTlGJTlGLmphdmE=">130.被围绕的区域<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdXJyb3VuZGVkLXJlZ2lvbnMv">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/17/d9305aef676d77d3.png#crop=0&crop=0&crop=1&crop=1&id=rzot8&originHeight=1146&originWidth=1432&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>必须是四面被围的 <code>O</code> 才能被换成 <code>X</code>，也就是说边角上的 <code>O</code> 一定不会被围，进一步，与边角上的 <code>O</code> 相连的 <code>O</code> 也不会被 <code>X</code> 围四面，也不会被替换。</p>
<p>先用 for 循环遍历棋盘的四边，用 DFS 算法把那些与边界相连的 <code>O</code> 换成一个特殊字符，比如 <code>#</code>；然后再遍历整个棋盘，把剩下的 <code>O</code> 换成 <code>X</code>，把 <code>#</code> 恢复成 <code>O</code>。这样就能完成题目的要求，时间复杂度 <code>O(MN)</code>。</p>
<p>可以把所有靠边的 <code>O</code> 和一个虚拟节点 <code>dummy</code> 进行连通：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/17/55715f2b73aa74f7.png#crop=0&crop=0&crop=1&crop=1&id=HvjrS&originHeight=696&originWidth=1070&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>然后再遍历整个 board，那些和 dummy 不连通的 O 就是被围绕的区域，需要被替换。</p>
<p>Union-Find 底层用的是一维数组，构造函数需要传入这个数组的大小，而题目给的是一个二维棋盘。</p>
<p>二维坐标 <code>(x,y)</code> 可以转换成 <code>x * n + y</code> 这个数（<code>m</code> 是棋盘的行数，<code>n</code> 是棋盘的列数）。<strong>这是将二维坐标映射到一维的常用技巧</strong>。</p>
<p>其次，索引 <code>[0.. m*n-1]</code> 都是棋盘内坐标的一维映射，因此虚拟的 <code>dummy</code> 节点占据索引 <code>m * n</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (board.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> board.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">// 给 dummy 留一个额外位置</span></span><br><span class="line">    <span class="type">UF</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UF</span>(m * n + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">dummy</span> <span class="operator">=</span> m * n;</span><br><span class="line">    <span class="comment">// 将首列和末列的 O 与 dummy 连通</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            uf.union(i * n, dummy);</span><br><span class="line">        <span class="keyword">if</span> (board[i][n - <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            uf.union(i * n + n - <span class="number">1</span>, dummy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将首行和末行的 O 与 dummy 连通</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[<span class="number">0</span>][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            uf.union(j, dummy);</span><br><span class="line">        <span class="keyword">if</span> (board[m - <span class="number">1</span>][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            uf.union(n * (m - <span class="number">1</span>) + j, dummy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方向数组 d 是上下左右搜索的常用手法</span></span><br><span class="line">    <span class="type">int</span>[][] d = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">0</span>,-<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) </span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                <span class="comment">// 将此 O 与上下左右的 O 连通</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> i + d[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> j + d[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (board[x][y] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                        uf.union(x * n + y, i * n + j);</span><br><span class="line">                &#125;</span><br><span class="line">    <span class="comment">// 所有不和 dummy 连通的 O，都要被替换</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) </span><br><span class="line">            <span class="keyword">if</span> (!uf.connected(dummy, i * n + j))</span><br><span class="line">                board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>


<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Nzc3N2MTEvQWxnb3JpdGhtTm90ZS9ibG9iL21hc3Rlci9HcmFwaC85OTAuJUU3JUFEJTg5JUU1JUJDJThGJUU2JTk2JUI5JUU3JUE4JThCJUU3JTlBJTg0JUU1JThGJUFGJUU2JUJCJUExJUU4JUI2JUIzJUU2JTgwJUE3LmphdmE=">990.等式方程的可满足性<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zYXRpc2ZpYWJpbGl0eS1vZi1lcXVhbGl0eS1lcXVhdGlvbnMv">🔗<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/17/6c03e9cdcc2194b5.png#crop=0&crop=0&crop=1&crop=1&id=nHKU5&originHeight=688&originWidth=1442&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>动态连通性其实就是一种等价关系，具有「自反性」「传递性」和「对称性」，<code>==</code> 关系也是一种等价关系，具有这些性质。所以这个问题适合使用 Union-Find 算法。</p>
<p>核心思想是，将 <code>equations</code> 中的算式根据 <code>==</code> 和 <code>!=</code> 分成两部分，先处理 <code>==</code> 算式，使得他们通过相等关系各自关联（连通分量）；然后处理 <code>!=</code> 算式，检查不等关系是否破坏了相等关系的连通性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">equationsPossible</span><span class="params">(String[] equations)</span> &#123;</span><br><span class="line">    <span class="comment">// 26 个英文字母</span></span><br><span class="line">    <span class="type">UF</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UF</span>(<span class="number">26</span>);</span><br><span class="line">    <span class="comment">// 先让相等的字母形成连通分量</span></span><br><span class="line">    <span class="keyword">for</span> (String eq : equations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eq.charAt(<span class="number">1</span>) == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">x</span> <span class="operator">=</span> eq.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="type">char</span> <span class="variable">y</span> <span class="operator">=</span> eq.charAt(<span class="number">3</span>);</span><br><span class="line">            uf.union(x - <span class="string">&#x27;a&#x27;</span>, y - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查不等关系是否打破相等关系的连通性</span></span><br><span class="line">    <span class="keyword">for</span> (String eq : equations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eq.charAt(<span class="number">1</span>) == <span class="string">&#x27;!&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">x</span> <span class="operator">=</span> eq.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="type">char</span> <span class="variable">y</span> <span class="operator">=</span> eq.charAt(<span class="number">3</span>);</span><br><span class="line">            <span class="comment">// 如果相等关系成立，就是逻辑冲突</span></span><br><span class="line">            <span class="keyword">if</span> (uf.connected(x - <span class="string">&#x27;a&#x27;</span>, y - <span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>Buy me a coffee</div>
  <button onclick="document.querySelector('.post-reward').classList.toggle('active');">
    Donate
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="Ssssv11 WeChat Pay">
        <span>WeChat Pay</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"><i class="fa fa-tag"></i> 算法</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/05/18/JUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7/" rel="prev" title="JUC并发工具">
                  <i class="fa fa-chevron-left"></i> JUC并发工具
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ssssv</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script size="90" alpha="0.6" zIndex="-1" src="/js/ribbon/ribbon.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="/js/local-search.js"></script>






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>

<script src="/js/cursor/fireworks.js"></script>

